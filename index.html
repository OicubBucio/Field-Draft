

<!DOCTYPE html>

<!-- GPT-LEAN BUILD: commentary trimmed; code/behavior identical to GPTOPT_P4. Keep anchors/guards/contract. -->
<!--
LLM FAST INDEX (GPT-Optimized Locator · Truncation-safe)
- Truncation guards (search):
  TRUNC_GUARD::HEAD_END / TRUNC_GUARD::BODY_END / TRUNC_GUARD::HTML_END

- Primary edit surfaces (V-SOT: prefer these):
  CSS PART 13.SUBCHUNK A / A.1
  CSS PART 13.SUBCHUNK B / B.1 / B.2
  CSS PART 13.SUBCHUNK C / C.1 / C.1a / C.2
  CSS PART 13.SUBCHUNK D / E
  CSS PART 13.SUBCHUNK F / F.1 / F.2
  CSS PART 13.SUBCHUNK G / H
  CSS PART 13.SUBCHUNK THEME-SURFACES / READABILITY

CHUNK LOCATOR TABLE (use Search in-file; anchors are exact strings)

NOTE (GPT SAFETY): Inline JS is split into multiple <script> /*
blocks to reduce truncation risk.
  - Script 1 parts: search "SCRIPT PART 1.1 BEGIN" … "SCRIPT PART 1.3 END"
  - Script 2 parts: search "SCRIPT PART 2.1 BEGIN" … "SCRIPT PART 2.4 END"
- SCRIPT PART 1 (DOM refs + contracts + UI bindings):
  Anchor: "SCRIPT PATCH P4C BEGIN"
  Contract table: "SUB-CHUNK 1.REQ BEGIN"
  End anchor: "SCRIPT PART 1 END (LLM ANCHOR)"

- SCRIPT PART 2 (Interaction + Save/Load):
  Start anchor: "FIELD DRAFT v1.0 · SCRIPT PART 2"
  Tool routing (mouse/touch): "chunk 11"
  Inspector UI wiring: "chunk 14"
  Save schema + storage: "chunk 19"
  Load/import + hash: "chunk 20"
  End anchor: "SCRIPT PART 2 END (LLM ANCHOR)"

Notes
- Prefer bounded edits inside SUB-CHUNK BEGIN/END fences.
- If a requested target lacks a BEGIN/END fence, add fences first, then edit inside them.
End.
-->
<html lang="en" data-build="Field Draft v1.0">
<head>
  <meta charset="UTF-8" />
  <!-- APP IDENTITY START — HEAD TITLE -->
  <title>Field Draft v1.0 · Field Ops</title>
  <!-- APP IDENTITY END — HEAD TITLE -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- SUB-CHUNK 0.PWA BEGIN - PWA bootstrap (manifest + theme + SW reg) -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#020617">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Field Draft">
  <link rel="apple-touch-icon" href="icons/icon-192.png">

  <script>
  // PWA: register service worker when hosted on HTTPS (or localhost).
  // NOTE: file:// and insecure origins will skip registration (expected).
  (function(){
    try{
      if (!('serviceWorker' in navigator)) return;
      if (!window.isSecureContext && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') return;
      window.addEventListener('load', function(){
        navigator.serviceWorker.register('sw.js').catch(function(){});
      });
    }catch(_){ }
  })();
  </script>
  <!-- SUB-CHUNK 0.PWA END - PWA bootstrap (manifest + theme + SW reg) -->


<!--
SUB-CHUNK 0.A BEGIN — Canonical navigation block (Cognitive Layers + Structure Map)
FD_TAG: field-draft_UPDATED-14 | 2025-12-22 | line options moved to Button 1; Draw has Line entry
COGNITIVE LAYERS (Archive-owned)
- CL-01 (CCL): Canonical ledger lives ONCE above CSS PART 13 (inside <style>
html{height:100%; overflow:hidden; overscroll-behavior:none;}
 as CSS comment).
- CL-02 (DPA): Anchors inserted only by Archive at edit choke points.
- Archive responsibility: maintain CL layers as part of every edit package (CL Status + CL Patch if changed).

FIELD DRAFT · STRUCTURE MAP (Canonical / Current)

SUB-CHUNK INDEX (append-only)
- SUB-CHUNK 0.A : This canonical navigation block (wraps everything below)
- SUB-CHUNK 3.A : CSS part 3 — Buttons base styles
- SUB-CHUNK 3.B : CSS part 3 — Dropdown menu (<details>) styles
- SUB-PART 2.A  : HTML PART 2 — Topbar CENTER stack X placeholder buttons (Button 1–4)
- SUB-PART 2.B  : HTML PART 2 — Topbar CENTER stack B status + mode slot (Units/Snap/Axis/Mode/Button 4)- SUB-CHUNK 2.C : HTML PART 2 — Context rail Auto toggle (Axis-lock style)
- SUB-CHUNK 2.D : HTML PART 2 — Persistent angle/dist rows (never disappear; disable when inactive)
- SUB-CHUNK 11.1C : SCRIPT chunk 11 — Auto-commit line segments (2-tap commit)

MARKER STANDARD (search-safe)
- Part headers:  "HTML PART X" / "CSS part X" / "SCRIPT PART X"
- Part footers:  "HTML end part X" / "CSS end part X" / "SCRIPT END PART X"
  (Reason: searching "HTML PART X" matches only the header, not the footer.)
- Chunk headers: "chunk N"
- Chunk footers: "chunk end N"
- If an END marker is missing, the boundary is the next Part/Chunk header.
- PROTECT comments mark structural closing tags that must not move.

NOTE (Marker Hygiene)
- This file intentionally uses mixed-case conventions (e.g., "CSS part 1" in CSS comments).
- We DO NOT mass-normalize casing across the entire file in one pass.
- New markers added by Archive must follow this map, and existing markers should be normalized only
  when their containing Part/Chunk is being replaced for another reason (avoids risky global churn).

CSS PARTS (inside <style>)
- CSS part 1   : Global reset + theme tokens + header + main padding reserve
- CSS part 2   : Top control bar (topbar) + context toolspace
- CSS part 3   : Buttons + dropdown menu (<details>) styling
- CSS part 4   : Main layout (work-layout grid + sidebar + right panel overlay shell)
- CSS part 5   : Tool & edit groups (left sidebar tool rows)
- CSS part 6   : Canvas shell + container + canvas element
- CSS part 7   : Canvas overlays (measurement overlay card)
- CSS part 8   : Status bar (fixed bottom)
- CSS part 9   : Shared form bits (inputs/selects/mono)
- CSS part 10  : Right sidebar internals (props + layers)
- CSS part 11  : Full-board view mode
- CSS part 12  : Responsive adjustments (tablet/mobile)
- CSS PART 13  : V-SOT skin overrides (do visual tuning here)

HTML PARTS (inside <main>)
- HTML PART 1  : Topbar LEFT (Draft name + File menu + Feature cluster + View board)
- HTML PART 2  : Topbar RIGHT (Labels + Symbols + Scale + Panel + Quick + Context)
  - SUB-PART 2.A : Topbar CENTER stack X placeholder buttons (Button 1–4)
  - SUB-PART 2.B : Topbar CENTER stack B status + mode slot (Units/Snap/Axis/Mode/Button 4)

WORK LAYOUT GRID (single container)
- HTML part 3      : STARTS .work-layout + LEFT SIDEBAR Tools section (opens <div class="work-layout"> and <aside id="leftSidebar">)
- HTML part 4      : LEFT SIDEBAR Edit section (inside left sidebar)
- HTML part 5      : LEFT SIDEBAR CLOSE (PROTECT closes </aside>)
- HTML part 6      : CENTER canvas + measure overlay
- HTML part 7      : RIGHT SIDEBAR begins (opens <aside id="rightSidebar"> + Properties header block)
- HTML part 8      : Properties · Line fields
- HTML part 9      : Properties · Symbol fields
- HTML part 10     : Properties · Area fields
- HTML part 11     : Properties · Label fields
- HTML PART 12     : Layers panel (right sidebar)
- HTML PART 13     : Job link panel + RIGHT SIDEBAR CLOSE + WORK-LAYOUT CLOSE
                    (PROTECT closes </div> for .work-layout)
- HTML part 14     : Bottom status bar + main structural close + exit full view

PROTECT TAGS (structural)
- LEFT SIDEBAR close: </aside> (HTML part 5)
- WORK LAYOUT close: </div> that closes .work-layout (inside HTML PART 13)
- MAIN close: </main> (HTML part 14)

SCRIPT PARTS
- SCRIPT PART 1 : State, geometry, drawing, inspector, hit-testing, edit modes
                 (chunks 1–10)
- SCRIPT PART 2 : Interaction handlers, view/zoom/pan, save/load/export, init
                 (chunks 11–20)

SCRIPT CHUNKS (current; each ends with "chunk end N")
- chunk 1   : Core DOM refs
- chunk 2   : State + debug exposure + transient edit state
- chunk 3   : Coordinates + geometry helpers + snapping base
- chunk 4   : History (undo/redo)
- chunk 5   : Status + units labels + toolspace switching
- chunk 6   : Resize & grid
- chunk 7   : Drawing features + overlays + main draw()
  - 7.1 Lines & areas
  - 7.2 Symbols
  - 7.3 Labels + measure + current path + move guide + orchestrator
- chunk 8   : Feature dropdown + inspector binding
- chunk 9   : Hit testing + vertex helpers
- chunk 10  : Edit mode actions + inspect routing

- chunk 11  : Interaction (mouse + touch)
- chunk 13  : Finish path + delete + clear + undo/redo wiring
- chunk 14  : Inspector field events (units-aware conversions)
- chunk 15  : Feature select change
- chunk 16  : Tool & edit button events + bottom status interactions
- chunk 17  : View / zoom / layers / panel toggle
- chunk 18  : Full-board view toggle
- chunk 19  : Save/load/export/Records/Costing
 
SUB-CHUNK QUICKJUMPS (added for GPT edit/audit efficiency; comment-only structure)
- CHUNK 1 tiering:
  - 1.REQ  (line ~3122) : Contract lint + hard required IDs table
  - 1.UI1  (line ~3151) : Core UI refs (canvas/topbar/menus/status)
  - 1.OPT  (line ~3193) : Optional/legacy refs (guarded || null)
  - 1.PP1  (line ~3285) : Properties panel / inspector refs wrapper
- CHUNK 10 routing bay:
  - 10.R1  (line ~5981) : Inspect/nav/move-shape/edit routing (bounded inside chunk 10)
- CHUNK 11 surgical bays:
  - 11.P1  (line ~7625) : PointerDown / capture setup
  - 11.P2  (line ~7636) : PointerMove / live interaction
  - 11.P3  (line ~7720) : PointerUp / commit cleanup
  - 11.T1  (line ~7942) : Touchstart handler
  - 11.T2  (line ~8078) : Touchmove handler
  - 11.T3  (line ~8167) : Touchend handler
- CHUNK 16 wrapper bays:
  - 16.D1  (line ~8692) : Tool selection dispatch wiring
  - 16.E1  (line ~10222) : Edit mode button wiring (wraps 16.1d–16.1i)
  - 16.S1  (line ~10305) : Bottom status bar interactions (Snap/Units)
 
- chunk 20  : Init + restore-from-hash + first draw
SUB-CHUNK 0.A END — Canonical navigation block (Cognitive Layers + Structure Map)

SUB-CHUNK 0.B BEGIN — Security Manifest + Integrity Constitution (SEC v1)
RD_SEC_TAG: RD_SEC_v1 | 2025-12-22 | governance-only (no runtime changes)

SEC-00 — CONSTITUTION (enforced by process + sentinel)
S0) BOUNDED EDITS ONLY
- All edits must be confined to existing Part/Chunk/Sub-Chunk boundaries.
- If an END marker is missing, boundary extends to the next BEGIN marker.

S1) MANIFEST REQUIRED ON TOUCH
- Any time a tracked block is edited, its SHA-256 MUST be recomputed and updated in

SEC-MANIFEST v1.4 (Tracked Blocks + SHA-256)
NOTE: Hashes cover the bounded text INCLUDING the BEGIN/END marker lines for each tracked block.
DEFINITION: FILE_SHA256 is computed over the full file EXCLUDING this SEC block (SUB-CHUNK 0.B) from its BEGIN marker line through its END marker line, inclusive.
SEARCH RULE: When extracting tracked blocks for verification, begin searching only AFTER the SEC END marker line to avoid matching tokens that appear inside this manifest text.

- FILE_SHA256 (payload-excluding-SEC): b5030eb861185424b578a200a20cb8e0b22817eb9346872a988d6d4460f18524

1) BLOCK: CL-01 Cognitive Layer (CCL governance)
   BEGIN: [COGNITIVE_LAYER:CL-01|NAME:CCL|VER:1.4|SCOPE:GLOBAL|OWNER:Archive|INTENT:Continuity+Drift-Control]
   END:   [/COGNITIVE_LAYER]
   SHA256: 718544b7fcd1e51407e0f89fe854c3f4136925f00e4dd7d9288b54a1316e828d

2) BLOCK: CL-02 DPA@V-SOT
   BEGIN: [COGNITIVE_LAYER:CL-02|NAME:DPA@V-SOT|VER:1.0]
   END:   [/COGNITIVE_LAYER]
   SHA256: 7ecbd4197ac7e17e16a437630333628cb3384def67a3f0f59c2a23e922d5edb9

3) BLOCK: CL-02 DPA@STATUS
   BEGIN: [COGNITIVE_LAYER:CL-02|NAME:DPA@STATUS|VER:1.0]
   END:   [/COGNITIVE_LAYER]
   SHA256: ca6ca750767cf65343f48b7d68d3da544990cae2e251bab2c55e6bcb563b2cd4

4) BLOCK: CL-02 DPA@BINDINGS
   BEGIN: [COGNITIVE_LAYER:CL-02|NAME:DPA@BINDINGS|VER:1.0]
   END:   [/COGNITIVE_LAYER]
   SHA256: d4a7ed5a03a449b11de408d622a8874e039dab1855890745ae741ac6525c6114

5) BLOCK: CL-02 DPA@SAVELOAD
   BEGIN: [COGNITIVE_LAYER:CL-02|NAME:DPA@SAVELOAD|VER:1.0]
   END:   [/COGNITIVE_LAYER]
   SHA256: 25c667d5f2b2f2c21a2839f9632d7f3b06423bca5c9dd9aa2a8c3f6ddfdfd584

6) BLOCK: SUB-CHUNK 16.B1 Bend tool wiring + UI binding
   BEGIN: SUB-CHUNK 16.B1 BEGIN
   END:   SUB-CHUNK 16.B1 END
   SHA256: 98f1aad5fa0ff097ce34457832341042a46d4de52331563f6c12afc961f98171

7) BLOCK: SUB-CHUNK 20.S2 Persistence / save-load / exports
   BEGIN: SUB-CHUNK 20.S2 BEGIN
   END:   SUB-CHUNK 20.S2 END
   SHA256: 6d90414a0bf7a55d0c6a4ad4a7268676e741e8e7cf81268fb653c83851e229e0

CHANGE RECEIPT
- LABEL: DUP-C (Wrapper Unification: getAngleDistOverrideMetersForMove)
- TOUCH: Converted getAngleDistOverrideMetersForMove into a wrapper calling getAngleDistOverrideMeters (single-authority dist override helper). Updated SEC payload hash.
- VERIFY: HASH-PASS (tool-side recompute) | 2026-01-01

- LABEL: DUP-B (Wrapper Unification: snapDeltaGridMouse + applyMoveShapeSnapMouse)
- TOUCH: Converted remaining duplicate Mouse helpers into wrappers (single-authority helpers). Updated SEC payload hash.
- VERIFY: HASH-PASS (tool-side recompute) | 2026-01-01

- LABEL: DUP-A (Wrapper Unification: Mouse alias consolidation)
- TOUCH: Converted duplicate helper implementations into wrappers (single-authority helpers). Updated SEC payload hash.
- VERIFY: HASH-PASS (tool-side recompute) | 2026-01-01

SUB-CHUNK 0.B END — Security Manifest + Integrity Constitution (SEC v1)
-->

  <!-- Records integration loader (standalone-safe)
       - Default: DISABLED (no fetch, no console 404 noise)
       - Hub can enable by setting window.FIELDOPS_ENABLE_RECORDS = true BEFORE this file runs,
         or by injecting records-core.js and providing window.FieldOpsRecords.
  -->
  <script>
  (function(){
    try {
      if (!window.FIELDOPS_ENABLE_RECORDS) return;
      var s = document.createElement('script');
      s.src = 'records-core.js';
      s.async = true;
      s.onload = function(){ console.log('[FieldDraft] Records core loaded'); };
      s.onerror = function(){ console.warn('[FieldDraft] Records core missing; continuing without Records.'); };
      document.head.appendChild(s);
    } catch (e) {
      /* no-op */
    }
  })();
  </script>

  <style>
/* CSS part 1 */
/* Global reset + theme tokens + header + main padding reserve */

* {
  box-sizing: border-box;
  font-family: system-ui, -apple-system, BlinkMacSystemFont,
    "Segoe UI", sans-serif;
}

:root {
  /* Core background + ink */
  --bg: #020617;
  --bg-alt: #020617;
  --bg-elevated: #020617;
  --ink: #e5e7eb;

  /* Muted text */
  --muted: #9ca3af;
  --muted-soft: #6b7280;

  /* Borders */
  --border: #1f2937;
  --border-soft: #111827;

  /* Accent system */
  --accent: #2563eb;
  --accent-soft: rgba(37, 99, 235, 0.15);
  --accent-strong: rgba(37, 99, 235, 0.25);
  --accent-warn: #f97316;
  --accent-good: #22c55e;

  /* Radius tokens */
  --radius-lg: 16px;
  --radius-md: 12px;
  --radius-sm: 999px;

  /* UI surface tokens (FIXED — required by status bar + pills) */
  --panel: rgba(2, 6, 23, 0.96);
  --chip: rgba(15, 23, 42, 0.85);

  /* THEME CONTRACT V4 — control + preview + semantic tokens */
  --control-bg: var(--chip);
  --control-border: var(--border);
  --control-ink: var(--ink);

  --preview-bg: var(--chip);
  --preview-border: var(--border);
  --preview-track-bg: rgba(0,0,0,0.10);
  --preview-line: var(--ink);

  --page-vignette-tail: var(--bg-elevated);

  --sem-truth: #0000ff;
  --sem-hint: #00ff00;
  --sem-on-truth: #e5f0ff;
}

body {
  margin: 0;
  height: 100dvh;
  height: calc(var(--app-vh, 1vh) * 100);
  min-height: 0;
  overflow: hidden;
  overscroll-behavior: none;
background: radial-gradient(circle at top, var(--bg) 0, var(--bg-elevated) 65%);
  color: var(--ink);
  display: flex;
  flex-direction: column;
}

/* Header branding bar */
/* CSS part 1.HDR BEGIN — Branding bar density */
/* PROTECT: chrome is sticky/z-indexed; header/topbar may not overlap or reorder. */
.chrome{
  position: sticky;
  top: 0;
  z-index: 20;
  background: rgba(2, 6, 23, 0.96);
  backdrop-filter: blur(12px);
  border-bottom: 1px solid var(--border);
}

/* Header branding bar (now lives inside .chrome) */
header {
  padding: 6px 12px 6px; /* thinner bar */
  background: transparent;
  border-bottom: none;

  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;              /* tighter */
  position: static;       /* sticky moved to .chrome */
}

.title-block {
  display: flex;
  flex-direction: column;
  gap: 2px; /* tighter */
}

.title-main {
  font-size: 13px;       /* thinner look */
  font-weight: 600;
  letter-spacing: 0.14em;
  text-transform: uppercase;
}

.title-sub {
  font-size: 10px;       /* thinner look */
  color: var(--muted);
}

.header-right {
  display: flex;
  align-items: center;
  gap: 4px;              /* tighter */
  flex-wrap: wrap;
}

.badge-env {
  font-size: 9px;        /* thinner */
  padding: 1px 6px;      /* thinner */
  border-radius: 999px;
  border: 1px solid #374151;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--muted);
  white-space: nowrap;
}

a.hub-link {
  color: #93c5fd;
  font-size: 10px;       /* slightly smaller */
  text-decoration: none;
  border-radius: 999px;
  border: 1px solid #1f2937;
  padding: 3px 9px;      /* thinner */
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background: rgba(15, 23, 42, 0.95);
}

a.hub-link:hover {
  background: #020617;
  border-color: #374151;
}
/* CSS part 1.HDR END — Branding bar density */

/* PROTECT: bottom status bar is fixed; reserve space so canvas never hides under it */
main {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
  padding-bottom: 48px; /* keep in sync with .status-bar height */
}

/* CSS end part 1 */

/* CSS part 2 */

/* CSS part 2.1 */
/* Topbar grid spine + columns */
.topbar {
  padding: 8px 16px 6px;
  border-bottom: 1px solid var(--border);
  background: var(--panel) !important;

  /* Deterministic 3-column spine */
  display: grid;
  grid-template-columns:
    minmax(240px, 0.85fr)   /* LEFT rail */
    minmax(360px, 1.55fr)   /* CENTER dropdown zone */
    minmax(195px, 0.68fr);  /* RIGHT snap rail (↓ ~25%) */
  gap: 12px;

  align-items: start;
  min-width: 0;
}

/* NEW: Tools-hidden mode (branding remains; toolbar collapses cleanly) */
body.tools-hidden .topbar{ display:none; }
/* CSS end part 2.1 */

/* CSS part 2.2 */
/* Column containers + rows */
.topbar-left,
.topbar-center,
.topbar-right {
  display: flex;
  flex-direction: column;
  gap: 8px;
  min-width: 0;
}

/* LEFT rail rows */
.topbar-left .topbar-group {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: nowrap;
  min-width: 0;
}

.topbar-group.scale-group {
  align-items: flex-start;
}
.scale-stack {
  display: flex;
  flex-direction: column;
  gap: 6px;
  min-width: 0;
}
.scale-row {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: nowrap;
  min-width: 0;
}
/* CENTER dropdown zone */
.topbar-center .topbar-group {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
  min-width: 0;
}

/* RIGHT snap rail */
.topbar-right .topbar-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: stretch;
  min-width: 0;
}
/* CSS end part 2.2 */

/* CSS part 2.3 */
/* Labels + pills + selects */
.rail-label {
  display: none;
}

.input-pill {
  background: var(--control-bg);
  border-radius: 999px;
  border: 1px solid var(--control-border);
  color: var(--control-ink);
  font-size: 11px;
  padding: 4px 10px;
  min-width: 0;
}

/* Grid opacity slider */
.input-pill input[type="range"]{
  width: 100%;
  min-width: 120px;
  height: 20px;
  background: transparent;
  padding: 0;
  margin: 0;
}

.input-pill input[type="text"],
.input-pill input[type="number"] {
  background: transparent;
  border: none;
  outline: none;
  color: inherit;
  font-size: inherit;
  padding: 0;
  min-width: 120px;
}

.input-pill input[type="number"] {
  width: 70px;
  text-align: right;
}

.input-pill span.unit {
  margin-left: 4px;
  color: var(--muted-soft);
}

.select-pill {
  background: var(--control-bg);
  border-radius: 999px;
  border: 1px solid var(--control-border);
  color: var(--ink);
  font-size: 11px;
  padding: 3px 8px;
  min-width: 0;
  flex: 1 1 auto;
}

.select-pill select {
  width: 100%;
  background: transparent !important;
  border: none !important;
  outline: none !important;
  color: inherit;
  font-size: inherit;
  min-width: 0;
}
/* CSS end part 2.3 */

/* CSS part 2.4 */
/* Snap pills + lock button + toolspace box */
.snap-pill {
  width: 100%;
  display: inline-flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;

  padding: 2px 8px;
  border-radius: 999px;
  font-size: 11px;

  background: var(--control-bg);
  border: 1px solid var(--control-border);
  user-select: none;
}

.snap-pill .value {
  font-weight: 700;
}

.topbar .status-pill {
  width: 100%;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: nowrap; /* PROTECT: status must remain single-line */
  min-width: 0;      /* PROTECT: allow ellipsis to work in flex */
}
.topbar .status-pill:hover {
  border-color: #4b5563;
}

#lockAxisBtn {
  width: 100%;
  justify-content: space-between;
}

.context-toolspace {
  align-items: stretch;
}

.context-box {
  
  --ink:#ffffff;
  --muted:#e5e7eb;
/* Token scope: this panel stays dark across themes; keep its text readable */
  color:#ffffff;
  --muted-soft:#cbd5e1;

  border: 1px solid #374151;
  border-radius: 16px;
  background: rgba(15,23,42,0.95);
  padding: 5px 8px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  min-width: 0;
}

/* Context toolspace: pills must not use global ink in light themes */
.context-box .input-pill,
.context-box .select-pill{
  color: inherit;
}
.context-box .input-pill span.unit{
  color: var(--muted-soft);
}

/* Context toolspace: force form controls to inherit readable text on the dark panel */
.context-box input,
.context-box select,
.context-box textarea{
  color: inherit;
}
.context-box input::placeholder,
.context-box textarea::placeholder{
  color: var(--muted-soft);
}

.context-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}

.context-key {
  font-size: 10px;
  color: var(--muted-soft);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  white-space: nowrap;
}

.context-na {
  color: var(--muted);
  opacity: 0.9;
}

.context-angle-presets {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  justify-content: flex-end;
}

.btn-xs {
  padding: 4px 8px;
  font-size: 11px;
}
/* CSS end part 2.4 */

/* CSS part 2.5 */
/* Tablet tightening */
@media (max-width: 980px) {
  .topbar { grid-template-columns: 1fr; }
  .input-pill input[type="text"] { min-width: 90px; }
}
/* CSS end part 2.5 */

/* CSS part 2.6 */
/* Center stacks (vertical) */
.topbar-center .topbar-group.center-stack{
  flex-direction: column;
  align-items: stretch;
  gap: 8px;
}
.topbar-center .topbar-group.center-stack select,
.topbar-center .topbar-group.center-stack .btn{
  width: 100%;
}
/* CSS end part 2.6 */

/* CSS part 2.7 */
/* Center grid (stack columns) — MUST match number of stacks in HTML */
.topbar-center .center-grid{
  display: grid;
  /* 4 stacks side-by-side: A | Y | MID | B */
  grid-template-columns:
    minmax(0, 1fr)
    minmax(0, 1fr)
    minmax(0, 1fr)
    minmax(0, 1fr);
  gap: 10px;
  align-items: start;
  min-width: 0;
}
.topbar-center .center-grid .topbar-group.center-stack{
  margin: 0;
}
/* CSS end part 2.7 */

/* CSS part 2.8 */
/* Snap menu sizing */
#snapModeMenu.drop-menu { width: 100%; }
#snapModeMenu .drop-panel { left: 0; right: auto; }
/* CSS end part 2.8 */

/* CSS end part 2 */

/* Buttons CSS part 3 ---------------------------------------------------------------- */

    /* SUB-CHUNK 3.A BEGIN — Buttons base styles */
.btn {
  padding: 5px 10px;
  border-radius: 999px;
  font-size: 11px;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 5px;
  white-space: nowrap;
}
.btn:hover {
  /* Visual/skin is single-authority in CSS PART 13 (V-SOT). */
}
.btn.active {
  /* Visual/skin is single-authority in CSS PART 13 (V-SOT). */
}
.btn-soft {
  /* Visual/skin is single-authority in CSS PART 13 (V-SOT). */
}

/* Ensure soft buttons can show active state (truth highlight) */
.btn-soft.active{
  /* Visual/skin is single-authority in CSS PART 13 (V-SOT). */
}

/* SUB-CHUNK 3.Aa BEGIN — Scale control visibility hardening (NO gesture zoom) */
.scale-row .btn-soft{
  /* Make +/- buttons read as tappable controls (not background) */
  border-color: rgba(37, 99, 235, 0.65);
  background: rgba(3, 8, 24, 0.95);
  box-shadow:
    inset 0 0 0 1px rgba(29, 78, 216, 0.18),
    0 0 0 1px rgba(59, 130, 246, 0.20);
}
.scale-row .btn-soft:hover{
  border-color: rgba(37, 99, 235, 0.95);
  box-shadow:
    inset 0 0 0 1px rgba(29, 78, 216, 0.28),
    0 0 0 2px rgba(59, 130, 246, 0.22);
}
.scale-row .btn-soft.is-holding{
  /* Hold feedback */
  border-color: rgba(99, 165, 250, 0.95);
  box-shadow:
    inset 0 0 0 1px rgba(29, 78, 216, 0.32),
    0 0 0 3px rgba(59, 130, 246, 0.24);
}

.scale-row input[type="number"]{
  height: 28px;
}
/* SUB-CHUNK 3.Aa END — Scale control visibility hardening */
/* PROTECT: keep scale-row button visibility rules above hint highlighting */
/* Hint highlight (relevance) moved to CSS PART 13.SUBCHUNK B.1 (V-SOT).
   Single-authority rule: PART 3 must not define .hint visuals to avoid split governance. */
/* (intentionally no .btn.hint / .btn-soft.hint rules here) */
.btn-ghost {
  border-style: dashed;
  border-color: #4b5563;
  background: rgba(15,23,42,0.9);
  color: var(--muted);
}
.btn-icon {
  padding-inline: 7px;
}
.btn span.icon {
  font-size: 12px;
  line-height: 1;
}
    /* SUB-CHUNK 3.A END — Buttons base styles */

    /* --- Dropdown menu (native <details>) ---------------------------------------------- */

    /* SUB-CHUNK 3.B BEGIN — Dropdown menu (<details>) styles */
.drop-menu {
  position: relative;
  display: inline-flex;
  align-items: center;
}

.drop-menu > summary {
  list-style: none;
  user-select: none;
}
.drop-menu > summary::-webkit-details-marker {
  display: none;
}

/* Panel */
.drop-panel {
  position: absolute;
  top: calc(100% + 8px);
  left: 0;
  z-index: 60;
  min-width: 210px;
  padding: 10px;
  border-radius: 16px;
  border: 1px solid var(--control-border);
  background: rgba(15,23,42,0.98);
  box-shadow: 0 18px 45px rgba(0,0,0,0.75);
  display: flex;
  flex-direction: column;
  gap: 8px;
}

/* Only show panel when open */
.drop-menu:not([open]) .drop-panel {
  display: none;
}

.drop-panel .btn {
  width: 100%;
  justify-content: flex-start;
}

/* SUB-CHUNK 3.Bc BEGIN — Draw submenu panel (responsive cascade/overlay) */
.drop-panel.submenu-panel{
  display: none; /* opened via JS */
  pointer-events: none;
}
.drop-panel.submenu-panel.open{
  display: flex;
  pointer-events: auto;
}

/* When overlay mode is active, hide main panel to avoid “double menu” */
.drop-panel.draw-main-panel.overlay-hidden{
  display: none !important;
}

.drop-panel.edit-main-panel.overlay-hidden{
  display: none !important;
}

/* Small UX affordances */
.drop-panel .submenu-back{
  justify-content: flex-start;
}
/* Ensure submenu buttons match main dropdown buttons (proportional sizing + spacing) */
.drop-panel .submenu-body{
  display: flex;
  flex-direction: column;
  gap: 8px; /* match .drop-panel gap */
  width: 100%;
}

/* SUB-CHUNK 3.Bc END — Draw submenu panel (responsive cascade/overlay) */

/* SUB-CHUNK 3.B END — Dropdown menu (<details>) styles */

    /* CSS end part 3 */

    /* Layout: left tools, center canvas, right inspector CSS part 4 -------------------- */

    .work-layout {
      /* Phase-4C: make the single-column work area a true flex fill so the canvas can claim remaining height (Runway-safe) */
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      min-height: 0;
      gap: 0;
    }

    .sidebar {
      border-right: 1px solid var(--border);
      background: var(--bg-alt);
      display: flex;
      flex-direction: column;
      padding: 8px 10px;
      gap: 10px;
    }

    /* Right properties panel becomes an overlay toggled from the top bar */
    .sidebar-right {
      /* PROTECT: Properties Inspector Dock — visually aligned to dropdown panels */
      border-right: none;
      border-left: none;

      position: fixed;
      top: var(--rightDockTop, 116px); /* below header + topbar (JS-calibrated) */
      right: 10px;

      width: min(320px, calc(100vw - 20px));
      max-height: calc(100vh - var(--rightDockTop, 116px) - 24px);

      /* Match .drop-panel surface language */
      border: 1px solid #374151;
      border-radius: 16px;
      background: rgba(15,23,42,0.98);

      box-shadow: 0 18px 45px rgba(0,0,0,0.75);
      z-index: 60;

      padding: 10px;
      display: none; /* hidden by default, shown when body has .show-right-panel */
      overflow: auto; /* prevent viewport overflow; scroll inside inspector */
    }

    body.show-right-panel .sidebar-right {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

.panel-section {
      border-radius: var(--radius-md);
      border: 1px solid var(--border-soft);
      background: radial-gradient(circle at top left,#020617,#020617 55%,#000 100%);
      padding: 8px 9px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    /* PROTECT: Collapsible section chrome inside Properties inspector */
    .panel-section-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      cursor:pointer;
      user-select:none;
    }
    .panel-section-head h3{
      margin:0;
      flex:1 1 auto;
      cursor:inherit;
    }
    .panel-collapse-btn{
      width:34px;
      height:34px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
      color: rgba(255,255,255,0.85);
      cursor:pointer;
      flex:0 0 auto;
    }
    .panel-collapse-btn:active{ transform: translateY(1px); }
    .panel-section.collapsed .panel-section-body{ display:none; }

    /* PROTECT: Industrial collapsed-bar styling (Properties inspector sections) */
    .panel-section.collapsed{
      padding: 5px 8px;
      gap: 0;
      border-color: rgba(255,255,255,0.18);
      background: linear-gradient(180deg, rgba(255,255,255,0.06) 0%, rgba(0,0,0,0.32) 100%);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.08),
        inset 0 -1px 0 rgba(0,0,0,0.65);
    }
    .panel-section.collapsed .panel-section-head{
      height: 25px;
      min-height: 25px;
      box-sizing: border-box;
      padding: 0 5px;
    }
    .panel-section.collapsed .panel-section-head h3{
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      opacity: 0.92;
    }
    .panel-section.collapsed .panel-section-head::before{
      content: "";
      width: 5px;
      height: 12px;
      border-radius: 3px;
      background: rgba(255,255,255,0.10);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.10), inset 0 -1px 0 rgba(0,0,0,0.65);
      margin-right: 6px;
      flex: 0 0 auto;
    }
    .panel-section.collapsed .panel-collapse-btn{
      width: 24px;
      height: 24px;
      border-radius: 8px;
      border-color: rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.20);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.08), inset 0 -1px 0 rgba(0,0,0,0.55);
    }

    .panel-title-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 6px;
    }

    
    .panel-title-actions{
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .close-btn{
      width: 28px;
      height: 28px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      border: 1px solid #374151;
      background: rgba(15,23,42,0.98);
      color: var(--muted);
      cursor: pointer;
      flex: 0 0 auto;
      line-height: 1;
      font-size: 16px;
      padding: 0;
    }
    .close-btn:hover{ filter: brightness(1.12); }
    .close-btn:active{ transform: translateY(1px); }
.panel-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .panel-sub {
      font-size: 10px;
      color: var(--muted-soft);
    }

    .panel-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    .panel-note {
      font-size: 10px;
      color: var(--muted-soft);
      line-height: 1.4;
    }
/* CSS end part 4 */
    /* Tool & edit groups CSS part 5 ---------------------------------------------------- */

    .tool-row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
      margin-bottom: 4px;
    }

    .tool-row .btn {
      width: 100%;
      justify-content: center;
    }

    .chip-mode {
      font-size: 10px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #4b5563;
      color: var(--muted-soft);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
/* CSS end part 5 */
    /* Canvas area CSS part 6 ----------------------------------------------------------- */

    .canvas-shell {
      position: relative;
      background: #020617;
      display: flex;
      flex-direction: column;
      flex: 1 1 auto; /* Phase-4C: allow canvas shell to fill the work-layout column */
      min-height: 0;
    }

    #canvasContainer {
      /* Canvas is the world: keep it viewport-anchored so UI never "grants" space to it. */
      position: fixed;
      inset: 0;
      z-index: 10;
      min-height: 0;
    }

    #roadCanvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #020617;
      touch-action: none;
    }
/* CSS end part 6 */
    /* Overlays inside canvas shell (for future use) CSS part 7 ------------------------- */

    .overlay-card {
      border-radius: 999px;
      border: 1px solid rgba(31,41,55,0.95);
      background: rgba(15,23,42,0.9);
      padding: 3px 8px;
      font-size: 10px;
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    /* Measurement overlay floats over the board, positioned by JS */
    .overlay-measure {
      position: absolute;
      z-index: 5;
      pointer-events: auto;
    }

    .overlay-close {
      border: none;
      background: transparent;
      color: var(--muted);
      font-size: 11px;
      padding: 0 4px;
      cursor: pointer;
    }
    .overlay-close:hover {
      color: #fca5a5;
    }

    .overlay-card span.value {
      color: var(--ink);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", monospace;
    }

    /* Axis indicator: always-visible coordinate model reminder */
    .overlay-axis {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 6;
      pointer-events: none;
      opacity: 0.92;
    }

    .overlay-axis .mono {
      color: var(--ink);
    }
/* CSS end part 7 */
    /* =========================
   CSS Part 8 — Status Bar
   ========================= */

.status-bar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 8px;
  background: var(--panel) !important;
  border-top: 1px solid var(--border);
  font-size: 12px;
  z-index: 40;
}

/* CSS PATCH: Status bar visibility toggle */
body.status-hidden .status-bar{ display:none !important; }
.status-left {
  display: flex;
  align-items: center;
  gap: 8px;
  min-width: 0;
  flex: 1;
}

.status-left,
.status-right {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: nowrap;
  flex: 0 0 auto;
}

.status-pill {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 2px 6px;
  border-radius: 4px;
  background: var(--chip);
  border: 1px solid var(--border);
  white-space: nowrap;
}

.status-pill .value {
  font-weight: 600;
}

#statusLeft {
  display: inline-block;
  flex: 1 1 auto;    /* PROTECT: text gets remaining space */
  min-width: 0;      /* PROTECT: enables ellipsis in flex row */
  max-width: 52vw;
  white-space: nowrap;
  overflow: hidden;
  
  color: var(--muted);
}

/* Small screens: keep action guidance visible; allow it to truncate instead of hiding. */

/* Diagnostics status actions (one-line only) */
.status-actions{
  display: inline-flex;
  flex: 0 0 auto;    /* PROTECT: keep actions visible, avoid wrap */
  align-items: center;
  gap: 6px;
  margin-left: 8px;
  white-space: nowrap;
}
.status-action-btn{
  appearance: none;
  border: 0;
  padding: 2px 8px;
  border-radius: 999px;
  background: rgba(255,255,255,0.06);
  color: var(--muted);
  font: inherit;
  line-height: 1.2;
  cursor: pointer;
}
.status-action-btn:active{ transform: translateY(0.5px); }
.status-action-btn:focus{ outline: 2px solid rgba(255,255,255,0.18); outline-offset: 2px; }

/* CSS end part 8 */

    /* Form bits CSS part 9 -------------------------------------------------------------- */

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", monospace;
      font-size: 11px;
    }

    input[type="number"],
    input[type="text"],
    select {
      /* Geometry here; visual/skin is single-authority in CSS PART 13 (V-SOT). */
      border-radius: 999px;
      padding: 3px 8px;
    }

    input[type="number"],
    input[type="text"] {
      /* Geometry here; visual/skin is single-authority in CSS PART 13 (V-SOT). */
      border-radius: 999px;
      padding: 3px 8px;
    }

    select {
      background: var(--control-bg);
      border: 1px solid var(--control-border);
      border-radius: 999px;
      color: var(--control-ink);
      padding: 3px 8px;
    }
/* CSS end part 9 */
    /* Right sidebar sections CSS part 10 ------------------------------------------------ */

    .prop-field-row {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
    }

    .prop-label {
      width: 70px;
      color: var(--muted-soft);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .prop-field-row .mono {
      min-width: 0;
      flex: 1 1 auto;
    }

    
    /* Line defaults preview (industrial) */
    .line-preview-wrap{
      margin-top: 8px;
      border: 1px solid var(--preview-border);
      border-radius: 10px;
      background: var(--preview-bg);
      padding: 6px 8px;
    }
    .line-preview-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 8px;
      margin-bottom: 6px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--muted-soft);
    }
    .line-preview-title{ font-weight: 700; }

    .line-preview-canvas{
      width: 100%;
      height: 34px;
      display: block;
      border-radius: 10px;
      background: var(--preview-track-bg);
    }
    .line-preview-meta{ font-size: 10px; opacity: 0.9; }
    .line-preview-track{
      width: 100%;
      min-height: 18px;
      display:flex;
      align-items:center;
    }
    #lineDefaultPreviewLine{
      width: 100%;
      border-top: 2px solid var(--preview-line);
      border-top-style: solid;
      height: 0;
    }
#measureDefaultPreviewLine{ display:none; }
.tag-row {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .tag-pill {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid var(--control-border);
      color: var(--muted-soft);
    }

    .layer-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 11px;
      padding: 3px 0;
    }

    .layer-left {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .layer-color {
      width: 10px;
      height: 10px;
      border-radius: 3px;
      background: #4b5563;
    }

    .layer-name {
      color: var(--muted);
    }

    .layer-controls {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .layer-checkbox {
      width: 14px;
      height: 14px;
    }
/* CSS end part 10 */
    /* Full-board view CSS part 11 -------------------------------------------------------- */

    body.full-board header,
    body.full-board .topbar,
    body.full-board .sidebar,
    body.full-board .sidebar-right,
    body.full-board .status-bar {
      display: none;
    }
    body.full-board #canvasContainer {
      /* Full-board hides HUD chrome; canvas remains viewport-anchored. */
      z-index: 30;
    }
    /* Phase: Full-board (View Board) HUD-only mode */
    #exitFullViewBtn {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 40;
      display: none;
    }

    body.full-board #exitFullViewBtn {
      display: inline-flex;
    }
/* CSS end part 11 */
    /* Responsive adjustments CSS part 12 ------------------------------------------------- */

    @media (max-width: 1024px) {
      .work-layout {
        grid-template-columns: 230px minmax(0,1fr);
      }
      .sidebar-right {
        display: none;
      }
    }

    @media (max-width: 768px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }
      .topbar {
        padding-inline: 10px;
      }
      .work-layout {
        grid-template-columns: minmax(0,1fr);
      }
      .sidebar {
        display: none;
      }
    }
/* CSS end part 12 */

/*
[COGNITIVE_LAYER:CL-01|NAME:CCL|VER:1.4|SCOPE:GLOBAL|OWNER:Archive|INTENT:Continuity+Drift-Control]
This block is written for Archive (the agent), not the user. Keep it compact, actionable, and deterministic.
Primary function: reduce drift + accelerate safe edits.

================================================================================
CL-01A — CONSTITUTION (RARELY CHANGES)
================================================================================
A1) BOUNDED EDITS ONLY
- All functional/structural edits MUST be bounded by Part/Chunk/Sub-Chunk markers.
- If an END marker is missing: boundary extends to the next BEGIN marker.
- Any edit package that touches structure MUST update (a) this CCL if rules change, and
  (b) the Structure Map / Legend when anchors/markers are added or modified.

A2) ID CONTRACTS (DOM ↔ JS)
- IDs are runtime contracts. Wrapping/moving is allowed. Renaming/removing IDs requires full audit.
- Prefer GUARD (optional binding) or QUARANTINE (disable/gray) over deletion.
- Any reference to removed UI must be guarded (null-safe) at the binding site.

A2.0) RUNTIME CONTRACT TABLE (SPEED LIST)
HARD REQUIRED IDs (must exist in HTML; must be present in DOM refs chunk 1)
- roadCanvas, canvasContainer
- draftNameInput, saveDraftBtn, loadDraftBtn, exportJsonBtn, importJsonBtn, exportPngBtn, importFileInput
- featureSelect
- gridPxInput, metersPerGridInput, snapStepInput
- lockAxisBtn, autoCommitBtn, autoCommitValue, contextToolspace
- statusMode, statusCursor, statusScale, statusUnits, statusSnap, statusSnapMode
- undoBtn, redoBtn, deleteSelectedBtn, clearAllBtn
- fullViewBtn, exitFullViewBtn
- rightSidebar, toggleRightPanelBtn

SOFT OPTIONAL IDs (may be missing; MUST be guarded at bind sites)
- Legacy sidebar tool/edit IDs (toolInspectBtn/toolMeasureBtn/toolAreaBtn/toolSymbolBtn/toolLabelBtn/toolEraseBtn, finishPathBtn, edit*Btn, lineToolMenu/lineToolBtn)
- Cosmetic-only helper nodes that can be muted or hidden (statusLeft, selType, anglePresetBar)

A2.1) DOM REFS GATE (SPEED RULE)
- The Hard Required ID list (CL-01A Runtime Contract Table) MUST be present in DOM refs chunk 1.
- Optional/legacy IDs may be referenced in chunk 1, but MUST remain guarded at bind sites.
- If a Hard Required ID is removed/replaced in HTML, update chunk 1 in the same pass.

A3) VISUAL SOURCE OF TRUTH (V-SOT)
- Visual tuning happens ONLY in CSS PART 13 (override layer). If “nothing changed,” you edited the wrong layer.
- Earlier CSS parts are base scaffolding. Do not patch-pyramid across multiple CSS parts.
- DPA@V-SOT is authoritative: stop and reroute visual edits into PART 13.

A4) SINGLE SOURCE OF TRUTH FUNCTIONS
- When a subsystem has a canonical engine function (e.g., commitCurrentPath()), all UI triggers must call it.
- Do NOT duplicate commit logic across handlers. Refactor triggers, not engines.

A5) L5 DELETE GATE (HARD)
Delete is allowed ONLY if ALL are true:
- Not present in HTML (or intentionally removed)
- Not required by JS at runtime OR fully guarded
- Not labeled FUTURE/LEGACY/QUARANTINED
- Removal verified by a deterministic checklist (see CL-01B Verify Protocol)
Limit deletions to 3–5 items per pass.

================================================================================
CL-01B — MIGRATION LEDGER (ACTIVE ↔ ARCHIVED)
================================================================================
Purpose: staged removal without breakage. Keep ACTIVE list short. Archive completed items.

VERIFY PROTOCOL (required for “VERIFIED”):
V0) Fast sanity (default for small edits): loads clean, canvas visible, basic pointer works, no console errors
V1) No console errors on load
V2) Primary tool parity confirmed (topbar triggers work; missing sidebar causes no crash)
V3) Save/Load sanity: Save → Load same draft; Export/Import JSON roundtrip (REQUIRED if schema touched)
V4) Visual sanity: canvas visible; pointer interactions work (pan/zoom/select/draw)
FAST-PATH RULE:
- If edit is CSS PART 13 only: V0 + V4
- If edit is bindings/tool routing (no schema change): V0 + V1 + V2
- If edit touches snapshot/schema/normalization: V0 + V1 + V3 (and V2 if tool states changed)
- If edit touches layout/visibility/canvas sizing: V0 + V1 + V4

FORMAT (per item):
- CODE: <tag>
  STATUS: ACTIVE | VERIFIED | ARCHIVED
  WHAT: <what changed>
  SAFETY: <guard / canonical engine / binding site>
  VERIFY: <V1/V2/V3/V4 subset>
  NEXT: <next removal gate or action>

ACTIVE ITEMS
- (empty)
  STATUS: n/a
  WHAT: Phase-4 archived all VERIFIED migration items. Add only truly active work here.
  SAFETY: Keep this list short; prefer ARCHIVED for completed items.
ARCHIVED ITEMS (cold storage; keep for provenance)
- SB-01 (Sidebar removal + single-column work-layout; VERIFIED V1,V2,V4; archived Phase-4)
- LT-01 (Line Tool migration to topbar; VERIFIED V1,V2,V4; archived Phase-4)
- IN-02 / ME-01 / AR-01 / LB-01 / MP-02 / ED-01 (Topbar tool/edit migrations batch; VERIFIED V1,V2,V4; archived Phase-4)
- FP-02 (FinishPath sidebar removed; guarded binding retained; verified)

================================================================================
CL-01C — SENTINEL HAZARDS (ACTIVE | QUARANTINED | RESOLVED | EXPIRED)
================================================================================
Purpose: warn Archive about “looks fine but isn’t” traps. Keep to a short list.

- HZ-01 STATUS CHANNEL MUTE
  STATE: RESOLVED
  FACT: #statusLeft is visible in the topbar status row and used for JS hints.
  RULE: If you intentionally mute #statusLeft again, update this hazard and provide an alternate visible status channel.
  DPA: DPA@STATUS

- HZ-02 STYLE LAYER DRIFT
  STATE: ACTIVE
  FACT: Visual edits can “look like they did nothing” when applied outside the V-SOT override layer.
  RULE: Route visual tuning into CSS PART 13 (V-SOT). Avoid patch pyramids across earlier CSS parts.
  DPA: DPA@V-SOT

- HZ-03 RENDERER DUPLICATION GUARD
  STATE: RESOLVED
  FACT: Historically, duplicate renderer functions were defined earlier and silently overridden later.
  RULE: Keep only one active renderer name per primitive. If legacy versions exist, suffix with __legacy_UNUSED.
  DPA: DPA@RENDER
- HZ-04 SAVE/LOAD SCHEMA RISK
  STATE: ACTIVE
  FACT: Snapshot v2 includes ui/tool/edit/layers/lineStyle; normalization occurs on load.
  RULE: If snapshot schema changes, run Verify Protocol V3 minimum.
  DPA: DPA@SAVELOAD

================================================================================
PATCH FOOTER
- [PHASE-4B Pass2] Pruned 5 legacy edit DOM refs by null-binding (finishPath/editMovePoint/editMoveShape/editAddVertex/editRemoveVertex). (rolling)
================================================================================
- LAST_PATCH: 2025-12-22
  TOUCHED: SEC-S3 — Manifest boundary hardening (single-line anchors for CL-01 + CSS PART 13); hashes refreshed
  RISK: L1 (governance-only)
  VERIFY: V0,V1

- LAST_PATCH: 2025-12-22
  TOUCHED: SEC-CLM — refreshed CL patch footer + SEC-MANIFEST hashes after S2 verification
  RISK: L1 (governance-only)
  VERIFY: V0,V1

- LAST_PATCH: 2025-12-22
  TOUCHED: SEC-S2 — Marker Integrity Sentinel added (Init chunk 20); manifest tracked blocks updated
  RISK: L2 (runtime diagnostics only)
  VERIFY: V0,V1
[/COGNITIVE_LAYER]
*/
/* [COGNITIVE_LAYER:CL-02|NAME:DPA@V-SOT|VER:1.0] STOP: Visual edits live in CSS PART 13 (V-SOT). If visuals don’t change, you edited the wrong layer. Consult CL-01. [/COGNITIVE_LAYER] */
/* =========================
   CSS PART 13 — Rectangular UI Skin + Density + Alignment
   Goal:
   - unify “button language” across topbar, status pills, and dropdowns
   - reduce perceived bulk (instrument panel density)
   - fix context rows alignment (Snap step / Angle step / Dist override)
   ========================= */



/* CSS part MOBILE.1 BEGIN — Phone viewport containment (dropdowns + panels + button labels)
   Goal:
   - Button labels never spill outside pills (ellipsis within)
   - Dropdown panels stay inside viewport on phones (fixed overlay, scroll inside)
   - Properties/right panel stays reachable (fixed overlay, scroll inside)
   NOTE: Desktop/tablet behavior remains unchanged. */
@media (max-width: 520px) {
  /* Mobile: HARD clip long labels inside pill buttons (no spill outside) */
  .btn,
  .btn-soft,
  .drop-menu > summary.btn{
    max-width: 100% !important;
    min-width: 0 !important;           /* critical for flex shrink */
    overflow: hidden !important;       /* clip label */
    text-overflow: clip !important;/* optional, but helpful */
    white-space: nowrap !important;
  }

  /* If a button contains inner inline elements, allow them to shrink too */
  .btn > * ,
  .drop-menu > summary.btn > *{
    min-width: 0 !important;
    max-width: 100% !important;
    overflow: hidden !important;
    text-overflow: clip !important;
    white-space: nowrap !important;
  }

  /* Ensure pills/buttons can shrink inside grid cells */
  .topbar, .topbar * { min-width: 0; }

  /* Dropdown panels become fixed overlays (on top of everything) */
  .drop-panel,
  .drop-panel.submenu-panel {
    position: fixed !important;
    left: 50% !important;
    right: auto !important;
    top: 72px !important;               /* below sticky chrome */
    transform: translateX(-50%) !important;
    width: min(92vw, 420px) !important;
    min-width: 0 !important;
    max-height: calc(100vh - 160px) !important; /* room for chrome + status */
    overflow-y: auto !important;
    overflow-x: hidden !important;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
  }

  /* Keep summary buttons from being pushed by long labels */
  .drop-menu > summary.btn { max-width: 100%; }

  /* Right-side properties/inspector panel: fixed overlay and fully scrollable */
  .sidebar-right {
    position: fixed !important;
    left: 4vw !important;
    right: 4vw !important;
    top: 72px !important;
    bottom: 72px !important;
    width: auto !important;
    max-height: none !important;
    z-index: 70 !important; /* above dropdowns */
    border-radius: 18px;
  }
}
/* CSS part MOBILE.1 END */


/* --- Transient Yes/No Modal (Import UX) --------------------------------------- */
#fdYesNoOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:99999;background:rgba(0,0,0,.45);}
#fdYesNoBox{min-width:280px;max-width:min(520px,92vw);border-radius:14px;padding:14px 14px 12px;box-shadow:0 18px 55px rgba(0,0,0,.55);
  background:linear-gradient(180deg, rgba(30,52,62,.96), rgba(12,20,28,.96));border:1px solid rgba(120,220,255,.28);}
#fdYesNoMsg{font-size:15px;line-height:1.25;margin:6px 6px 12px;color:#e9f7ff;text-shadow:0 1px 0 rgba(0,0,0,.55);} 
#fdYesNoBtns{display:flex;gap:10px;justify-content:flex-end;}
#fdYesNoBtns .btn{min-width:92px;}
#fdYesNoBtns .btn-no{filter:saturate(.85);opacity:.92;}
#fdYesNoBtns .btn-yes{filter:saturate(1.05);} 
/* ----------------------------------------------------------------------------- */

</style>
<!-- V-SOT13_SPLIT_BEGIN::20260108 :: Truncation-safe style segmentation; CSS content unchanged; added only tag boundaries + HTML comment sentinels -->
<style>
/* CSS PART 13.SUBCHUNK A — Skin tokens (V-SOT variables) */
:root{
  --rect-r: 8px;              /* unified corner radius */
  --rect-b: rgba(148,163,184,0.26);
  --rect-b2: rgba(148,163,184,0.14);
  --rect-top: rgba(255,255,255,0.10);
  --rect-bot: rgba(0,0,0,0.55);
  --rect-face-a: rgba(51,65,85,0.40);
  --rect-face-b: rgba(2,6,23,0.92);
  --rect-face-flat: rgba(2,6,23,0.86);
  --ui-custom-base: #2563eb; /* user theme base (custom) */
  --ui-custom-strength: 14%; /* custom tint strength (0–40%) */
}

/* END CSS PART 13.SUBCHUNK A */
</style>
<!-- V-SOT13_SUBCHUNK_END::A::20260108 -->
<style>
/* CSS PART 13.SUBCHUNK A.1 — Readability lift (text contrast)
   Goal: increase legibility of secondary labels without changing layout or button logic.
   Scope: tokens + a few label classes that use muted/muted-soft. */
body{
  --muted: #b6c2d1;
  --muted-soft: #94a3b8;
}

/* Small labels: bump contrast slightly */
.context-key,
.panel-title,
.panel-sub,
.prop-label,
.title-sub,
.badge-env{
  color: var(--muted) !important;
}
/* END CSS PART 13.SUBCHUNK A.1 */
</style>
<!-- V-SOT13_SUBCHUNK_END::A.1::20260108 -->
<style>
/* CSS PART 13.SUBCHUNK B — Buttons (topbar + sidebars + details summary)
   Single visual authority: color/skin lives here (V-SOT). */
.btn,
button.btn,
.tool-row .btn,
.drop-menu > summary.btn{
  border-radius: var(--rect-r) !important;
  /* Face A/B requested: ffffff → 020617 */
  background: linear-gradient(to bottom, var(--btn-face-a, #ffffff), var(--btn-face-b, #020617)) !important;
  /* Border requested: 0000ff */
  border: 1px solid var(--btn-border, var(--sem-truth)) !important;

  box-shadow:
    inset 0 1px 0 var(--rect-top),
    inset 0 -1px 0 var(--rect-bot) !important;
}

/* Auto button face routing (token-driven).
   When enabled, Faces A/B follow theme surface tokens instead of fixed user colors. */
body[data-btn-auto-faces="1"]{
  --btn-face-a: color-mix(in srgb, var(--panel, #0b1220) 78%, #ffffff 22%);
  --btn-face-b: color-mix(in srgb, var(--panel, #0b1220) 90%, #000000 10%);
}

/* Button-skin variables applied to key tool dropdowns (Line / Symbol / Label) */
:root{
  /* Variable bridge for ID-locked config dropdowns */
  --btn-hover-border: var(--sem-hint);
  --cfg-armed-halo2: rgba(0,255,0,0.22);
  --cfg-armed-halo3: rgba(0,255,0,0.28);
}

#lineStyleSelect,
#symbolSelect,
#labelKindSelect{
  background: linear-gradient(to bottom, var(--btn-face-a, #ffffff), var(--btn-face-b, #020617)) !important;
  border: 1px solid var(--btn-border, var(--sem-truth)) !important;
  color: #ffffff !important;
}

/* Truth highlight for dropdown summaries (Draw ▾ / Edit ▾ / Snap ▾ etc.) */
.drop-menu > summary.btn.active{
  background: var(--sem-truth) !important;
  border-color: var(--sem-truth) !important;
  color: var(--sem-on-truth) !important;
}

.btn:hover{
  /* Hover requested: 00ff00 */
  border-color: var(--sem-hint) !important;
}

.btn:active{
  box-shadow:
    inset 0 2px 4px rgba(0,0,0,0.55),
    inset 0 1px 0 rgba(255,255,255,0.06) !important;
  transform: translateY(1px);
}

.btn.active{
  /* ON requested: blue */
  background: linear-gradient(to bottom, color-mix(in srgb, var(--sem-truth) 35%, transparent), var(--sem-truth)) !important;
  border-color: var(--sem-truth) !important;
  color: var(--sem-on-truth) !important;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.14),
    inset 0 -1px 0 rgba(0,0,0,0.55) !important;
}
</style>
<!-- V-SOT13_SUBCHUNK_END::B::20260108 -->
<style>
/* CSS PART 13.SUBCHUNK B.1 — Hint highlight (green family)
   Purpose: “relevance” cue. NOT an ON/OFF truth state.
   Contract: .hint stays subtle; truth remains .active (blue).
*/
.btn.hint,
.drop-menu > summary.btn.hint,
.btn-soft.hint{
  border-color: color-mix(in srgb, var(--sem-hint) 65%, transparent) !important;
  box-shadow:
    inset 0 0 0 1px color-mix(in srgb, var(--sem-hint) 16%, transparent),
    0 0 0 2px color-mix(in srgb, var(--sem-hint) 6%, transparent);
}
</style>
<!-- V-SOT13_SUBCHUNK_END::B.1::20260108 -->
<style>
/* CSS PART 13.SUBCHUNK B.2 — Button text authority (force token ink)
   Goal: eliminate platform/default text-color leaks (Android/Chromium selects/summaries/btn spans).
   Contract: button-like controls render theme ink by default; semantic states override (active/hint). */
.btn,
button.btn,
.tool-row .btn,
.drop-menu > summary.btn,
.btn-soft,
.status-pill{
  color: var(--ink) !important;
  -webkit-text-fill-color: var(--ink) !important;
}
.btn *,
.drop-menu > summary.btn *,
.btn-soft *,
.status-pill *{
  color: inherit !important;
  -webkit-text-fill-color: inherit !important;
}

/* END CSS PART 13.SUBCHUNK B.2 */
/* END CSS PART 13.SUBCHUNK B.1 */
</style>
<!-- V-SOT13_SUBCHUNK_END::B.2::20260108 -->
<style>
/* CSS PART 13.SUBCHUNK C — Inputs / selects (global) */
/* V4: bind ALL form wells to control-well tokens so the Wells Palette actually governs them.
   This intentionally replaces older rect-face styling that ignored --control-* overrides. */
input[type="text"],
input[type="number"],
input[type="color"],
select{
  border-radius: var(--rect-r) !important;
  border: 1px solid var(--control-border) !important;
  background: var(--control-bg) !important;
  color: var(--control-ink) !important;
  caret-color: var(--control-ink) !important;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.10),
    inset 0 -1px 0 rgba(0,0,0,0.35) !important;
  -webkit-text-fill-color: var(--control-ink) !important;
}

/* END CSS PART 13.SUBCHUNK C */
</style>
<!-- V-SOT13_SUBCHUNK_END::C::20260108 -->
<style>
/* CSS PART 13.SUBCHUNK C.1 — Form text contrast hardening
   Fix: some browsers (esp. Android) render <select> text in default (black) unless color is forced on the actual control.
   Scope: visual only (V-SOT). */
.select-pill select,
.select-pill,
select,
input[type="text"],
input[type="number"],
input[type="color"]{
  color: var(--control-ink) !important;
}

/* Dropdown list items (browser support varies) */
select option{
  color: #0f172a;
  background: #ffffff;
}
</style>
<!-- V-SOT13_SUBCHUNK_END::C.1::20260108 -->
<style>
/* CSS PART 13.SUBCHUNK C.2 — Topbar tool selects should look like buttons
   Targets: Line/Symbol/Label dropdowns (lineStyleSelect, symbolSelect, labelKindSelect)
   Contract: when NOT armed -> blended face + BLUE border (same as buttons).
             when hovered -> GREEN border (same as buttons).
             when armed (JS adds .armed-config) -> GREEN border + subtle green halo (see SUBCHUNK H). */
#labelKindSelect,
#symbolSelect,
#lineStyleSelect{
  border-radius: var(--rect-r) !important;
  background: linear-gradient(to bottom, var(--btn-face-a, #ffffff), var(--btn-face-b, #020617)) !important;
  border: 1px solid var(--btn-border, var(--sem-truth)) !important;
  box-shadow:
    inset 0 1px 0 var(--rect-top),
    inset 0 -1px 0 var(--rect-bot),
    0 2px 10px rgba(0,0,0,0.35);
  color: var(--ink) !important;
  -webkit-text-fill-color: var(--ink) !important;
}
/* === Match relevant dropdown text size to buttons (and option list) === */
#lineStyleSelect,
#symbolSelect,
#labelKindSelect {
  font-size: 11px !important;   /* matches .btn font-size in SUB-CHUNK 3.A */
  line-height: 1.15;
  font-family: inherit;
}

#lineStyleSelect option,
#symbolSelect option,
#labelKindSelect option {
  font-size: 11px !important;
}
#labelKindSelect:hover,
#symbolSelect:hover,
#lineStyleSelect:hover{
  border-color: var(--btn-hover-border, var(--sem-hint)) !important;
}
/* END CSS PART 13.SUBCHUNK C.1 */
</style>
<!-- V-SOT13_SUBCHUNK_END::C.2::20260108 -->
<style>
/* CSS PART 13.SUBCHUNK C.1a — Tool dropdown relevance highlight (ID beats base skin)
   When a tool is selected, JS toggles .armed-config on its related <select>.
   Because the base skin uses ID selectors with !important, we must override with ID+class. */
#labelKindSelect.armed-config,
#symbolSelect.armed-config,
#lineStyleSelect.armed-config{
  border-color: var(--btn-hover-border, var(--sem-hint)) !important;
  box-shadow:
    0 0 0 2px var(--cfg-armed-halo2, rgba(0,255,0,0.22)),
    inset 0 1px 0 rgba(255,255,255,0.06),
    inset 0 -1px 0 rgba(0,0,0,0.55) !important;
}
#labelKindSelect.armed-config:focus,
#symbolSelect.armed-config:focus,
#lineStyleSelect.armed-config:focus{
  border-color: var(--btn-hover-border, var(--sem-hint)) !important;
  box-shadow:
    0 0 0 3px var(--cfg-armed-halo3, rgba(0,255,0,0.28)),
    inset 0 1px 0 rgba(255,255,255,0.06),
    inset 0 -1px 0 rgba(0,0,0,0.55) !important;
}
/* END CSS PART 13.SUBCHUNK C.1a */
</style>
<!-- V-SOT13_SUBCHUNK_END::C.1a::20260108 -->
<style>
/* CSS PART 13.SUBCHUNK D — “Pills” become rectangular displays */
.input-pill,
.select-pill,
.status-pill,
.snap-pill,
.overlay-card{
  border-radius: var(--rect-r) !important;
    border: 1px solid var(--control-border) !important;
  background: var(--control-bg) !important;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.06),
    inset 0 -1px 0 rgba(0,0,0,0.55) !important;
}

/* END CSS PART 13.SUBCHUNK D */
</style>
<!-- V-SOT13_SUBCHUNK_END::D::20260108 -->
<style>
/* CSS PART 13.SUBCHUNK E — Dropdown panel surface */
.drop-panel{
  border-radius: calc(var(--rect-r) + 6px) !important;
  border: 1px solid var(--rect-b) !important;
  background: rgba(15,23,42,0.96) !important;
  box-shadow: 0 18px 45px rgba(0,0,0,0.75) !important;
}

/* END CSS PART 13.SUBCHUNK E */
</style>
<!-- V-SOT13_SUBCHUNK_END::E::20260108 -->
<style>
/* CSS PART 13.SUBCHUNK F — Context output alignment (label | field) */
.context-box .context-row{
  display: grid !important;
  grid-template-columns: 120px 1fr;
  align-items: center;
  gap: 10px;
}

.context-box .context-key{
  min-width: 120px;
  max-width: 120px;
}

/* Field container becomes the ONLY surface; inner input is borderless */
.context-box .input-pill{
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 10px;
  padding: 2px 4px !important;
  min-width: 0;
}

/* Remove nested input “box-in-box” look inside context pills */
.context-box .input-pill input[type="number"],
.context-box .input-pill input[type="text"]{
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
  height: 14px !important;
  padding: 0 !important;
  width: 110px;
  max-width: 110px;
  text-align: right;
  font-size: 10px;
}

/* Unit sits in a fixed slot so columns align cleanly */
.context-box .input-pill .unit{
  margin: 0 !important;
  padding: 0 4px;
  border-left: 1px solid rgba(148,163,184,0.18);
  color: rgba(226,232,240,0.60);
  min-width: 44px;
  text-align: left;
  font-size: 10px;
}

/* END CSS PART 13.SUBCHUNK F */
</style>
<!-- V-SOT13_SUBCHUNK_END::F::20260108 -->
<style>
/* CSS PART 13.SUBCHUNK F.1 — Snap step compact geometry (standalone + runway)
   Goal: shrink numeric field footprint (no overlap) while preserving height/thickness. */
.context-box .context-row.snap-row .input-pill{
  flex: 0 0 auto !important; /* prevent the pill from expanding to fill space */
}
#snapStepInput{
  min-width: 0 !important;   /* override global .input-pill input min-width:120px */
  width: 6ch !important;     /* fits "0.000" */
  max-width: 6ch !important;
  text-align: right !important;
}

/* END CSS PART 13.SUBCHUNK F.1 */
</style>
<!-- V-SOT13_SUBCHUNK_END::F.1::20260108 -->
<style>
/* CSS PART 13.SUBCHUNK F.2 — Snap step visual tightening (spacing only)
   Goal: reduce perceived extra space around digits without changing heights. */
.context-box .context-row.snap-row .input-pill{
  padding: 2px 2px !important; /* was 2px 4px */
  gap: 6px !important;         /* was 10px */
}
.context-box .context-row.snap-row .unit{
  min-width: 28px !important;  /* was 44px (global context pill unit slot) */
  padding: 0 2px !important;   /* was 0 4px */
}

/* END CSS PART 13.SUBCHUNK F.2 */
</style>
<!-- V-SOT13_SUBCHUNK_END::F.2::20260108 -->
<style>
/* CSS PART 13.SUBCHUNK F.3 — Angle tool numeric fields compact fit (match Snap step proportions)
   Goal: prevent pill overflow in narrow toolspace; keep input+unit within pill like Snap row. */
#toolspaceAngle .context-row .input-pill{
  flex: 0 0 auto !important;
  padding: 2px 2px !important;
  gap: 6px !important;
}
#angleSnapDegInput{
  min-width: 0 !important;
  width: 4ch !important;   /* fits "45" / "360" */
  max-width: 4ch !important;
  text-align: right !important;
}
#angleSnapDistInput{
  min-width: 0 !important;
  width: 7ch !important;   /* fits "0.00" / "12.34"; placeholder is visual only */
  max-width: 7ch !important;
  text-align: right !important;
}
#toolspaceAngle .context-row .unit{
  min-width: 28px !important;
  padding: 0 2px !important;
}

/* END CSS PART 13.SUBCHUNK F.3 */
</style>
<!-- V-SOT13_SUBCHUNK_END::F.3::20260117 -->

<style>
/* CSS PART 13.SUBCHUNK G — Topbar primary fields density reduction */
.topbar-left input[type="text"]#draftNameInput{
  height: 24px !important;
  font-size: 12px !important;
  padding: 0 8px !important;
}

.topbar-left select#featureSelect{
  height: 24px !important;
  font-size: 12px !important;
  padding: 0 8px !important;
}

.topbar-left input[type="number"]#gridPxInput,
.topbar-left input[type="number"]#metersPerGridInput{
  height: 24px !important;
  font-size: 12px !important;
  padding: 0 8px !important;
}

/* Make Units / Snap / XY lock / Mode match topbar button style (no new buttons) */
#snapModeMenu > summary.btn{
  height: 24px !important;
  padding: 0 8px !important;
  font-size: 11px !important;
}

#lockAxisBtn{
  height: 24px !important;
  padding: 0 8px !important;
  font-size: 11px !important;
}

.topbar-center .status-pill{
  height: 24px !important;
  padding: 0 8px !important;
  font-size: 11px !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: space-between !important;
  gap: 10px !important;
  cursor: pointer;
}

/* END CSS PART 13.SUBCHUNK G */
</style>
<!-- V-SOT13_SUBCHUNK_END::G::20260108 -->
<style>
/* CSS PART 13.SUBCHUNK H — Armed config highlight (Line/Symbol/Label dropdown cue)
   Purpose: when a Draw tool is armed, its related configuration dropdown gets a subtle “available” highlight.
   NOTE: Purely visual; JS toggles .armed-config on the <select> elements. */
select.armed-config{
  /* Armed config highlight should track relevance lane (GREEN) */
  border-color: rgba(0,255,0,0.85) !important;
  box-shadow:
    0 0 0 2px rgba(0,255,0,0.22),
    inset 0 1px 0 rgba(255,255,255,0.06),
    inset 0 -1px 0 rgba(0,0,0,0.55) !important;
}
select.armed-config:focus{
  border-color: rgba(0,255,0,0.95) !important;
  box-shadow:
    0 0 0 3px rgba(0,255,0,0.28),
    inset 0 1px 0 rgba(255,255,255,0.06),
    inset 0 -1px 0 rgba(0,0,0,0.55) !important;
}
/* END CSS PART 13.SUBCHUNK H */

/* LEGACY HARD-GUARD: prevent any interaction even if enabled accidentally */
/* Button #5 repurposed: Multi-select now uses #topMultiSelectBtn5 */

body[data-theme="dark"]{
  /* Unified UI surface — DARK */
  --ui-surface-blended: linear-gradient(
    to bottom,
    rgba(255,255,255,0.04),
    rgba(59,59,59,0.96)
  );
  --bg:#3b3b3b;
  --bg-alt:#363636;
  --bg-elevated:#323232;
  --panel:rgba(59,59,59,.94);
  --chip:rgba(67,67,67,.88);
  --ink:#e5e7eb;
  --muted:#94a3b8;
  --border:rgba(255,255,255,.22);
  --border-soft:rgba(255,255,255,.14);

  /* button / chrome tokens */
  --rect-face-a:#4f4f4f;
  --rect-face-b:#353535;
  --rect-face-flat:#454545;
  --rect-top:rgba(255,255,255,.18);
  --rect-bot:rgba(0,0,0,.30);
  --rect-b:rgba(255,255,255,.22);
  --rect-b2:rgba(255,255,255,.14);
  /* V4 tokens */
  --control-bg: var(--chip);
  --control-border: var(--border);
  --control-ink: var(--ink);
  --preview-bg: var(--chip);
  --preview-border: var(--border);
  --preview-track-bg: rgba(0,0,0,0.10);
  --preview-line: var(--ink);
  --page-vignette-tail: var(--bg-elevated);

}

body[data-theme="mid"]{
  --muted-soft:#000000;
  /* Unified UI surface — MID */
  --ui-surface-blended: linear-gradient(
    to bottom,
    rgba(255,255,255,0.06),
    rgba(126,127,128,0.96)
  );
  --bg:#7e7f80;
  --bg-alt:#747576;
  --bg-elevated:#6a6b6c;
  --panel:rgba(126,127,128,.92);
  --chip:rgba(113,114,115,.88);
  --ink:#e5e7eb;
  --muted:#a3b1c6;
  --border:rgba(255,255,255,.20);
  --border-soft:rgba(255,255,255,.12);
  --rect-face-a:#959697;
  --rect-face-b:#717273;
  --rect-face-flat:#8b8c8d;
  --rect-top:rgba(255,255,255,.24);
  --rect-bot:rgba(0,0,0,.18);
  --rect-b:rgba(0,0,0,.22);
  --rect-b2:rgba(0,0,0,.14);
  /* V4 tokens */
  --control-bg: var(--chip);
  --control-border: var(--border);
  --control-ink: var(--ink);
  --preview-bg: var(--chip);
  --preview-border: var(--border);
  --preview-track-bg: rgba(0,0,0,0.10);
  --preview-line: var(--ink);
  --page-vignette-tail: var(--bg-elevated);

}

body[data-theme="light"]{
  /* Unified UI surface — LIGHT */
  --ui-surface-blended: linear-gradient(
    to bottom,
    rgba(255,255,255,0.08),
    rgba(179,180,181,0.96)
  );
  --bg:#b3b4b5;
  --bg-alt:#b8b8b9;
  --bg-elevated:#a8a9aa;
  --panel:rgba(187,188,188,.92);
  --chip:rgba(179,180,181,.92);
  --ink:#0f172a;
  --muted:#334155;
  --muted-soft:#000000;
  --border: rgba(15,23,42,.18);
  --border-soft: rgba(15,23,42,.12);
  --rect-face-a:#c1c2c2;
  --rect-face-b:#b3b4b5;
  --rect-face-flat:#c5c6c7;
  --rect-top:rgba(255,255,255,.65);
  --rect-bot:rgba(15,23,42,.10);
  --rect-b: rgba(15,23,42,.18);
  --rect-b2: rgba(15,23,42,.12);
  /* V4 tokens */
  --control-bg: rgba(255,255,255,0.70);
  --control-border: var(--border);
  --control-ink: var(--ink);
  --preview-bg: rgba(255,255,255,0.65);
  --preview-border: var(--border);
  --preview-track-bg: rgba(0,0,0,0.08);
  --preview-line: rgba(15,23,42,0.92);
  --page-vignette-tail: var(--bg-elevated);

}
/* UI theme: custom (user-selected base color) */
body[data-theme="custom"]{
  /* base comes from JS into --ui-custom-base; fallback stays accent */
  --accent: var(--ui-custom-base, var(--accent));

  /* Custom strength control (0–40%). Higher = more of the chosen base color. */
  --cs: var(--ui-custom-strength, 14%);
  --cs-bg: var(--cs);
  --cs-alt: calc(var(--cs) + 4%);
  --cs-elev: calc(var(--cs) + 6%);
  --cs-panel: calc(var(--cs) + 8%);
  --cs-chip: calc(var(--cs) + 4%);
  --cs-border: calc(var(--cs) + 18%);

  /* Dark-tint recipes (tint toward deep surfaces) */
  --bg: color-mix(in srgb, var(--ui-custom-base, #2563eb) var(--cs-bg), #000 calc(100% - var(--cs-bg)));
  --bg-alt: color-mix(in srgb, var(--ui-custom-base, #2563eb) var(--cs-alt), #000 calc(100% - var(--cs-alt)));
  --bg-elevated: color-mix(in srgb, var(--ui-custom-base, #2563eb) var(--cs-elev), #000 calc(100% - var(--cs-elev)));
  --panel: color-mix(in srgb, var(--ui-custom-base, #2563eb) var(--cs-panel), #020617 calc(100% - var(--cs-panel)));
  --chip: color-mix(in srgb, var(--ui-custom-base, #2563eb) var(--cs-chip), #0b1220 calc(100% - var(--cs-chip)));
  --border: color-mix(in srgb, var(--ui-custom-base, #2563eb) var(--cs-border), rgba(148,163,184,0.26) calc(100% - var(--cs-border)));
  --border-soft: color-mix(in srgb, var(--ui-custom-base, #2563eb) calc(var(--cs-border) - 10%), rgba(148,163,184,0.18) calc(110% - var(--cs-border)));

  --ink: #e5e7eb;
  --muted: #94a3b8;

  /* Custom chrome blend tracks strength */
  --cs-ui1: calc(var(--cs) * 0.50);
  --cs-ui2: calc(var(--cs) * 0.80);
  --ui-surface-blended: linear-gradient(
    to bottom,
    color-mix(in srgb, var(--ui-custom-base, #2563eb) var(--cs-ui1), rgba(2,6,23,0.82) calc(100% - var(--cs-ui1))),
    color-mix(in srgb, var(--ui-custom-base, #2563eb) var(--cs-ui2), rgba(2,6,23,0.92) calc(100% - var(--cs-ui2)))
  );

  /* V4 tokens */
  --control-bg: var(--chip);
  --control-border: var(--border);
  --control-ink: var(--ink);
  --preview-bg: var(--chip);
  --preview-border: var(--border);
  --preview-track-bg: rgba(0,0,0,0.10);
  --preview-line: var(--ink);
  --page-vignette-tail: var(--bg-elevated);

}

/* UI theme: custom (light mode) — tint toward white surfaces */
/* UI theme: custom (light mode) — tint toward white surfaces */
body[data-theme="custom"][data-custom-mode="light"]{
  --accent: var(--ui-custom-base, var(--accent));

  /* Custom strength control (0–40%). Higher = more of the chosen base color. */
  --cs: var(--ui-custom-strength, 14%);
  --cs-bg: var(--cs);
  --cs-alt: calc(var(--cs) + 2%);
  --cs-elev: calc(var(--cs) + 4%);
  --cs-panel: calc(var(--cs) + 4%);
  --cs-chip: calc(var(--cs) + 2%);
  --cs-border: calc(var(--cs) + 8%);

  /* Light-tint recipes (tint toward white/light surfaces) */
  --bg: color-mix(in srgb, var(--ui-custom-base, #2563eb) var(--cs-bg), #ffffff calc(100% - var(--cs-bg)));
  --bg-alt: color-mix(in srgb, var(--ui-custom-base, #2563eb) var(--cs-alt), #f8fafc calc(100% - var(--cs-alt)));
  --bg-elevated: color-mix(in srgb, var(--ui-custom-base, #2563eb) var(--cs-elev), #eef2f7 calc(100% - var(--cs-elev)));
  --panel: color-mix(in srgb, var(--ui-custom-base, #2563eb) var(--cs-panel), rgba(241,245,249,0.94) calc(100% - var(--cs-panel)));
  --chip: color-mix(in srgb, var(--ui-custom-base, #2563eb) var(--cs-chip), rgba(226,232,240,0.92) calc(100% - var(--cs-chip)));
  --border: color-mix(in srgb, var(--ui-custom-base, #2563eb) var(--cs-border), rgba(15,23,42,0.18) calc(100% - var(--cs-border)));
  --border-soft: color-mix(in srgb, var(--ui-custom-base, #2563eb) calc(var(--cs-border) - 6%), rgba(15,23,42,0.12) calc(106% - var(--cs-border)));

  --ink: #0f172a;
  --muted: #334155;
  --muted-soft: #000000;

  /* Custom chrome blend tracks strength */
  --cs-ui1: calc(var(--cs) * 0.50);
  --cs-ui2: calc(var(--cs) * 0.80);
  --ui-surface-blended: linear-gradient(
    to bottom,
    color-mix(in srgb, var(--ui-custom-base, #2563eb) var(--cs-ui1), rgba(255,255,255,0.16) calc(100% - var(--cs-ui1))),
    color-mix(in srgb, var(--ui-custom-base, #2563eb) var(--cs-ui2), rgba(241,245,249,0.96) calc(100% - var(--cs-ui2)))
  );

  /* V4 tokens */
  --control-bg: rgba(255,255,255,0.72);
  --control-border: var(--border);
  --control-ink: var(--ink);
  --preview-bg: rgba(255,255,255,0.66);
  --preview-border: var(--border);
  --preview-track-bg: rgba(0,0,0,0.08);
  --preview-line: rgba(15,23,42,0.92);
  --page-vignette-tail: var(--bg-elevated);
}

/* V4 NOTE: Light/Mid pill rescue rules removed — control wells now token-based */
/* V4 NOTE: Light/Mid pill rescue rules removed — control wells now token-based */

</style>
<!-- V-SOT13_SUBCHUNK_END::H::20260108 -->
<style>
/* CSS PART 13.SUBCHUNK THEME-SURFACES — Make toolbar/chrome follow theme tokens
   Reason: .chrome and .topbar previously used hard-coded dark RGBA backgrounds in base CSS,
   so custom/mid/light themes did not visibly affect the top toolbar surfaces. */
body[data-theme="dark"] .chrome,
body[data-theme="mid"] .chrome,
body[data-theme="light"] .chrome,
body[data-theme="custom"] .chrome{
  background: var(--panel) !important;
}

body[data-theme="light"] .topbar,
body[data-theme="light"] .properties-panel,
body[data-theme="light"] .status-bar,
body[data-theme="light"] .drop-menu,
body[data-theme="mid"] .topbar,
body[data-theme="mid"] .properties-panel,
body[data-theme="mid"] .status-bar,
body[data-theme="mid"] .drop-menu,
body[data-theme="dark"] .topbar,
body[data-theme="dark"] .properties-panel,
body[data-theme="dark"] .status-bar,
body[data-theme="dark"] .drop-menu {
  background: var(--ui-surface-blended) !important;
}
/* Optional: keep the app background tied to tokens (improves light theme legibility) */
body[data-theme="mid"],
body[data-theme="light"],
body[data-theme="custom"]{
  background: radial-gradient(circle at top, var(--bg) 0, var(--page-vignette-tail) 65%) !important;
}
/* END CSS PART 13.SUBCHUNK THEME-SURFACES */

/* Ensure panel gradients follow theme tokens (avoid hard-coded dark stops) */
.panel-section{
  background: radial-gradient(circle at top left, var(--bg), var(--bg) 55%, var(--bg-elevated) 100%) !important;
}

/* Canvas shell follows tokens; actual canvas paint is JS-driven */
.canvas-shell{
  background: var(--bg) !important;
}

/* END CSS PART 13 */

/* CSS PATCH P4C BEGIN — Embed compact mode (Runway/iframe) */
html.embed .topbar{ padding:4px 10px 4px; gap:8px; }
html.embed .topbar-left, html.embed .topbar-center, html.embed .topbar-right{ gap:4px; }
html.embed .topbar-left .topbar-group,
html.embed .topbar-center .topbar-group{ gap:6px; }
html.embed .topbar-center .topbar-group{ flex-wrap: wrap; }
html.embed .btn{ padding:6px 10px; font-size:12px; }
html.embed .btn-icon{ width:34px; min-width:34px; height:34px; padding:0; }
html.embed select,
html.embed input[type="text"],
html.embed input[type="number"]{ height:34px; font-size:12px; }
html.embed .input-pill{ padding:6px 10px; }
html.embed .snap-pill{ padding:8px 10px; }
html.embed .status-bar{ height:26px; font-size:11px; }
html.embed .status-pill{ font-size:11px; padding:4px 8px; }
/* CSS PATCH P4C END — Embed compact mode (Runway/iframe) */

/* CSS PATCH SNAPROW BEGIN — Standalone Snap hitbox tightening
   Purpose: reduce Snap ON/OFF horizontal footprint so it cannot steal taps intended for the Snap Step input
   Scope: standalone + embedded (safe; purely layout)
*/
.context-box .context-row.snap-row{
  grid-template-columns: 86px 1fr !important;
  gap: 12px !important;
}
.context-box .context-row.snap-row #snapToggleBtn{
  width: 64px !important; /* horizontal length only */
}
/* CSS PATCH SNAPROW END — Standalone Snap hitbox tightening */

/* STEP2c: hide legacy Sketch test button */
#freeDrawBtn{display:none !important;}
</style>
<!-- V-SOT13_SUBCHUNK_END::THEME::20260108 -->
<style>
/* CSS PART 13.SUBCHUNK READABILITY — Muted text contrast lift (V-SOT)
   Goal: make small labels readable on dark chrome without changing layout.
   Scope: tokens + a few label classes only. */
:root{
  --muted: #cbd5e1;       /* was too dim */
  --muted-soft: #94a3b8;  /* secondary labels */
}

/* Ensure common small-label surfaces inherit the brighter tokens */
.title-sub,
.badge-env,
.panel-title,
.panel-sub,
.prop-label,
.context-key{
  color: var(--muted-soft) !important;
}

/* Optional: “meta” labels inside pills/rows */
.context-na,
.status-left,
.layer-name{
  color: var(--muted) !important;
}
/* END CSS PART 13.SUBCHUNK READABILITY */
</style>
<!-- V-SOT13_SUBCHUNK_END::READABILITY::20260108 -->

<style>
/* CSS PART 13.SUBCHUNK OVERLAY-WORLD — Phase 2A (canvas sovereign; chrome/sidebars are HUD overlays)
   - Promote chrome from sticky (layout participant) to fixed (overlay).
   - Prevent empty HUD regions from blocking drawing: pointer-events none on wrapper, auto on interactive children.
   - Keep layout wrappers from creating scroll/height pressure; canvas owns viewport. */

body{
  overflow: hidden; /* canvas is the world; prevent page scroll from chrome/layout wrappers */
}

/* Chrome becomes a HUD overlay (was position: sticky) */
.chrome{
  position: fixed !important;
  top: 0;
  left: 0;
  right: 0;
  z-index: 70; /* above canvas and panels */
  pointer-events: none; /* do not block canvas except where interactive elements exist */
}

/* Allow interaction inside chrome */
.chrome header,
.chrome .topbar,
.chrome .topbar *{
  pointer-events: auto;
}

/* Ensure work area doesn't fight for height — canvas is fixed */
.work-layout{
  min-height: 0 !important;
}

/* Right panel already uses fixed positioning; ensure it stays above canvas but below chrome if desired */
#rightSidebar{
  z-index: 60;
}

/* END CSS PART 13.SUBCHUNK OVERLAY-WORLD */

/* CSS PATCH P5 BEGIN — Properties panel row overflow guard
   Purpose: prevent label/value collisions when adding shape dimension rows (Diameter/Width/Height)
   Strategy: enforce stable two-column grid and allow pills to shrink without overflow
*/
.sidebar-right .prop-field-row{
  display:grid;
  grid-template-columns: 84px minmax(0,1fr);
  align-items:center;
  gap:10px;
}
.sidebar-right .prop-label{
  min-width:0;
  white-space:nowrap;
  overflow:hidden;
  
}
.sidebar-right .input-pill{
  min-width:0;
}
.sidebar-right .input-pill input[type="number"],
.sidebar-right .input-pill input[type="text"]{
  min-width:0;
  width:100%;
}
/* CSS PATCH P5 END — Properties panel row overflow guard */
</style>
<!-- V-SOT13_SUBCHUNK_END::OVERLAY-WORLD::20260109 -->

<!-- V-SOT13_PART_END::20260108 -->

<!-- TRUNC_GUARD::HEAD_END::HG_20260108 -->

<style id="fd-mobile-overrides">
/* ======================================================
   MOBILE OVERRIDES (phones)
   Single authority block for phone viewport behavior.
   Intent: toolbar overlays + safe clipping + scrollable menus.
   ====================================================== */
@media (max-width: 520px) {

  /* --- Button/Pill text containment (no ellipsis, hard clip) --- */
  .toolbar button,
  .toolbar .btn,
  .toolbar .tool-btn,
  .toolbar .pill,
  .toolbar .pillBtn,
  .toolbar .pill-button,
  .toolbar .btnPill,
  .toolbar .menuBtn,
  .toolbar .dropBtn,
  .toolbar .toggleBtn,
  .toolbar .smallBtn,
  .toolbar .bigBtn,
  .toolbar [role="button"]{
    max-width: 100% !important;
    overflow: hidden !important;      /* hard boundary */
    white-space: nowrap !important;    /* single line */
    text-overflow: clip !important;    /* no dots */
  }

  /* Flexbox shrink allow-list: critical to prevent text forcing overflow */
  .toolbar button *,
  .toolbar .btn *,
  .toolbar .tool-btn *,
  .toolbar .pill *,
  .toolbar .pillBtn *,
  .toolbar .pill-button *,
  .toolbar .btnPill *,
  .toolbar .menuBtn *,
  .toolbar .dropBtn *,
  .toolbar .toggleBtn *,
  .toolbar .smallBtn *,
  .toolbar .bigBtn *{
    min-width: 0 !important;
    max-width: 100% !important;
    overflow: hidden !important;
    white-space: nowrap !important;
    text-overflow: clip !important;
  }

  /* --- Dropdown / flyout menus must stay inside viewport ---
     On phones: fixed overlay + internal scroll so nothing is unreachable. */
  .dropdown,
  .dropdown-menu,
  .menu,
  .flyout,
  .panel-menu,
  .toolbarMenu,
  .toolMenu,
  .editMenu,
  .drawMenu{
    position: fixed !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    right: auto !important;
    top: 10vh !important;
    bottom: auto !important;
    max-height: 78vh !important;
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch !important;
    z-index: 99999 !important;
  }

  /* --- Properties panel: phone-friendly overlay --- */
  #propertiesPanel,
  .propertiesPanel,
  .properties-panel,
  .panel.properties,
  .rightPanel,
  .right-panel{
    position: fixed !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    width: min(96vw, 520px) !important;
    top: 8vh !important;
    bottom: 8vh !important;
    max-height: none !important;
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch !important;
    z-index: 99998 !important;
  }

  /* --- Keep toolbar usable above overlays when shown --- */
  .toolbar,
  #toolbar,
  .toolBar,
  .toolbarRoot{
    position: relative !important;
    z-index: 99997 !important;
  }
}
</style>
<style id="fd-tablet-overrides">
/* ======================================================
   TABLET ORIENTATION OVERRIDES (portrait / short-height)
   Goal: menus + properties never fall off-screen when
   rotating between landscape and portrait.
   ====================================================== */

/* iPad/Android tablets in portrait often have reduced usable width for right-anchored menus */
@media (max-width: 1024px) and (orientation: portrait) {

  .dropdown,
  details.drop-menu[open] > .drop-panel,
  .drop-menu[open] > .drop-panel,
  .drop-menu .drop-panel,
  .drop-panel,
  .dropdown-menu,
  .menu,
  .flyout,
  .panel-menu,
  .toolbarMenu,
  .toolMenu,
  .editMenu,
  .drawMenu{
    position: fixed !important;
    left: auto !important;
    right: max(2vw, 10px) !important;
    transform: none !important;
    top: max(10vh, 64px) !important;
    max-height: 78vh !important;
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch !important;
    z-index: 99999 !important;
  }

  #propertiesPanel,
  .propertiesPanel,
  .properties-panel,
  .panel.properties,
  .rightPanel,
  .right-panel{
    position: fixed !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    width: min(96vw, 720px) !important;
    top: max(8vh, 56px) !important;
    bottom: 8vh !important;
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch !important;
    z-index: 99998 !important;
  }
}

/* Landscape tablets can have short height; clamp vertical space so menus scroll instead of falling below viewport */
@media (max-height: 700px) and (orientation: landscape) {

  .dropdown,
  .dropdown-menu,
  .menu,
  .flyout,
  .panel-menu,
  .toolbarMenu,
  .toolMenu,
  .editMenu,
  .drawMenu{
    position: fixed !important;
    left: auto !important;
    right: max(2vw, 10px) !important;
    transform: none !important;
    top: max(8vh, 48px) !important;
    max-height: 76vh !important;
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch !important;
    z-index: 99999 !important;
  }

  #propertiesPanel,
  .propertiesPanel,
  .properties-panel,
  .panel.properties,
  .rightPanel,
  .right-panel{
    position: fixed !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    width: min(96vw, 760px) !important;
    top: max(8vh, 48px) !important;
    bottom: 6vh !important;
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch !important;
    z-index: 99998 !important;
  }
}
</style>

<!-- PATCH BEGIN :: USER PRESET SYMBOLS PANEL UI :: 20260115a -->
<style>
  /* User Preset Symbols — panel UI (matches drop-panel surface language; avoids global pointer-event changes) */
  #userPresetPanel{
    position: fixed;
    top: 132px; /* below header/topbar */
    right: 10px;
    width: min(320px, calc(100vw - 20px));
    z-index: 85;
    display: none;
  }
  #userPresetPanel.open{ display: flex; flex-direction: column; gap: 10px; }

  #userPresetPanel .preset-head{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 10px;
  }
  #userPresetPanel .preset-title{
    font-weight: 700;
    letter-spacing: 0.2px;
  }
  #userPresetPanel .preset-actions{ display:flex; flex-direction:column; gap: 8px; }
  #userPresetPanel select{ width: 100%; }

  /* Ensure inputs/buttons are clickable even if future chrome changes occur */
  #userPresetPanel, #userPresetPanel *{ pointer-events: auto; }
</style>
<!-- PATCH END :: USER PRESET SYMBOLS PANEL UI :: 20260115a -->

</head>
<body>

<div class="chrome" id="chrome">
  <!-- Branding + Toolbar are unified inside this sticky chrome surface -->
<header>
  <div class="title-block">
    <div class="title-main">FIELD DRAFT v1.0</div>
  </div>
  <div class="header-right">

    <button class="btn btn-soft" id="toggleTopbarBtn" type="button" aria-pressed="false" title="Hide/show the toolbar">Hide tools</button>
    <button class="btn btn-soft" id="toggleStatusbarBtn" type="button" aria-pressed="false" title="Hide/show the bottom status bar">Hide status</button>
    <a href="index.html" class="hub-link">
      <span class="icon">↩</span>
      <span>Toolbox hub</span>
    </a>
  </div>
</header>
  <!-- HTML PART 1 — TOPBAR -->
<!-- Top control bar (3-column spine) -->
  <div class="topbar">

    <!-- LEFT rail: Draft / Feature / Scale -->
    <div class="topbar-left">

      <!-- Draft row -->
      <div class="topbar-group">
        <span class="topbar-label rail-label">Draft</span>

        <input type="text" id="draftNameInput" placeholder="Draft name" style="flex:1 1 auto; min-width:0;" />

        <!-- File / Draft actions dropdown (saves space) -->
        <details class="drop-menu" id="draftMenu">
          <summary class="btn btn-soft">
            <span class="icon">💾</span>
            File
          </summary>

          <div class="drop-panel">
            <button class="btn btn-soft" id="saveDraftBtn"><span class="icon">💾</span>Save</button>
            <div class="panel-note" style="margin-top:4px; margin-bottom:-2px;">Load saved draft</div>
            <select id="loadDraftSelect" class="select-pill" aria-label="Load saved draft">
              <option value="">(select)</option>
            </select>
            <button class="btn btn-soft" id="loadDraftBtn">Load selected</button>
            <button class="btn btn-soft" id="deleteDraftBtn">Delete selected</button>
            <button class="btn btn-soft" id="exportJsonBtn">Export JSON</button>
            <button class="btn btn-soft" id="importJsonBtn">Import JSON</button>
            <button class="btn btn-soft" id="importIntoCurrentBtn">Import into current draft</button>
            <button class="btn btn-soft" id="exportPngBtn">Export PNG</button>

            <input type="file" id="importFileInput" accept="application/json" style="display:none;" />
          </div>
        </details>
      </div>

      <!-- Feature row -->
      <div class="topbar-group">
        <span class="topbar-label rail-label">Feature</span>
        <span class="input-pill mono" id="selType" style="display:none;">–</span>

        <select id="featureSelect" style="flex:1 1 auto; min-width:0;">
          <option value="">(none)</option>
        </select>
      </div>

      <!-- Scale row -->
      <div class="topbar-group scale-group">
        <span class="topbar-label rail-label">Scale</span>

        <div class="scale-stack">
          <div class="scale-row" aria-label="Grid pixels per grid">
            <button class="btn btn-soft" id="gridPxMinusBtn" type="button" title="Grid px −1" aria-label="Grid px minus">−</button>
            <input type="number" id="gridPxInput" min="5" max="80" step="1" value="30" style="width:140px; max-width:140px;" />
            <button class="btn btn-soft" id="gridPxPlusBtn" type="button" title="Grid px +1" aria-label="Grid px plus">+</button>
            <span class="chip mono">px / grid</span>
          </div>

          <div class="scale-row" aria-label="Units per grid">
            <button class="btn btn-soft" id="metersPerGridMinusBtn" type="button" title="Units per grid −" aria-label="Units per grid minus">−</button>
            <input type="number" id="metersPerGridInput" min="0.01" step="0.01" value="1" style="width:140px; max-width:140px;" />
            <button class="btn btn-soft" id="metersPerGridPlusBtn" type="button" title="Units per grid +" aria-label="Units per grid plus">+</button>
            <span class="chip mono" id="metersPerGridUnit">m / grid</span>
          </div>
        </div>
      </div>

</div>

    <!-- CENTER column -->
    <div class="topbar-center">
      <div class="center-grid">

        <div class="topbar-group center-stack" aria-label="topbar stack MID">
          <button class="btn btn-soft" id="clearAllBtn" type="button">Clear all</button>
          <button class="btn btn-soft" id="deleteSelectedBtn" type="button">Delete selected</button>
          <button class="btn btn-soft" id="undoBtn" type="button">Undo</button>
          <button class="btn btn-soft" id="redoBtn" type="button">Redo</button>
        </div>

        <!-- STACK A -->
        <div class="topbar-group center-stack">
          <span class="topbar-label rail-label">Tools</span>

          <select id="labelKindSelect">
            <option value="point">Point text</option>
            <option value="box">Box label</option>
            <option value="leader">Leader label</option>
          </select>

          <select id="symbolSelect">
<option value="">Choose symbol…</option>
<option value="arrow">Arrow</option>
<option value="stopbar">Stop bar</option>
<option value="manhole">Manhole</option>
<option value="crosswalk">Crosswalk</option>
<option value="stop-sign">Stop sign</option>
<option value="yield-sign">Yield sign</option>
<option value="speed-sign">Speed sign</option>
<option value="no-parking">No parking</option>
<option value="ped-sign">Ped warning</option>
<option value="signal">Traffic light</option>
</select>

          <button class="btn btn-ghost btn-slot" id="topMultiSelectBtn5" type="button" title="Multi-Select" aria-pressed="false">Multi-Select</button>
          <button class="btn btn-soft" id="fullViewBtn" type="button">View board</button>
<button class="btn btn-soft" id="freeDrawBtn" title="Sketch (drag to draw)">Sketch</button>

        </div>

        <!-- SUB-PART 2.A BEGIN — Topbar CENTER stack X placeholder buttons (Button 1–4) -->
        <!-- STACK X (NEW) -->
        <!-- PROTECT: placeholder stack only; keep IDs unique -->
<!-- SUB-PART 2.A END — Topbar CENTER stack X placeholder buttons (Button 1–4) -->

        <!-- STACK Y (NEW) -->
        <!-- PROTECT: placeholder stack; keep IDs stable for future use -->
        <div class="topbar-group center-stack" aria-label="topbar stack Y">
          
          <button type="button" class="btn btn-soft" id="presetGeomBtn" title="User preset geometry (coming soon)">Presets</button>
<button class="btn btn-soft" id="stackYBtn2" type="button">Properties</button>

          <!-- EDIT MENU: Duplicate button promoted to category trigger -->
          <details class="drop-menu" id="editMenu" style="width:100%;">
            <summary class="btn btn-soft" style="width:100%; justify-content:space-between;">
              <span>Edit</span>
              <span class="mono">▾</span>
            </summary>

            <!-- EDIT: Main panel -->
            <div class="drop-panel edit-main-panel" id="editMainPanel" style="min-width: 240px;">
              <!-- Ordered by contract: Bend first -->
<!-- SUB-CHUNK 2.A_MSEL BEGIN — Multi-select toggle -->
              <button type="button" class="btn btn-soft" id="topEditMultiSelectBtn" title="Multi-select moved to Button 5" disabled aria-hidden="true" tabindex="-1" style="display:none">Multi</button>
              <!-- SUB-CHUNK 2.A_MSEL END — Multi-select toggle -->
              <button type="button" class="btn btn-soft" id="topEditDeformOpener" data-open-edit-submenu="deform" aria-haspopup="true" aria-expanded="false">Move / Deform ▸</button>
  <button type="button" class="btn btn-soft" id="topEditCopyBtnMain">Copy</button>
  <button type="button" class="btn btn-soft" id="topEditPasteBtnMain">Paste</button>
<div class="hr"></div>
<button type="button" class="btn btn-soft" id="topEditDuplicateSubmenuOpener" data-open-edit-submenu="duplicate" aria-haspopup="true" aria-expanded="false">Duplicate ▸</button>
<!-- Submenu opener: Group objects (overlay replacement; no scroll) -->
              <button type="button" class="btn btn-soft" id="topEditGroupObjectsOpener" data-open-edit-submenu="groupObjects" aria-haspopup="true" aria-expanded="false">Group objects ▸</button>

              <button type="button" class="btn btn-ghost" id="topEditMenuCloseBtn">Close</button>
            
            </div>

            <!-- EDIT: Submenu panel (overlay replacement; no side-cascade) -->
            <div class="drop-panel submenu-panel" id="editSubmenuPanel" aria-hidden="true" style="min-width: 240px;">
              <button type="button" class="btn btn-ghost submenu-back" data-edit-submenu-back="true">← Edit</button>
<!-- Deform submenu -->
<div class="submenu-body" data-edit-submenu="deform">
  <button type="button" class="btn btn-soft" id="topEditMoveShapeBtn">Move shape</button>
  <button type="button" class="btn btn-soft" id="topEditMovePointBtn">Move point</button>
  
  <!-- BEGIN: Move/Deform core tools (moved from Edit root) -->
  <button type="button" class="btn btn-soft" id="topEditBendBtn">Bend</button>
  <button type="button" class="btn btn-soft" id="topEditRotateBtn">Rotate</button>
  <button type="button" class="btn btn-soft" id="topEditScaleBtn">Scale</button>
  <button type="button" class="btn btn-soft" id="topEditSplitLineBtn">Split line</button>
  <button type="button" class="btn btn-soft" id="topEditCutoutBtn">Cut-out</button>
  <!-- END: Move/Deform core tools -->
<button type="button" class="btn btn-soft" id="topEditAddVertexBtn">Add vertex</button>
  <button type="button" class="btn btn-soft" id="topEditRemoveVertexBtn">Remove vertex</button>
</div>

<!-- Duplicate submenu -->
<div class="submenu-body" data-edit-submenu="duplicate">
  <button type="button" class="btn btn-soft" id="topEditCopyBtn">Copy</button>
  <button type="button" class="btn btn-soft" id="topEditPasteBtn">Paste</button>
  <div class="hr"></div>
  <button type="button" class="btn btn-soft" id="topEditDuplicateBtn">Duplicate</button>
  <button type="button" class="btn btn-soft" id="topEditDuplicateMirrorBtn">Duplicate Mirror</button>
  <button type="button" class="btn btn-soft" id="topEditArrayRepeatBtn">Array Repeat</button>
    <button type="button" class="btn btn-soft" id="topEditRadialArrayBtn">Radial Array</button>
<button type="button" class="btn btn-soft" id="topEditOffsetParallelBtn">Offset Parallel</button>
</div>

              <!-- Group objects submenu -->
              <div class="submenu-body" data-edit-submenu="groupObjects">
                <button type="button" class="btn btn-soft" id="topGroupCreateBtn">Create group</button>
                <button type="button" class="btn btn-soft" id="topGroupAddBtn">Add to group</button>
                <button type="button" class="btn btn-soft" id="topGroupRemoveBtn">Remove from group</button>
                <button type="button" class="btn btn-soft" id="topGroupCombineBtn">Combine groups</button>
                <button type="button" class="btn btn-soft" id="topGroupDisbandBtn">Disband authority</button>
                <div class="hr"></div>
                <button type="button" class="btn btn-soft" id="topGroupTotalAreaBtn">Total area (areas)</button>
              </div>
            </div>
          </details>

          <button class="btn btn-soft" id="stackYBtn4" type="button">Inspect / Nav</button>
        </div>

        <!-- SUB-PART 2.B BEGIN — Topbar CENTER stack B status + mode slot (Units/Snap/Axis/Mode/Button 4) -->
        <!-- STACK B -->
        <div class="topbar-group center-stack" aria-label="topbar stack B">

          <!-- Units dropdown (direct-select) -->
          <details class="drop-menu" id="unitsMenu" style="width:100%;">
            <summary class="btn btn-soft" style="width:100%; justify-content:space-between;">
              <span>Units</span>
              <span class="mono" id="statusUnits">m</span>
            </summary>

            <div class="drop-panel" style="min-width: 240px;">
              <button type="button" class="btn btn-soft" data-units-mode="metric">m</button>
              <button type="button" class="btn btn-soft" data-units-mode="cm">cm</button>
              <button type="button" class="btn btn-soft" data-units-mode="mm">mm</button>
              <button type="button" class="btn btn-soft" data-units-mode="imperial">ft</button>
              <button type="button" class="btn btn-soft" data-units-mode="in">in</button>
              <button type="button" class="btn btn-ghost" id="unitsMenuCloseBtn">Close</button>
            </div>
          </details>

          <details class="drop-menu" id="snapModeMenu" style="width:100%;">
            <summary class="btn btn-soft" style="width:100%; justify-content:space-between;">
              <span>Snap</span>
              <span class="mono" id="statusSnapMode">Snap point</span>
            </summary>

            <div class="drop-panel" style="min-width: 240px;">
              <button type="button" class="btn btn-soft" data-snap-mode="point">Snap point</button>
              <button type="button" class="btn btn-soft" data-snap-mode="angle">Snap angle</button>
              <button type="button" class="btn btn-soft" data-snap-mode="grid">Snap grid</button>
            </div>
          </details>

          <button class="btn btn-soft active" id="lockAxisBtn" style="width:100%; justify-content:space-between;" type="button">
            <span>XY lock</span>
            <span id="axisLockState" class="mono">ON</span>
          </button>

          <!-- Swapped: Button 4 now hosts primary Draw tool -->
<!-- GPT_SAFE_ZONE BEGIN: TOPBAR_DRAW_DROPDOWN (SUB-CHUNK 2.E) — edit only if explicitly authorized -->
<!-- SUB-CHUNK 2.E BEGIN — Topbar Draw dropdown (line/area hub) -->
          <details class="drop-menu" id="drawToolMenu" style="width:100%;">
            <summary class="btn btn-soft" id="stackXBtn4" style="width:100%; justify-content:center;">
              Draw · <span class="mono" id="drawToolLabel">Solid</span>
            </summary>

            <!-- DRAW: Main panel -->
            <div class="drop-panel draw-main-panel" id="drawMainPanel" style="min-width: 240px;">
              <button type="button" class="btn btn-soft" data-draw-tool="erase">Erase</button>

              <!-- Submenu opener: Line -->
              <button type="button" class="btn btn-soft" data-open-submenu="line" aria-haspopup="true" aria-expanded="false">
                Line ▸
              </button>

              <!-- Submenu opener: Area -->
              <button type="button" class="btn btn-soft" data-open-submenu="area" aria-haspopup="true" aria-expanded="false">
                Area ▸
              </button>

              <button type="button" class="btn btn-soft" data-draw-tool="quickVerify">Quick Verify</button>
              <button type="button" class="btn btn-soft" data-draw-tool="measure">Measure</button>
              <button type="button" class="btn btn-soft" data-draw-tool="label">Label</button>
              <button type="button" class="btn btn-soft" data-draw-tool="symbol">Symbol</button>

              <button type="button" class="btn btn-ghost" id="drawToolCloseBtn">Close</button>
            </div>

            <!-- DRAW: Submenu panel (overlay replacement; no side-cascade) -->
            <div class="drop-panel submenu-panel" id="drawSubmenuPanel" aria-hidden="true" style="min-width: 240px;">
              <button type="button" class="btn btn-ghost submenu-back" data-submenu-back="true">← Draw</button>

              <!-- Line submenu -->
              <div class="submenu-body" data-submenu="line">
                <button type="button" class="btn btn-soft" data-draw-tool="line">Line</button>
                <button type="button" class="btn btn-soft" data-draw-tool="rectLine">Rectangle</button>
                <button type="button" class="btn btn-soft" data-draw-tool="circleLine">Circle</button>
                <button type="button" class="btn btn-soft" data-draw-tool="freeDraw">Sketch</button>
              </div>

              <!-- Area submenu -->
              <div class="submenu-body" data-submenu="area">
                <button type="button" class="btn btn-soft" data-draw-tool="area">Area region</button>
                <button type="button" class="btn btn-soft" data-draw-tool="rect">Area rectangle</button>
                <button type="button" class="btn btn-soft" data-draw-tool="circle">Area circle</button>
                <button type="button" class="btn btn-soft" data-draw-tool="findArea">Find area</button>
              </div>
            </div>
          </details>
<!-- SUB-CHUNK 2.E END — Topbar Draw dropdown (line/area hub) -->
<!-- GPT_SAFE_ZONE END: TOPBAR_DRAW_DROPDOWN (SUB-CHUNK 2.E) -->

        </div>
        <!-- SUB-PART 2.B END — Topbar CENTER stack B status + mode slot (Units/Snap/Axis/Mode/Button 4) -->

      </div>
    </div>

    <!-- RIGHT column -->
    <div class="topbar-right">
      <div class="topbar-group context-toolspace" id="contextToolspace">
        <span class="topbar-label rail-label">Context</span>

        <div class="context-box">
          <div class="context-row snap-row">
            <button class="btn btn-soft" id="snapToggleBtn" type="button" style="width:64px; flex:0 0 auto; justify-content:space-between;" aria-pressed="false" title="Toggle snap ON/OFF">
              <span>Snap</span>
              <span class="value mono" id="snapToggleValue">OFF</span>
            </button>
            <div class="input-pill">
              <input type="number" id="snapStepInput" min="0.001" step="0.001" value="1" />
              <span class="unit mono" id="snapStepUnit">m</span>
            </div>
          </div>

          <!-- SUB-CHUNK 2.C BEGIN — Auto-commit toggle (Line tools) -->
          <div class="context-row">
            <span class="context-key">Auto</span>
            <!-- PROTECT: Axis-Lock style binary toggle (ON highlighted / OFF neutral). -->
            <button class="btn btn-soft" id="autoCommitBtn" style="width:100%; justify-content:center;" type="button" aria-label="Auto-commit line segments toggle">
              <span class="mono" id="autoCommitValue">OFF</span>
            </button>
          </div>
          <!-- SUB-CHUNK 2.C END — Auto-commit toggle (Line tools) -->

                    <!-- PROTECT: Tool row is ACTIVE. Live tool output is shown here (via #statusMode). -->
          <div class="context-row">
            <span class="context-key">Tool</span>
            <span class="context-na mono" id="toolspaceNA"><span class="mono" id="statusMode">Inspect</span></span>
          </div>
          <!-- SUB-CHUNK 2.D BEGIN — Persistent angle/dist controls (never disappear) -->
          <!-- PROTECT: These rows remain visible; JS disables/dims when snap mode != Angle. -->
          <div id="toolspaceAngle">
            <div class="context-row">
              <span class="context-key">Angle step</span>
              <div class="input-pill">
                <input type="number" id="angleSnapDegInput" min="1" step="1" value="45" />
                <span class="unit mono">deg</span>
              </div>
            </div>

            <div class="context-row">
              <span class="context-key">Dist override</span>
              <div class="input-pill">
                <input type="number" id="angleSnapDistInput" min="0" step="0.01" placeholder="(auto)" />
                <span class="unit mono" id="angleSnapDistUnit">m</span>
              </div>
            </div>

            <div id="anglePresetBar" style="display:none;"></div>
          </div>
          <!-- SUB-CHUNK 2.D END — Persistent angle/dist controls (never disappear) -->

        </div>
      </div>
    </div>

  </div>
  <!-- HTML end part 2 -->
</div><!-- /.chrome -->

<main>

<!-- HTML part 3 -->
<!-- Main work layout start + LEFT SIDEBAR (Tools section) -->
<div class="work-layout">
  
<!-- HTML end part 5 -->
    <!-- CENTER: HTML part 6 Canvas -->
    <section class="canvas-shell">
      <div id="canvasContainer">
        <canvas id="roadCanvas"></canvas>

        <!-- Always-visible axis indicator (screen-space coords) -->
        <div class="overlay-card overlay-axis" id="axisIndicator">
          <span class="mono">X →</span>
          <span class="mono">Y ↓</span>
        </div>

        <!-- Floating overlay for measurement label -->
        <div class="overlay-card overlay-measure" id="measureOverlay" style="display:none;">
          <span>Dist</span>
          <span class="value mono" id="measureDistance">0.00</span>
          <span class="value mono" id="measureDistanceUnit">m</span>
          <span class="value mono" id="measureAngle">0°</span>
          <button type="button" class="overlay-close" id="measureClearBtn">×</button>
        </div>
      </div>
    </section>
<!-- HTML end part 6 -->
    <!-- RIGHT: Properties, layers, job link HTML part 7 -->
    <aside class="sidebar sidebar-right" id="rightSidebar">
      <!-- Selected properties -->
      <section class="panel-section">
        <div class="panel-title-row">
          <div class="panel-title">Properties</div>
          
          <div class="panel-title-actions">
            <span class="panel-sub">Active feature details</span>
            <button class="close-btn" id="propCloseBtn" title="Close Properties" aria-label="Close Properties">×</button>
          </div>
        </div>

        <div class="prop-field-row">
          <div class="prop-label">Type</div>
          <div class="mono" id="propTypeValue">–</div>
        </div>
        <div class="prop-field-row">
          <div class="prop-label">ID</div>
          <div class="mono" id="propIdValue">–</div>
        </div>

        <div class="prop-field-row">
          <div class="prop-label">Group</div>
          <input type="text" id="propGroupInput" placeholder="optional group tag" />
        </div>
<!-- HTML end part 7 -->

        <!-- Line fields HTML part 8 -->
        <div id="selLineFields" style="display:none; margin-top:6px;">

          <!-- sub-chunk 8.A · Length (existing) -->
          <div class="prop-field-row">
            <div class="prop-label">Length</div>
            <div class="input-pill">
              <input type="number" id="selLengthInput" min="0" step="0.1" />
              <span class="unit" id="selLengthUnit">m</span>
            </div>
          </div>


          <!-- sub-chunk 8.B · Stroke width -->
          <div class="prop-field-row">
            <div class="prop-label">Width</div>
            <div class="input-pill">
              <input type="number" id="selStrokeWidthInput" min="0.5" step="0.5" />
              <span class="unit mono">px</span>
            </div>
          </div>

          <!-- sub-chunk 8.C · Stroke color -->
          <div class="prop-field-row">
            <div class="prop-label">Color</div>
            <div class="input-pill" style="display:flex; align-items:center; gap:8px;">
              <input type="color" id="selStrokeColorInput" style="height:22px; width:34px; padding:0; border:none; background:transparent;" />
              <span class="mono" id="selStrokeColorText">#ffffff</span>
            </div>
          </div>

          <!-- sub-chunk 8.D · Pattern selector -->
          <div class="prop-field-row">
            <div class="prop-label">Pattern</div>
            <select id="selStrokePatternSelect">
              <option value="auto">(auto)</option>
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="centerline">Centerline</option>
              <option value="custom">Custom dash</option>
            </select>
          </div>

          <!-- sub-chunk 8.E · Custom dash (comma list) -->
          <div class="prop-field-row" id="selStrokeDashRow" style="display:none;">
            <div class="prop-label">Dash</div>
            <input type="text" id="selStrokeDashInput" class="mono" placeholder="e.g. 10,8 or 18,6,3,6" />
          </div>

        </div>
        <!-- HTML end part 8 -->

        <!-- Symbol fields HTML part 9 -->
        <div id="selSymbolFields" style="display:none; margin-top:6px;">
          <div class="prop-field-row">
            <div class="prop-label">Rotation</div>
            <div class="input-pill">
              <input type="number" id="selAngleInput" step="1" />
              <span class="unit">deg</span>
            </div>
          </div>
          <div class="prop-field-row">
            <div class="prop-label">Size</div>
            <div class="input-pill">
              <input type="number" id="selSizeInput" min="0.1" step="0.1" />
              <span class="unit" id="selSizeUnit">m</span>
            </div>
          </div>
        </div>
        <!-- HTML end part 9 -->

        <!-- Area fields HTML part 10 -->
        
          <!-- sub-chunk 10.MA · Multi-select area summary -->
          <div id="selMultiAreaFields" style="display:none; margin-top:6px;">
            <div class="prop-field-row">
              <div class="prop-label">Selected</div>
              <div class="input-pill">
                <input type="number" id="selMultiAreaCountInput" disabled />
                <span class="unit mono">areas</span>
              </div>
            </div>
            <div class="prop-field-row">
              <div class="prop-label">Total area</div>
              <div class="input-pill">
                <input type="number" id="selMultiAreaTotalInput" disabled />
                <span class="unit" id="selMultiAreaUnit">m²</span>
              </div>
            </div>
          </div>

<div id="selAreaFields" style="display:none; margin-top:6px;">
          <div class="prop-field-row">
            <div class="prop-label">Name</div>
            <input type="text" id="selAreaNameInput" placeholder="e.g. Johnson St + intersection" />
          </div>
          <div class="prop-field-row">
            <div class="prop-label">Area</div>
            <div class="input-pill">
              <input type="number" id="selAreaValueInput" disabled />
              <span class="unit" id="selAreaUnit">m²</span>
            </div>
          </div> <!-- FIX: close Area .prop-field-row -->
          
          <!-- sub-chunk 10.SD · Shape dimensions (rect/circle) -->
          <div id="selShapeDimFields" style="display:none; margin-top:4px;">
            <div class="prop-field-row" id="selShapeWidthRow" style="display:none;">
              <div class="prop-label">Width</div>
              <div class="input-pill">
                <input type="number" id="selShapeWidthInput" min="0" step="0.1" />
                <span class="unit" id="selShapeWidthUnit">m</span>
              </div>
            </div>
            <div class="prop-field-row" id="selShapeHeightRow" style="display:none;">
              <div class="prop-label">Height</div>
              <div class="input-pill">
                <input type="number" id="selShapeHeightInput" min="0" step="0.1" />
                <span class="unit" id="selShapeHeightUnit">m</span>
              </div>
            </div>
            <div class="prop-field-row" id="selShapeDiameterRow" style="display:none;">
              <div class="prop-label">Diameter</div>
              <div class="input-pill">
                <input type="number" id="selShapeDiameterInput" min="0" step="0.1" />
                <span class="unit" id="selShapeDiameterUnit">m</span>
              </div>
            </div>
          </div>
          <div class="prop-field-row">
            <div class="prop-label">Surface</div>
            <input type="text" id="selAreaSurfaceInput" placeholder="e.g. 50mm asphalt" />
          </div>
          <div class="prop-field-row">
            <div class="prop-label">Job</div>
            <input type="text" id="selAreaJobInput" placeholder="Job ID / note" />
          </div>
        </div>
<!-- HTML end part 10 -->
        <!-- Label fields HTML part 11 (11.1 — text & size) -->
        <div id="selLabelFields" style="display:none; margin-top:6px;">
          <div class="prop-field-row">
            <div class="prop-label">Text</div>
            <input type="text" id="selLabelTextInput" placeholder="Label text" />
          </div>
          <div class="prop-field-row">
            <div class="prop-label">Size</div>
            <div class="input-pill">
              <input type="number" id="selLabelSizeInput" min="0.1" step="0.1" />
              <span class="unit" id="selLabelSizeUnit">m</span>
            </div>
          </div>
        </div>
      </section>
      <!-- HTML end part 11 -->

      
      
      <!-- HTML PART 11.25 — Display settings panel (moved from Properties) -->
      <section class="panel-section" id="displaySettingsPanel">
        <div class="panel-title-row">
          <div class="panel-title">Display</div>
          <span class="panel-sub">Canvas + Theme</span>
        </div>

<!-- sub-chunk 8.F · Display (Canvas + Theme) BEGIN -->
        <div id="displayFields">
          <div class="prop-subtitle">Display</div>

          <div class="prop-field-row">
            <div class="prop-label">Canvas</div>
            <div class="input-pill">
              <select id="canvasBgPresetSelect" aria-label="Canvas background preset">
                <option value="draft-blue">Draft Blue</option>
                <option value="draft-green">Draft Green</option>
                <option value="white">White</option>
                <option value="dark">Dark</option>
                <option value="custom">Custom…</option>
              </select>
            </div>
          </div>

          <div class="prop-field-row" id="canvasBgCustomRow" style="display:none;">
            <div class="prop-label">Custom</div>
            <div class="input-pill">
              <input type="color" id="canvasBgColorInput" value="#020617" aria-label="Custom canvas background color" />
              <input type="text" id="canvasBgColorText" class="mono" value="#020617" aria-label="Custom canvas background hex" />
            </div>
          </div>

          <!-- sub-chunk 8.F.1 · Background image controls BEGIN -->
          <div class="prop-field-row">
            <div class="prop-label">BG image</div>
            <div class="tool-row" style="justify-content:flex-end; gap:8px;">
              <button class="btn btn-soft" id="bgImageLoadBtn" type="button" title="Load an image as canvas background">Load</button>
              <button class="btn btn-soft" id="bgImageClearBtn" type="button" title="Remove the background image">Clear</button>
            </div>
          </div>

          <input type="file" id="bgImageFileInput" accept="image/*" style="display:none;" />

          <div class="prop-field-row" id="bgImageOpacityRow" style="display:none;">
            <div class="prop-label">BG opacity</div>
            <div class="input-pill">
              <input type="range" id="bgImageOpacityInput" min="0" max="100" value="60" />
              <span class="unit mono" id="bgImageOpacityValue">60</span>
              <span class="unit mono">%</span>
            </div>
          </div>

          <div class="prop-field-row" id="bgImageScaleRow" style="display:none;">
            <div class="prop-label">BG m/px</div>
            <div class="input-pill">
              <input type="number" id="bgImageMppInput" min="0" step="0.0001" />
              <button class="btn btn-soft" id="bgImageCenterBtn" type="button" style="margin-left:8px;">Center</button>
            </div>
          </div>

          <div class="prop-field-row" id="bgImageCalRow" style="display:none;">
            <div class="prop-label">BG calibrate</div>
            <div class="input-pill">
              <input type="number" id="bgImageCalLenInput" min="0" step="0.01" placeholder="Known length" />
              <span class="unit mono" id="bgImageCalUnit">m</span>
              <button class="btn btn-soft" id="bgImageCalBtn" type="button" style="margin-left:8px;">Calibrate</button>
              <button class="btn btn-soft" id="bgImageCalCancelBtn" type="button" style="margin-left:8px; display:none;">Cancel</button>
            </div>
          </div>

          <!-- sub-chunk 8.F.1 · Background image controls END -->

          
          <div class="prop-field-row">
            <div class="prop-label">Grid (minor)</div>
            <div class="input-pill">
              <input type="range" id="gridOpacityMinorInput" min="0" max="100" value="100" />
              <span class="unit mono" id="gridOpacityMinorValue">100</span>
              <span class="unit mono">%</span>
            </div>
          </div>

          <div class="prop-field-row">
            <div class="prop-label">Grid (major)</div>
            <div class="input-pill">
              <input type="range" id="gridOpacityMajorInput" min="0" max="100" value="100" />
              <span class="unit mono" id="gridOpacityMajorValue">100</span>
              <span class="unit mono">%</span>
            </div>
          </div>
<div class="prop-field-row">
            <div class="prop-label">Theme</div>
            <div class="input-pill">
              <select id="uiThemeSelect" aria-label="UI theme">
                <option value="dark">Dark</option>
                <option value="mid">Mid</option>
                <option value="light">Light</option>
                <option value="custom">Custom…</option>
              
              </select>
            </div>
          </div>


<div class="prop-field-row" id="uiThemeCustomRow" style="display:none;">
  <div class="prop-label">UI Color</div>
  <div class="input-pill">
    <input type="color" id="uiThemeCustomColorInput" value="#2563eb" aria-label="Custom UI theme color" />
    <input type="text" id="uiThemeCustomColorText" class="mono" value="#2563eb" aria-label="Custom UI theme hex" />
  </div>
</div>

<div class="prop-field-row" id="uiThemeCustomModeRow" style="display:none;">
  <div class="prop-label">Custom Mode</div>
  <div class="input-pill">
    <select id="uiThemeCustomModeSelect" aria-label="Custom theme mode">
      <option value="dark">Dark</option>
      <option value="light">Light</option>
    </select>
  </div>
</div>

<div class="prop-field-row" id="uiThemeCustomStrengthRow" style="display:none;">
  <div class="prop-label">Tint Strength</div>
  <div class="input-pill">
    <input type="range" id="uiThemeCustomStrengthRange" min="0" max="40" step="1" value="14" aria-label="Custom tint strength" />
    <span class="unit mono" id="uiThemeCustomStrengthText">14</span>
    <span class="unit mono">%</span>
  </div>
</div>

<div class="prop-field-row" id="uiThemeBtnAutoFacesRow">
            <div class="prop-label">Auto Btn Faces</div>
            <div class="input-pill" style="justify-content:flex-start;">
              <label style="display:flex; align-items:center; gap:10px;">
                <input type="checkbox" id="btnAutoFacesCheck" />
                <span class="unit mono">Follow theme</span>
              </label>
            </div>
          </div>
  <!-- Control Wells Palette controls removed (v1.6.6.6) -->

<div class="prop-field-row">
            <div class="prop-label">Buttons A</div>
            <div class="input-pill">
              <input type="color" id="btnFaceAColorInput" />
              <span class="unit mono" id="btnFaceAColorText">#ffffff</span>
            </div>
          </div>

          <div class="prop-field-row">
            <div class="prop-label">Buttons B</div>
            <div class="input-pill">
              <input type="color" id="btnFaceBColorInput" />
              <span class="unit mono" id="btnFaceBColorText">#020617</span>
            </div>
          </div>

          <div class="prop-field-row">
            <div class="prop-label">Btn border</div>
            <div class="input-pill">
              <input type="color" id="btnBorderColorInput" />
              <span class="unit mono" id="btnBorderColorText">#0000ff</span>
            </div>
          </div>

          <div class="prop-field-row">
            <div class="prop-label">Presets</div>
            <div class="tool-row" style="justify-content:flex-end; gap:8px;">
              <button class="btn btn-soft" id="saveDisplayPresetBtn" type="button">Save preset</button>
              <button class="btn btn-soft" id="resetFactoryBtn" type="button">Reset factory</button>
            </div>
          </div>

          

        </div>
<!-- sub-chunk 8.F · Display (Canvas + Theme) END -->

      </section>

<!-- HTML PART 11.5 — Line defaults panel (persistent) -->
      <section class="panel-section" id="lineDefaultsPanel">
        <div class="panel-title-row">
          <div class="panel-title">Line</div>
          <span class="panel-sub">Defaults</span>
        </div>

        <div class="prop-field-row">
          <div class="prop-label">Thickness</div>
          <div class="input-pill">
            <input type="number" id="lineDefaultWidthInput" min="0.5" step="0.5" />
            <span class="unit mono">px</span>
          </div>
        </div>

        <div class="prop-field-row">
          <div class="prop-label">Color</div>
          <div class="input-pill" style="display:flex; align-items:center; gap:8px;">
            <input type="color" id="lineDefaultColorInput" style="height:34px; width:34px; padding:0; border:none; background:transparent;" />
            <span class="mono" id="lineDefaultColorText">#ffffff</span>
          </div>
        </div>

        <div class="prop-field-row">
          <div class="prop-label">Style</div>
          <select id="lineDefaultStyleSelect">
            <option value="auto">(auto)</option>
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="centerline">Centerline</option>
                      <option value="custom">Custom</option>
          </select>
        </div>

        <!-- Custom dash list (comma-separated, px units) -->
        <div class="prop-field-row" id="lineDefaultDashRow" style="display:none;">
          <div class="prop-label">Dash</div>
          <input id="lineDefaultDashInput" type="text" value="10, 8" placeholder="e.g. 10, 8 or 18, 6, 3, 6" />
        </div>

        <div class="line-preview-wrap aria-hidden="true">
          <div class="line-preview-head">
            <span class="line-preview-title">Preview</span>
            <span class="line-preview-meta mono" id="lineDefaultPreviewMeta"></span>
          </div>
          <div class="line-preview-track">
            <div id="lineDefaultPreviewLine"></div>
          </div>
        </div>
      
      </section>

<!-- HTML PART 11.55 — Measure defaults panel (persistent) -->
      <section class="panel-section" id="measureDefaultsPanel">
        <div class="panel-title-row">
          <div class="panel-title">Measure</div>
          <span class="panel-sub">Defaults</span>
        </div>
<div class="prop-field-row">
          <div class="prop-label">Thickness</div>
          <div class="input-pill">
            <input type="number" id="measureDefaultWidthInput" min="0.5" step="0.5" />
            <span class="unit">px</span>
          </div>
        </div>

        <div class="prop-field-row">
          <div class="prop-label">Color</div>
          <div class="input-pill" style="display:flex; align-items:center; gap:8px;">
            <input type="color" id="measureDefaultColorInput" style="width:34px; height:34px; padding:0; border:none; background:transparent;" />
            <span class="mono" id="measureDefaultColorText">#a855f7</span>
          </div>
        </div>

        <div class="prop-field-row">
          <div class="prop-label">Style</div>
          <select id="measureDefaultStyleSelect">
            <option value="auto">(auto)</option>
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="custom">Custom</option>
          </select>
        </div>

        <div class="prop-field-row" id="measureDefaultDashRow" style="display:none;">
          <div class="prop-label">Dash</div>
          <div class="input-pill">
            <input type="text" id="measureDefaultDashInput" placeholder="e.g., 10,8" />
          </div>
        </div>

        <div class="prop-field-row">
          <div class="prop-label">Label</div>
          <select id="measureDefaultModeSelect" aria-label="Measure label mode">
            <option value="distance">Distance</option>
            <option value="distance_angle">Distance + Angle</option>
            <option value="angle">Angle</option>
            <option value="none">None</option>
          </select>
        </div>

        <div class="prop-field-row">
          <div class="prop-label">Decimals</div>
          <div class="input-pill">
            <input type="number" id="measureDefaultDecimalsInput" min="0" max="6" step="1" value="2" />
            <span class="unit">dp</span>
          </div>
        </div>
        <div class="line-preview-wrap measure-preview-wrap" aria-hidden="true">
          <div class="line-preview-head">
            <span class="line-preview-title">Preview</span>
            <span class="line-preview-meta mono" id="measureDefaultPreviewMeta"></span>
          </div>
          <div class="line-preview-track">
            <canvas class="line-preview-canvas" id="measureDefaultPreviewCanvas"></canvas>
            <div id="measureDefaultPreviewLine"></div>
            <div class="measure-preview-label mono" id="measureDefaultPreviewLabel"></div>
          </div>
        </div>

      </section>

<!-- HTML PART 11.6 — Area defaults panel (persistent) -->
      <section class="panel-section" id="areaDefaultsPanel">
        <div class="panel-title-row">
          <div class="panel-title">Area</div>
          <span class="panel-sub">Fill color &amp; opacity (defaults)</span>
        </div>

        <div class="prop-field-row">
          <div class="prop-label">Color</div>
          <div class="input-pill">
            <input type="color" id="areaDefaultColorInput" value="#38bdf8" aria-label="Area default color" />
            <input type="text" id="areaDefaultColorText" class="mono" value="#38bdf8" aria-label="Area default hex" />
          </div>
        </div>

        <div class="prop-field-row">
          <div class="prop-label">Opacity</div>
          <div class="input-pill" style="gap:10px;">
            <input type="range" id="areaDefaultOpacityRange" min="0" max="100" step="1" value="12" aria-label="Area default opacity percent" style="flex:1; min-width:120px;" />
            <div class="mono" id="areaDefaultOpacityPct" style="min-width:48px; text-align:right;">12%</div>
          </div>
        </div>
      </section>

<!-- HTML PART 12 — Layers panel -->
      <section class="panel-section">
        <div class="panel-title-row">
          <div class="panel-title">Layers</div>
          <span class="panel-sub">Visibility &amp; lock</span>
        </div>

        <!-- HTML PART 12.1a — Line layers (UI names only; internal IDs unchanged) -->
        <div id="layersList">
          <div class="layer-row">
            <div class="layer-left">
              <div class="layer-color" style="background:#e5e7eb;"></div>
              <span class="layer-name">Solid lines</span>
            </div>
            <div class="layer-controls">
              <input type="checkbox" class="layer-checkbox" id="layerRoadsVisible" checked />
              <input type="checkbox" class="layer-checkbox layer-lock" id="layerRoadsLocked" title="Lock layer" />
            </div>
          </div>

          <div class="layer-row">
            <div class="layer-left">
              <div class="layer-color" style="background:#facc15;"></div>
              <span class="layer-name">Dashed lines</span>
            </div>
            <div class="layer-controls">
              <input type="checkbox" class="layer-checkbox" id="layerLanesVisible" checked />
              <input type="checkbox" class="layer-checkbox layer-lock" id="layerLanesLocked" title="Lock layer" />
            </div>
          </div>
          <!-- HTML END PART 12.1a -->

          <!-- HTML PART 12.1b — Non-line layers -->
          <div class="layer-row">
            <div class="layer-left">
              <div class="layer-color" style="background:#38bdf8;"></div>
              <span class="layer-name">Areas</span>
            </div>
            <div class="layer-controls">
              <input type="checkbox" class="layer-checkbox" id="layerAreasVisible" checked />
              <input type="checkbox" class="layer-checkbox layer-lock" id="layerAreasLocked" title="Lock layer" />
            </div>
          </div>

          <div class="layer-row">
            <div class="layer-left">
              <div class="layer-color" style="background:#e5e7eb;"></div>
              <span class="layer-name">Labels</span>
            </div>
            <div class="layer-controls">
              <input type="checkbox" class="layer-checkbox" id="layerLabelsVisible" checked />
              <input type="checkbox" class="layer-checkbox layer-lock" id="layerLabelsLocked" title="Lock layer" />
            </div>
          </div>

          <div class="layer-row">
            <div class="layer-left">
              <div class="layer-color" style="background:#e5e7eb;"></div>
              <span class="layer-name">Symbols</span>
            </div>
            <div class="layer-controls">
              <input type="checkbox" class="layer-checkbox" id="layerSymbolsVisible" checked />
              <input type="checkbox" class="layer-checkbox layer-lock" id="layerSymbolsLocked" title="Lock layer" />
            </div>
          </div>

          <div class="layer-row">
            <div class="layer-left">
              <div class="layer-color" style="background:#a855f7;"></div>
              <span class="layer-name">Measurements</span>
            </div>
            <div class="layer-controls">
              <input type="checkbox" class="layer-checkbox" id="layerMeasureVisible" checked />
              <input type="checkbox" class="layer-checkbox layer-lock" id="layerMeasureLocked" title="Lock layer" />
            </div>
          </div>
          <!-- HTML END PART 12.1b -->
        </div>
      </section>
      <!-- HTML end part 12 -->

      <!-- HTML PART 13 — Job link / integration -->
      <section class="panel-section">
        <div class="panel-title-row">
          <div class="panel-title">Job link</div>
          <span class="panel-sub">For Costing &amp; Records</span>
        </div>
        <div class="panel-row">
          <input type="text" id="draftJobIdInput" placeholder="Job ID / client" />
        </div>
        <div class="panel-row">
          <button class="btn btn-soft" id="sendAreasToCostingBtn" disabled title="Coming soon" style="opacity:0.65; cursor:not-allowed;">Send areas to Costing (coming soon)</button>
        </div>
        <div class="panel-note">
          Coming soon.
        </div>
      </section>
    </aside>

    <!-- PROTECT: DO NOT DELETE / DO NOT MOVE — closes .work-layout grid -->
  </div>
  <!-- HTML END PART 13 -->

<!-- Status bar HTML part 14 -->
<div class="status-bar">
  <div class="status-left">
    <span class="status-pill">
      <span>Status</span>
      <span class="value mono" id="statusLeft">–</span>
      <span class="status-actions" id="statusActions" aria-hidden="true">
        <button type="button" class="status-action-btn" id="statusReportBtn" title="Generate report" hidden>Report</button>
        <button type="button" class="status-action-btn" id="statusDismissBtn" title="Dismiss warning" hidden>Dismiss</button>
      </span>
    </span>
  </div>

  <div class="status-right">
    <span class="status-pill">
      <span>Cursor</span>
      <span class="value mono" id="statusCursor">–</span>
    </span>
  </div>
</div>

<!-- PROTECT: DO NOT DELETE / DO NOT MOVE — closes <main> structural wrapper -->
</main>

<button id="exitFullViewBtn" class="btn btn-soft">
  <span class="icon">✕</span>
  <span>Exit board view</span>
</button>
<!-- HTML end part 14 -->
<script>

  // SCRIPT PART 1.1 BEGIN (LLM ANCHOR)

  // SCRIPT PATCH P4C BEGIN — Embed compact mode (Runway/iframe)
  // If Field Draft is running inside the Dev Index runway iframe, tighten UI to preserve canvas.
  try{
    if (window.self !== window.top) document.documentElement.classList.add('embed');
  }catch(_){
    // cross-origin access can throw; treat as embedded
    document.documentElement.classList.add('embed');
  }
  // SCRIPT PATCH P4C END — Embed compact mode (Runway/iframe)

// --- FIELD DRAFT v1.0 · SCRIPT PART 1 · STATE + DRAWING + INSPECTOR ------
  // --- Core DOM refs chunk 1 ----------------------------------------------------------
  // DOM REFS GATE: Hard Required IDs must be present here; optional/legacy IDs may appear but require guarded bindings.
  // See CL-01A Runtime Contract Table + CL-01A.2.1.

  // SUB-CHUNK 1.REQ BEGIN — Contract lint + HARD REQUIRED IDs table (CL-01A)
  // CONTRACT LINT (non-fatal): helps catch truncation/merge drift early without changing runtime behavior.
  // Logs missing HARD REQUIRED IDs as defined in CL-01A.
  (function contractLintHardRequiredIDs(){
    try {
      const REQUIRED_IDS = [
        'roadCanvas','canvasContainer',
        'draftNameInput','saveDraftBtn','loadDraftBtn','deleteDraftBtn','loadDraftSelect',
        'exportJsonBtn','importJsonBtn','importIntoCurrentBtn','exportPngBtn','importFileInput',
        'featureSelect',
        'gridPxInput','metersPerGridInput','snapStepInput',
        'lockAxisBtn','autoCommitBtn','autoCommitValue','contextToolspace',
        'statusMode','statusCursor','statusUnits','statusSnapMode',
        'undoBtn','redoBtn','deleteSelectedBtn','clearAllBtn',
        'fullViewBtn','exitFullViewBtn',
        'rightSidebar'
      ];

      // OPTIONAL / LEGACY IDs (CL-01A-OPT): allowed to be absent in this build.
      // Keep this list to preserve historical intent without creating false-positive lint noise.
      const OPTIONAL_IDS = [
        'statusScale',                  // retired status readout (legacy)
        'statusSnap',                   // retired status readout (legacy)
        'toggleRightPanelBtn',          // old ID (replaced by LEGACY_* marker in DOM)
        'topMultiSelectBtn5'            // Multi-select (Button 5)
      ];
      const missing = REQUIRED_IDS.filter(id => !document.getElementById(id));
      if (missing.length) {
        console.warn('[FIELD DRAFT][CONTRACT LINT] Missing HARD REQUIRED IDs:', missing);
      }
    } catch (e) {
      console.warn('[FIELD DRAFT][CONTRACT LINT] Unexpected error:', e);
    }
  })();
  // SUB-CHUNK 1.REQ END — Contract lint + HARD REQUIRED IDs table (CL-01A)

  // SUB-CHUNK 1.UI1 BEGIN — Core UI refs (canvas, topbar, menus, status)
  const canvas = document.getElementById('roadCanvas');
  const container = document.getElementById('canvasContainer');
  // Hard required: fail loudly if the core canvas contract is broken.
  if (!canvas) { throw new Error('FIELD DRAFT: Missing required DOM node #roadCanvas'); }
  const ctx = canvas.getContext('2d');
  if (!ctx) { throw new Error('FIELD DRAFT: Unable to acquire 2D context from #roadCanvas'); }
// Top bar + selectors
  const draftNameInput  = document.getElementById('draftNameInput');
  const saveDraftBtn    = document.getElementById('saveDraftBtn');
  const loadDraftBtn    = document.getElementById('loadDraftBtn');
  const deleteDraftBtn = document.getElementById('deleteDraftBtn');
    const loadDraftSelect = document.getElementById('loadDraftSelect');
const exportJsonBtn   = document.getElementById('exportJsonBtn');
  const importJsonBtn   = document.getElementById('importJsonBtn');
  const importIntoCurrentBtn = document.getElementById('importIntoCurrentBtn');
  const exportPngBtn    = document.getElementById('exportPngBtn');
  const importFileInput = document.getElementById('importFileInput');  const fullViewBtn         = document.getElementById('fullViewBtn');
  const exitFullViewBtn     = document.getElementById('exitFullViewBtn');
  const featureSelect       = document.getElementById('featureSelect');
  const selType             = document.getElementById('selType');
  const toggleRightPanelBtn = document.getElementById('toggleRightPanelBtn');
  const rightSidebar        = document.getElementById('rightSidebar');

  // Context toolspace (top bar runway)
  const contextToolspace    = document.getElementById('contextToolspace');
  const snapStepInput       = document.getElementById('snapStepInput');
  const toolspaceNA         = document.getElementById('toolspaceNA');

  
  const autoCommitBtn      = document.getElementById('autoCommitBtn');
  const autoCommitValue    = document.getElementById('autoCommitValue');
const toolspaceAngle      = document.getElementById('toolspaceAngle');
  const angleSnapDegInput   = document.getElementById('angleSnapDegInput');
  const angleSnapDistInput  = document.getElementById('angleSnapDistInput');
  const anglePresetBar      = document.getElementById('anglePresetBar');

  // Tools
  const toolInspectBtn = null; // Phase-4B: legacy sidebar control pruned (sidebar removed)
  const toolMeasureBtn = null; // Phase-4B: legacy sidebar control pruned (sidebar removed)
  const toolAreaBtn = null; // Phase-4B: legacy sidebar control pruned (sidebar removed)
  const toolSymbolBtn = null; // Phase-4B: legacy sidebar control pruned (sidebar removed)
  const toolLabelBtn = null; // Phase-4B: legacy sidebar control pruned (sidebar removed)
  // SUB-CHUNK 1.OPT BEGIN — Optional/legacy UI refs (MUST remain guarded)
  const toolEraseBtn        = document.getElementById('toolEraseBtn') || null; // optional/legacy id (must be guarded at bind sites)

  // Line Tool (new)
  const lineToolMenu        = document.getElementById('lineToolMenu') || null; // optional/legacy id (must be guarded at bind sites)
  const lineToolBtn         = document.getElementById('lineToolBtn') || null; // optional/legacy id (must be guarded at bind sites)
  const lineStyleLabel      = document.getElementById('lineStyleLabel') || null; // optional/legacy id (must be guarded at bind sites)
  const lineToolCloseBtn    = document.getElementById('lineToolCloseBtn') || null; // optional/legacy id (must be guarded at bind sites)
  // SUB-CHUNK 1.OPT END — Optional/legacy UI refs (MUST remain guarded)

  // Line style selector (topbar stack Button 1) — uniform dropdown UI
  const lineStyleSelect     = document.getElementById('lineStyleSelect');

  // Legacy refs (kept guarded / may be absent after UI unification)
  const lineOptionsMenu     = null;
  const lineOptionsBtn      = null;
  const lineOptionsLabel    = null;
  const lineOptionsCloseBtn = null;

    // Stack X quick buttons (topbar placeholders promoted)
  const stackXBtn2          = document.getElementById('stackXBtn2');
  const stackXBtn3          = document.getElementById('stackXBtn3');
  const stackXBtn4Alt       = document.getElementById('stackXBtn4Alt');

  // Topbar Stack Y quick actions
  const stackYBtn1          = document.getElementById('stackYBtn1'); // Button 4 (reserved placeholder)
  const stackYBtn2          = document.getElementById('stackYBtn2'); // Button 5: Properties
  const stackYBtn4          = document.getElementById('stackYBtn4'); // Button 8
  // LEGACY: stackYBtn3 was promoted to Edit ▾ (no longer exists as a button). Keep null-safe ref to avoid ReferenceError.
  const stackYBtn3 = document.getElementById('stackYBtn3'); // legacy (should be null)

  // Draw Tool (topbar hub)
  const drawToolMenu        = document.getElementById('drawToolMenu');
  const drawToolBtn         = document.getElementById('stackXBtn4'); // <summary> button
  const drawToolLabel       = document.getElementById('drawToolLabel');
  const drawToolCloseBtn    = document.getElementById('drawToolCloseBtn');

  // Edit
  const finishPathBtn       = null; // Phase-4B Pass2: legacy control pruned (no matching HTML id)
  const undoBtn             = document.getElementById('undoBtn');
  const redoBtn             = document.getElementById('redoBtn');
  const deleteSelectedBtn   = document.getElementById('deleteSelectedBtn');
  const clearAllBtn         = document.getElementById('clearAllBtn');
  const editMovePointBtn    = null; // Phase-4B Pass2: legacy sidebar control pruned (migrated to topbar stack buttons)
  const editMoveShapeBtn    = null; // Phase-4B Pass2: legacy sidebar control pruned (migrated to topbar stack buttons)
  const editAddVertexBtn    = null; // Phase-4B Pass2: legacy sidebar control pruned (migrated to topbar stack buttons)
  const editRemoveVertexBtn = null; // Phase-4B Pass2: legacy sidebar control pruned (migrated to topbar stack buttons)
    // Legacy DOM ref pruned (Phase 4B Pass 3): sidebar editDuplicateBtn (topbar Duplicate remains)
  const editDuplicateBtn    = null;
    // Legacy DOM ref pruned (Phase 4B Pass 3): sidebar editCutoutBtn (topbar Cut-out remains)
  const editCutoutBtn       = null;

  // Options
  const labelKindSelect     = document.getElementById('labelKindSelect');
  const symbolSelect        = document.getElementById('symbolSelect');

  // --- Symbol dropdown UX guard ------------------------------------------------------
  // Native <select> widgets open the picker scrolled to the currently-selected option.
  // After moving user presets to the top of the symbol list, that behavior can land
  // users in the generic section when their current selection is a built-in symbol.
  //
  // Goal: when user presets exist, opening the dropdown should start at the top so
  // user presets are immediately visible. Because native pickers don't expose scroll
  // control, we "prime" the picker on open by temporarily selecting the first user
  // preset option. If the user cancels (no change), we restore the prior value on blur.
  // This preserves truth: the actual selection only changes if the user chooses.
  let __symSelPrimed = false;
  let __symSelPrevValue = null;
	  let __symSelPrimedValue = null;
  function __symSelHasUserOptions(){
    try{ return !!(symbolSelect && symbolSelect.querySelector('option[data-user-symbol="1"]')); }catch(_){ return false; }
  }
  function __symSelPrimeToTop(){
    try{
      if (!symbolSelect) return;
      if (__symSelPrimed) return;
      if (!__symSelHasUserOptions()) return;
      const cur = String(symbolSelect.value||'');
      if (cur.startsWith('user:')) return; // already in user section

      const firstUser = symbolSelect.querySelector('option[data-user-symbol="1"]');
      if (!firstUser) return;

	      __symSelPrevValue = cur;
	      __symSelPrimedValue = String(firstUser.value||'');
	      __symSelPrimed = true;
	      // Prime without firing an intentional user change.
	      symbolSelect.value = __symSelPrimedValue;
	    }catch(_){ __symSelPrimed = false; __symSelPrevValue = null; __symSelPrimedValue = null; }
  }
  function __symSelUnprimeRestoreIfNeeded(){
    try{
      if (!symbolSelect) return;
      if (!__symSelPrimed) return;
      // If user did not commit a real change, restore previous value.
	      if (__symSelPrevValue != null && __symSelPrimedValue != null && String(symbolSelect.value||'') === String(__symSelPrimedValue||'')){
        symbolSelect.value = __symSelPrevValue;
      }
    }catch(_){
      // no-op
    }
    __symSelPrimed = false;
    __symSelPrevValue = null;
	    __symSelPrimedValue = null;
  }

	  // Attach priming listeners early (before other handlers):
	  // - pointerdown/mousedown/touchstart: prime before native picker opens
	  // - blur: restore if the user cancels
	  // - change: commit (no restore)
	  try{
	    if (symbolSelect){
	      symbolSelect.addEventListener('pointerdown', __symSelPrimeToTop, true);
	      symbolSelect.addEventListener('mousedown', __symSelPrimeToTop, true);
	      symbolSelect.addEventListener('touchstart', __symSelPrimeToTop, { capture:true, passive:true });
	      symbolSelect.addEventListener('focus', __symSelPrimeToTop, true);
	      symbolSelect.addEventListener('blur', __symSelUnprimeRestoreIfNeeded, true);
	      symbolSelect.addEventListener('change', ()=>{ __symSelPrimed = false; __symSelPrevValue = null; __symSelPrimedValue = null; }, true);
	    }
	  }catch(_){ }

  // View / scale
  const gridPxInput         = document.getElementById('gridPxInput');
  const metersPerGridInput  = document.getElementById('metersPerGridInput');

  // Scale +/- (gesture-free zoom control)
  const gridPxMinusBtn      = document.getElementById('gridPxMinusBtn');
  const gridPxPlusBtn       = document.getElementById('gridPxPlusBtn');
  const metersPerGridMinusBtn = document.getElementById('metersPerGridMinusBtn');
  const metersPerGridPlusBtn  = document.getElementById('metersPerGridPlusBtn');

  const lockAxisBtn         = document.getElementById('lockAxisBtn');

  // Properties panel
  const propTypeValue       = document.getElementById('propTypeValue');
  const propIdValue         = document.getElementById('propIdValue');
  const propGroupInput      = document.getElementById('propGroupInput');

  const selLineFields       = document.getElementById('selLineFields');
  const selSymbolFields     = document.getElementById('selSymbolFields');
  const selAreaFields       = document.getElementById('selAreaFields');
  const selMultiAreaFields  = document.getElementById('selMultiAreaFields');
  const selMultiAreaCountInput = document.getElementById('selMultiAreaCountInput');
  const selMultiAreaTotalInput = document.getElementById('selMultiAreaTotalInput');

  const selLabelFields      = document.getElementById('selLabelFields');
const selLengthInput      = document.getElementById('selLengthInput');
  const selAngleInput       = document.getElementById('selAngleInput');
  const selSizeInput        = document.getElementById('selSizeInput');
  const selAreaNameInput    = document.getElementById('selAreaNameInput');
  const selAreaValueInput   = document.getElementById('selAreaValueInput');
  const selAreaSurfaceInput = document.getElementById('selAreaSurfaceInput');
  const selAreaJobInput     = document.getElementById('selAreaJobInput');
  const selShapeDimFields   = document.getElementById('selShapeDimFields');
  const selShapeWidthRow    = document.getElementById('selShapeWidthRow');
  const selShapeHeightRow   = document.getElementById('selShapeHeightRow');
  const selShapeDiameterRow = document.getElementById('selShapeDiameterRow');
  const selShapeWidthInput  = document.getElementById('selShapeWidthInput');
  const selShapeHeightInput = document.getElementById('selShapeHeightInput');
  const selShapeDiameterInput = document.getElementById('selShapeDiameterInput');
  const selShapeWidthUnit   = document.getElementById('selShapeWidthUnit');
  const selShapeHeightUnit  = document.getElementById('selShapeHeightUnit');
  const selShapeDiameterUnit = document.getElementById('selShapeDiameterUnit');
  const selLabelTextInput   = document.getElementById('selLabelTextInput');
  const selLabelSizeInput   = document.getElementById('selLabelSizeInput');

  // SUB-CHUNK 1.UI1 END — Core UI refs (canvas, topbar, menus, status)

  // SUB-CHUNK 1.PP1 BEGIN — Properties panel / inspector refs
  // --- sub-chunk 1.1a · Line style inspector fields (new) ------------------------------
  const selStrokeWidthInput     = document.getElementById('selStrokeWidthInput');
  const selStrokeColorInput     = document.getElementById('selStrokeColorInput');
  const selStrokeColorText      = document.getElementById('selStrokeColorText');
  const selStrokePatternSelect  = document.getElementById('selStrokePatternSelect');

  // --- sub-chunk 1.1b · Display controls (Canvas + Theme) -----------------------------
  const canvasBgPresetSelect = document.getElementById('canvasBgPresetSelect');
  const canvasBgCustomRow    = document.getElementById('canvasBgCustomRow');
  const canvasBgColorInput   = document.getElementById('canvasBgColorInput');
  const canvasBgColorText    = document.getElementById('canvasBgColorText');
  const uiThemeSelect        = document.getElementById('uiThemeSelect');
  const uiThemeCustomRow          = document.getElementById('uiThemeCustomRow');
  const uiThemeCustomColorInput   = document.getElementById('uiThemeCustomColorInput');
  const uiThemeCustomColorText    = document.getElementById('uiThemeCustomColorText');
  const uiThemeCustomModeRow      = document.getElementById('uiThemeCustomModeRow');
  const uiThemeCustomModeSelect   = document.getElementById('uiThemeCustomModeSelect');
  const uiThemeCustomStrengthRow  = document.getElementById('uiThemeCustomStrengthRow');
  const uiThemeCustomStrengthRange= document.getElementById('uiThemeCustomStrengthRange');
  const uiThemeCustomStrengthText = document.getElementById('uiThemeCustomStrengthText');
  // --- sub-chunk 1.1c · Control wells palette REMOVED (v1.6.6.6) ---

  const gridOpacityMinorInput = document.getElementById('gridOpacityMinorInput');
  const gridOpacityMinorValue = document.getElementById('gridOpacityMinorValue');
  const gridOpacityMajorInput = document.getElementById('gridOpacityMajorInput');
  const gridOpacityMajorValue = document.getElementById('gridOpacityMajorValue');
const btnFaceAColorInput   = document.getElementById('btnFaceAColorInput');
  const btnFaceAColorText    = document.getElementById('btnFaceAColorText');
  const btnFaceBColorInput   = document.getElementById('btnFaceBColorInput');
  const btnFaceBColorText    = document.getElementById('btnFaceBColorText');
  const btnBorderColorInput  = document.getElementById('btnBorderColorInput');
  const btnBorderColorText   = document.getElementById('btnBorderColorText');
  const saveDisplayPresetBtn = document.getElementById('saveDisplayPresetBtn');
  const resetFactoryBtn      = document.getElementById('resetFactoryBtn');

  const bgImageFileInput      = document.getElementById('bgImageFileInput');
  const bgImageLoadBtn        = document.getElementById('bgImageLoadBtn');
  const bgImageClearBtn       = document.getElementById('bgImageClearBtn');
  const bgImageOpacityRow     = document.getElementById('bgImageOpacityRow');
  const bgImageOpacityInput   = document.getElementById('bgImageOpacityInput');
  const bgImageOpacityValue   = document.getElementById('bgImageOpacityValue');
  const bgImageScaleRow       = document.getElementById('bgImageScaleRow');
  const bgImageMppInput       = document.getElementById('bgImageMppInput');
  const bgImageCenterBtn      = document.getElementById('bgImageCenterBtn');

  const bgImageCalRow        = document.getElementById('bgImageCalRow');
  const bgImageCalLenInput   = document.getElementById('bgImageCalLenInput');
  const bgImageCalUnit       = document.getElementById('bgImageCalUnit');
  const bgImageCalBtn        = document.getElementById('bgImageCalBtn');
  const bgImageCalCancelBtn  = document.getElementById('bgImageCalCancelBtn');


  
  // --- Line defaults (persistent) ---
  const lineDefaultWidthInput   = document.getElementById('lineDefaultWidthInput');
  const lineDefaultColorInput   = document.getElementById('lineDefaultColorInput');
  const lineDefaultColorText    = document.getElementById('lineDefaultColorText');
  const lineDefaultStyleSelect  = document.getElementById('lineDefaultStyleSelect');
  // --- Measure defaults (persistent) ---
  const measureDefaultWidthInput   = document.getElementById('measureDefaultWidthInput');
  const measureDefaultColorInput   = document.getElementById('measureDefaultColorInput');
  const measureDefaultColorText    = document.getElementById('measureDefaultColorText');
  const measureDefaultStyleSelect  = document.getElementById('measureDefaultStyleSelect');
  const measureDefaultModeSelect   = document.getElementById('measureDefaultModeSelect');
  const measureDefaultDecimalsInput= document.getElementById('measureDefaultDecimalsInput');

  // --- Area defaults (persistent) ---
  const areaDefaultColorInput   = document.getElementById('areaDefaultColorInput');
  const areaDefaultColorText    = document.getElementById('areaDefaultColorText');
  const areaDefaultOpacityRange = document.getElementById('areaDefaultOpacityRange');
  const areaDefaultOpacityPct   = document.getElementById('areaDefaultOpacityPct');
const selStrokeDashRow        = document.getElementById('selStrokeDashRow');
  const selStrokeDashInput      = document.getElementById('selStrokeDashInput');
  // --- chunk end 1.1a -------------------------------------------------------------------

  // Layers
  const layerRoadsVisible   = document.getElementById('layerRoadsVisible');
  const layerLanesVisible   = document.getElementById('layerLanesVisible');
  const layerAreasVisible   = document.getElementById('layerAreasVisible');
  const layerLabelsVisible  = document.getElementById('layerLabelsVisible');
  const layerSymbolsVisible = document.getElementById('layerSymbolsVisible');
  const layerMeasureVisible = document.getElementById('layerMeasureVisible');
  const layerRoadsLocked    = document.getElementById('layerRoadsLocked');
  const layerLanesLocked    = document.getElementById('layerLanesLocked');
  const layerAreasLocked    = document.getElementById('layerAreasLocked');
  const layerLabelsLocked   = document.getElementById('layerLabelsLocked');
  const layerSymbolsLocked  = document.getElementById('layerSymbolsLocked');
  const layerMeasureLocked  = document.getElementById('layerMeasureLocked');

  // Job link
  const draftJobIdInput     = document.getElementById('draftJobIdInput');
  const sendAreasToCostingBtn = document.getElementById('sendAreasToCostingBtn');

  // Status bar
  const statusLeft          = document.getElementById('statusLeft');
  const statusMode          = document.getElementById('statusMode');
  const statusSnap          = document.getElementById('statusSnap');
  const statusSnapMode      = document.getElementById('statusSnapMode');
  const statusUnits         = document.getElementById('statusUnits');

  // Status helper (compat): some tools call setStatus(...)
  function setStatus(msg){
    try{ if(statusLeft) statusLeft.textContent = (msg==null?'':String(msg)); }catch(_){/*noop*/}
  }

  // Status actions (Diagnostics v1)
  const statusActions       = document.getElementById('statusActions');
  const statusReportBtn     = document.getElementById('statusReportBtn');
  const statusDismissBtn    = document.getElementById('statusDismissBtn');

  // SUB-CHUNK 20.D1 BEGIN — Diagnostics v1 (Sentry + Status Presenter + Export)
  // Contract: status bar is ONE LINE only; all details export via report.txt / report.json.
  // Design: Sentry (event-driven, always-on) + Probe (user-armed; v1 scaffolding only).
  
  // === DIAGNOSTICS BUILD ID (v1.7.1 hardening) ===
  // Used in exported reports. Override externally if you want a different stamp.
  window.__CHANNEL__  = window.__CHANNEL__  || 'dev';
  window.__BUILD_ID__ = window.__BUILD_ID__ || (document.documentElement.getAttribute('data-build') || document.title || 'Field Draft');
const FO_DIAG = (function(){
    const MAX_INCIDENTS = 50;    // deduped
    const MAX_BREADCRUMBS = 30;  // bounded
    const incidentsBySig = Object.create(null); // signature -> incident
    const incidentOrder = []; // signature order (most recent last)
    const breadcrumbs = [];

    function isoNow(){ return new Date().toISOString(); }
    function safeStr(v){ try{ return (v===undefined||v===null) ? '' : String(v); }catch(_){ return ''; } }

    function hashSig(input){
      // Small, stable signature hash (non-crypto).
      let h = 2166136261;
      const s = safeStr(input);
      for (let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = (h * 16777619) >>> 0; }
      return ('00000000' + h.toString(16)).slice(-8);
    }

    function makeSignature(inc){
      const code = safeStr(inc.code);
      const tool = safeStr(inc.tool);
      const phase = safeStr(inc.phase);
      const scope = safeStr(inc.scope);
      const key = safeStr(inc.key || '');
      return code + '|' + scope + '|' + tool + '|' + phase + '|' + hashSig(key);
    }

    function pushBreadcrumb(evt, val){
      const b = { ts: isoNow(), evt: safeStr(evt), val: safeStr(val) };
      breadcrumbs.push(b);
      if (breadcrumbs.length > MAX_BREADCRUMBS) breadcrumbs.splice(0, breadcrumbs.length - MAX_BREADCRUMBS);
    }

    function raiseIncident(inc){
      const now = isoNow();
      const incident = Object.assign({}, inc);
      incident.ts = incident.ts || now;

      // Normalize fields
      incident.severity = safeStr(incident.severity || 'WARN');
      incident.code = safeStr(incident.code || 'UNKNOWN');
      incident.scope = safeStr(incident.scope || 'ui');
      incident.phase = safeStr(incident.phase || (window.state && state.phase) || 'unknown');
      incident.tool = safeStr(incident.tool || (window.state && state.tool) || 'unknown');
      incident.summary = safeStr(incident.summary || incident.code);
      incident.details = incident.details || {};
      incident.self_resolved = !!incident.self_resolved;

      const sig = incident.signature || makeSignature(incident);
      incident.signature = sig;

      let existing = incidentsBySig[sig];
      if (existing){
        existing.count = (existing.count || 1) + 1;
        existing.last_ts = now;
        existing.summary = incident.summary || existing.summary;
        existing.severity = incident.severity || existing.severity;
        existing.details = incident.details || existing.details;
      } else {
        incident.count = 1;
        incident.first_ts = now;
        incident.last_ts = now;
        incident.breadcrumbs = breadcrumbs.slice(Math.max(0, breadcrumbs.length - 10)); // bounded snapshot
        incidentsBySig[sig] = incident;
        incidentOrder.push(sig);
        if (incidentOrder.length > MAX_INCIDENTS){
          const dropSig = incidentOrder.shift();
          delete incidentsBySig[dropSig];
        }
      }

      // Hand off to status presenter (if available)
      try { if (window.FO_STATUS && typeof FO_STATUS.raiseIncident === 'function') FO_STATUS.raiseIncident(incidentsBySig[sig]); } catch(_){}
      return incidentsBySig[sig];
    }

    function listIncidents(){
      return incidentOrder.map(sig => incidentsBySig[sig]).filter(Boolean);
    }

    function buildReportObject(){
      const active = (window.FO_STATUS && FO_STATUS.getActiveIncident) ? FO_STATUS.getActiveIncident() : null;
      const rep = {
        report_id: 'rpt_' + isoNow() + '_' + hashSig(Math.random().toString(16)),
        created_ts: isoNow(),
        app: {
          name: 'Field Draft',
          build_id: (window.__BUILD_ID__ ? String(window.__BUILD_ID__) : 'unknown'),
          channel: (window.__CHANNEL__ ? String(window.__CHANNEL__) : 'unknown')
        },
        environment: {
          user_agent: (navigator && navigator.userAgent) ? navigator.userAgent : '',
          platform: (navigator && navigator.platform) ? navigator.platform : '',
          viewport: { w: window.innerWidth || 0, h: window.innerHeight || 0, dpr: window.devicePixelRatio || 1 }
        },
        runtime: {
          phase: (window.state && state.phase) ? String(state.phase) : 'unknown',
          tool: (window.state && state.tool) ? String(state.tool) : 'unknown',
          toggles: {
            snap: !!(window.state && state.snap),
            axis_lock: !!(window.state && state.axisLock),
            auto_commit: !!(window.state && state.autoCommit)
          }
        },
        status: {
          active_incident_signature: active ? String(active.signature || '') : '',
          active_incident_code: active ? String(active.code || '') : ''
        },
        incidents: listIncidents(),
        breadcrumbs: breadcrumbs.slice(),
        probe: null,
        notes: { user_note: null }
      };
      return rep;
    }

    function reportTXT(rep){
      const lines = [];
      lines.push('Field Draft Diagnostics Report');
      lines.push('Report ID: ' + safeStr(rep.report_id));
      lines.push('Created: ' + safeStr(rep.created_ts));
      lines.push('Build: ' + safeStr(rep.app && rep.app.build_id));
      lines.push('Tool: ' + safeStr(rep.runtime && rep.runtime.tool) + ' | Phase: ' + safeStr(rep.runtime && rep.runtime.phase));
      const st = rep.status || {};
      if (st.active_incident_code){
        lines.push('Active: ' + safeStr(st.active_incident_code) + ' (' + safeStr(st.active_incident_signature) + ')');
      } else {
        lines.push('Active: none');
      }
      lines.push('');
      lines.push('Incidents (deduped): ' + (rep.incidents ? rep.incidents.length : 0));
      (rep.incidents || []).slice(-10).forEach((inc)=>{
        lines.push('- ' + safeStr(inc.severity) + ' ' + safeStr(inc.code) + ' x' + safeStr(inc.count) + ' :: ' + safeStr(inc.summary));
      });
      lines.push('');
      lines.push('Breadcrumbs: ' + (rep.breadcrumbs ? rep.breadcrumbs.length : 0));
      (rep.breadcrumbs || []).slice(-10).forEach((b)=>{
        lines.push('- ' + safeStr(b.ts) + ' ' + safeStr(b.evt) + ' ' + safeStr(b.val));
      });
      return lines.join('\n');
    }

    function downloadText(filename, text){
      try{
        const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(()=>{ try{ URL.revokeObjectURL(url); }catch(_){}
          try{ a.remove(); }catch(_){} }, 250);
        return true;
      }catch(err){
        console.warn('[FO_DIAG] downloadText failed', err);
        return false;
      }
    }

    function downloadJSON(filename, obj){
      try{
        const text = JSON.stringify(obj, null, 2);
        const blob = new Blob([text], { type: 'application/json;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(()=>{ try{ URL.revokeObjectURL(url); }catch(_){}
          try{ a.remove(); }catch(_){} }, 250);
        return true;
      }catch(err){
        console.warn('[FO_DIAG] downloadJSON failed', err);
        return false;
      }
    }

    function generateAndDownloadReport(){
      const rep = buildReportObject();
      const stamp = rep.created_ts.replace(/[:.]/g,'-');
      const base = 'fielddraft_report_' + stamp;
      // Attempt JSON then TXT. If browser blocks multiple downloads, JSON still lands.
      downloadJSON(base + '.json', rep);
      downloadText(base + '.txt', reportTXT(rep));
      return rep;
    }

    function initSentry(){
      if (initSentry._inited) return;
      initSentry._inited = true;

      // global error hooks (event-driven)
      window.addEventListener('error', function(ev){
        try{
          raiseIncident({
            severity: 'ERROR',
            code: 'UNHANDLED_ERROR',
            scope: 'runtime',
            summary: 'Unhandled error',
            key: (ev && ev.message ? ev.message : '') + '|' + (ev && ev.filename ? ev.filename : ''),
            details: { message: ev && ev.message, filename: ev && ev.filename, lineno: ev && ev.lineno, colno: ev && ev.colno }
          });
        }catch(_){}
      });

      window.addEventListener('unhandledrejection', function(ev){
        try{
          const msg = (ev && ev.reason) ? (ev.reason.message || String(ev.reason)) : 'unhandled rejection';
          raiseIncident({
            severity: 'ERROR',
            code: 'UNHANDLED_REJECTION',
            scope: 'runtime',
            summary: 'Unhandled rejection',
            key: msg,
            details: { reason: msg }
          });
        }catch(_){}
      });

      // One-time startup integrity check (deferred).
      // PROTECT: avoid hot-path outerHTML scans; run once per load.
      setTimeout(function(){
        try{
          if (typeof runMarkerIntegritySentinel === 'function'){
            runMarkerIntegritySentinel({ emitIncident:true, quietOK:true, source:'startup' });
          }
        }catch(_){ }
      }, 0);
    }

    return {
      pushBreadcrumb,
      raiseIncident,
      listIncidents,
      buildReportObject,
      reportTXT,
      generateAndDownloadReport,
      initSentry
    };
  })();
  window.FO_DIAG = FO_DIAG;

  const FO_STATUS = (function(){
    let hintText = '–';
    let activeIncident = null;
    const dismissed = Object.create(null);

    function setHint(text){
      hintText = (text === undefined || text === null) ? '–' : String(text);
      render();
    }

    function raiseIncident(incident){
      if (!incident) return;
      const sig = String(incident.signature || '');
      if (sig && dismissed[sig]) return;
      activeIncident = incident;
      render();
    }

    function dismiss(signature){
      const sig = String(signature || (activeIncident && activeIncident.signature) || '');
      if (!sig) return;
      dismissed[sig] = true;
      if (activeIncident && String(activeIncident.signature) === sig) activeIncident = null;
      render();
    }

    function getActiveIncident(){ return activeIncident; }

    function render(){
      if (!statusLeft) return;

      const showIncident = !!activeIncident;
      if (showIncident){
        statusLeft.textContent = String(activeIncident.summary || activeIncident.code || 'Warning');
        if (statusReportBtn) statusReportBtn.hidden = false;
        if (statusDismissBtn) statusDismissBtn.hidden = false;
        if (statusActions) statusActions.setAttribute('aria-hidden','false');
      } else {
        statusLeft.textContent = hintText;
        if (statusReportBtn) statusReportBtn.hidden = true;
        if (statusDismissBtn) statusDismissBtn.hidden = true;
        if (statusActions) statusActions.setAttribute('aria-hidden','true');
      }
    }

    // Wire status action buttons
    try{
      if (statusReportBtn){
        statusReportBtn.addEventListener('click', function(){
          // On demand: run marker sentinel before generating report (captures current integrity state).
          try{ if (typeof runMarkerIntegritySentinel === 'function') runMarkerIntegritySentinel({ emitIncident:true, quietOK:true }); }catch(_){}
          try{ FO_DIAG.generateAndDownloadReport(); }catch(err){ console.warn('[FO_STATUS] report generation failed', err); }
        });
      }
      if (statusDismissBtn){
        statusDismissBtn.addEventListener('click', function(){
          try{ dismiss(activeIncident && activeIncident.signature); }catch(_){}
        });
      }
    }catch(_){}

    return { setHint, raiseIncident, dismiss, getActiveIncident, render };
  })();
  window.FO_STATUS = FO_STATUS;

  function setStatusHint(text){
    try{ FO_STATUS.setHint(text); }catch(_){
      // PROTECT: last-ditch fallback, must not recurse
      try{ if (statusLeft) statusLeft.textContent = String(text); }catch(__){}
    }
  }
  // SUB-CHUNK 20.D1 END — Diagnostics v1 (Sentry + Status Presenter + Export)

  // Units dropdown
  const unitsMenu           = document.getElementById('unitsMenu');
  const unitsMenuCloseBtn   = document.getElementById('unitsMenuCloseBtn');

  const statusCursor        = document.getElementById('statusCursor');
  const statusScale         = document.getElementById('statusScale');

  // Measure overlay (used for selected measurement label)
  const measureOverlay      = document.getElementById('measureOverlay');
  const measureDistance     = document.getElementById('measureDistance');
  const measureDistanceUnit = document.getElementById('measureDistanceUnit');
  const measureAngle        = document.getElementById('measureAngle');
  const measureClearBtn     = document.getElementById('measureClearBtn');

  const fmt = (v,d=2)=>Number.isFinite(v)?v.toFixed(d):'0.00';

  // --- Required DOM refs diagnostics (Package 5) -----------------------------
  // Non-fatal: logs missing hard-required IDs to help catch layout/drift issues early.
  // IMPORTANT: Do not add optional/legacy IDs here. Those must remain guarded at bind sites.
  const FO_REQUIRED_DOM = [
    ['roadCanvas', canvas],
    ['canvasContainer', container],
    ['draftNameInput', draftNameInput],
    ['saveDraftBtn', saveDraftBtn],
    ['loadDraftBtn', loadDraftBtn],
    ['exportJsonBtn', exportJsonBtn],
    ['importJsonBtn', importJsonBtn],
    ['importIntoCurrentBtn', importIntoCurrentBtn],
    ['exportPngBtn', exportPngBtn],
    ['importFileInput', importFileInput],
    ['fullViewBtn', fullViewBtn],
    ['exitFullViewBtn', exitFullViewBtn],
    ['featureSelect', featureSelect],
    ['gridPxInput', gridPxInput],
    ['metersPerGridInput', metersPerGridInput],
    ['selType', selType],
    ['toolspaceNA', toolspaceNA],
    ['autoCommitBtn', autoCommitBtn],
    ['autoCommitValue', autoCommitValue],
    ['lockAxisBtn', lockAxisBtn],
    ['rightSidebar', rightSidebar],
    ['contextToolspace', contextToolspace],
    ['undoBtn', undoBtn],
    ['redoBtn', redoBtn],
    ['deleteSelectedBtn', deleteSelectedBtn],
    ['clearAllBtn', clearAllBtn],
    ['snapStepInput', snapStepInput],
    ['statusLeft', statusLeft],
    ['statusMode', statusMode],
    ['statusSnapMode', statusSnapMode],
    ['statusUnits', statusUnits],
    ['statusCursor', statusCursor],
  ];

  (function foDiagRequiredDomRefsOnce(){
    try{
      const missing = FO_REQUIRED_DOM.filter(([id, el]) => !el).map(([id]) => id);
      if (missing.length){
        console.warn('[FO_DOM_REQUIRED_MISSING] ' + missing.join(', '));
      }
    }catch(e){
      console.warn('[FO_DOM_REQUIRED_DIAG_ERROR] ' + (e && e.message ? e.message : e));
    }
  })();

  // --- chunk end 1 ---------------------------------------------------------------

    // SUB-CHUNK 1.PP1 END — Properties panel / inspector refs

// --- State chunk 2 ------------------------------------------------------------------
// SUB-CHUNK 2.B1 BEGIN — Bend session state (safe-edit boundary)
  // --- chunk 2.1 · Core state ---------------------------------------------------------

  const state = {
        lastSymbolType: '',  // remembers last chosen symbol (empty = none chosen)
    phase: 'startup',     // 'startup','idle','tool_active','drawing','editing','saving','loading'
    editMode: 'none',      // 'none','movePoint','moveShape','addVertex','removeVertex','splitLine','cutout','groupAdd','groupRemove','groupCombine'

    // --- chunk 2.1a · Line Tool UI state (deterministic routing) ----------------------
    // UI style choice, explicitly mapped to internal tool/type.
    // solid      -> road
    // dashed     -> lane
    // centerline -> lane
    lineStyle: 'solid',

    // --- chunk 2.B1a · Bend transient session (edit modifier; no schema changes) ------
    // NOTE: Bend is an EDIT over an existing line/polyline segment.
    // - Preview lives in bend.previewPointsFull + state.currentPath overlay.
    // - Commit is gated by Auto/Finish (Auto uses state.autoCommitLine).
    bend: {
      active: false,
      pending: false,              // Auto OFF: preview exists, waiting for Finish
      featureIndex: null,          // index in state.features
      segIndex: null,              // segment start index within feature.points
      basePoints: null,            // full original points snapshot (for splice)
      startWorld: null,            // {xM,yM} at drag start (anchor point)
      grabT: 0.5,                 // 0..1 param along A->B where bulge is anchored (0.5 = midpoint)
      startGrabT: 0.5,            // capture grabT at start (for cancel/restore)
      a: null,                     // segment A {xM,yM}
      b: null,                     // segment B {xM,yM}
      n: null,                     // normal unit vector {xM,yM}
      bulgeM: 0,                   // signed offset in meters
      previewPointsFull: null      // full polyline points including curve samples
    },

// SUB-CHUNK 2.B1 END — Bend session state (safe-edit boundary)
// --- chunk end 2.1a ---------------------------------------------------------------

    // --- chunk 2.1b · Auto-commit mode flag (line-like tools) -------------------------
    // When true, Line Tool commits 2-point segments on the 2nd tap.
    autoCommitLine: false,
    // --- chunk end 2.1b ---------------------------------------------------------------
    // --- chunk end 2.1a ---------------------------------------------------------------

    // Display grid (what you SEE)
    gridPx: 30,
    metersPerGrid: 1,

    // Snap system v1 (Step 4: ON/OFF only)
    snapEnabled: false,     // Snap OFF by default (free movement, no rounding)
    snapMode: 'point',      // 'point' | 'angle' (Snap OFF = free movement)
    unitsMode: 'metric',    // placeholder for later: 'metric' | 'imperial'

    // Display (user-driven)
    canvasBg: '#020617',
    // Background image (optional; user-supplied)
    bgImageEnabled: false,
    bgImageOpacity: 0.6,   // 0..1
    bgImageMpp: null,      // meters-per-image-pixel (number)
    bgImageOriginXM: 0,    // world meters (top-left of image)
    bgImageOriginYM: 0,
    bgImageName: '',
    bgImageDataUrl: '',    // Data URL (persisted; may be large)
    _bgImageObj: null,     // HTMLImageElement (runtime only; not persisted)

    _bgCal: { active:false, p1:null, p1Img:null }, // background calibration (runtime only)

    gridOpacity: 1, // legacy (v1)
    gridOpacityMinor: 1,
    gridOpacityMajor: 1,
    btnFaceA: '#ffffff',
    btnFaceB: '#020617',
    btnBorder: '#0000ff',
    uiTheme: 'mid',
    btnAutoFaces: false,

    // Snap step (what geometry rounds to) — still tracking metersPerGrid for now
    snapStepM: 1,

    viewOriginXM: 0,
    viewOriginYM: 0,
    axisLock: false,

    features: [],          // [{id,type,points,...}]
    nextId: 1,
    currentPath: null,     // for drawing roads / lanes / areas / measure
    selectedId: null,
    selectedIds: [],
    multiSelectEnabled: false,

    // --- chunk 2.1c · Free-Capture (Step 1: isolated, debug-only) --------------------
    // Deterministic isolation gate: does nothing unless armed via console.
    // Purpose: sample points during pointer/touch move without affecting existing tools.
    freeCapture: {
      armed: false,     // legacy (Step1); unused in Step2 tool mode
      active: false,    // becomes true on pointer/touch down while tool==='freeDraw'
      points: [],
      lastXM: null,
      lastYM: null
    },
    // --- chunk end 2.1c ---------------------------------------------------------------

    history: [],
    future: [],

    layers: {
      roads: true,
      lanes: true,
      areas: true,
      labels: true,
      symbols: true,
      measure: true
    },
    layerLocks: {
      roads: false,
      lanes: false,
      areas: false,
      labels: false,
      symbols: false,
      measure: false
    }
  };

  // --- TRUTH TOOL FAMILIES (single source of truth) -----------------------------------------------
  // Draw = creates a new object/overlay the user can see on the canvas.
  // Erase is included as draw-adjacent for convenience.
  // Edit tools modify existing geometry (e.g., bend).
  const DRAW_FAMILY_TOOLS = new Set([
    'road','lane',
    'area','freeDraw',
    'rect','circle','rectLine','circleLine','findArea',
    'symbol','label','measure','quickVerify',
    'erase'
  ]);
  const EDIT_FAMILY_TOOLS = new Set([
    'bend'
  ]);
  // -----------------------------------------------------------------------------------------------

  // --- chunk 2.1.1 · Debug exposure (Dev Index / 📦 Archive report) -------------------
  // Expose state for diagnostics in the parent Debug Runway. No behavior change.
  window.state = state;

  // --- chunk 2.2 · Edit transient state ------------------------------------------------

  // For edit modes
  let movePointSelection = null;   // {featureId, ring:'outer'|'hole', holeIndex, pointIndex}
  let moveShapeDrag = null;        // {featureId, startWorld, original}
  
  // --- chunk 2.2R · Rotate transient session (edit modifier; no snap/axis rewiring) ---
  // NOTE: Rotate is an EDIT over a selected feature. Preview is non-committed until Auto/Finish.
  // Session is module-local (NOT stored in state) to avoid history/state bloat and drift.
  let rotateSession = null; // {featureId, type, base, pivot:{xM,yM}, pendingDeltaDeg, pending, lastSign}

  // --- Rotate drag (Phase 3) ---------------------------------------------------------
  // rotateDrag is transient (not in state). It arms on pointer down in rotate mode,
  // previews on move, and either commits (Auto) or stays pending for Finish.
  let rotateDrag = {
    armed:false,
    active:false,
    downXPx:0,
    downYPx:0,
    downWorld:null,
    pivotCandidate:null,
    startAngleRad:0
  }; // shared for mouse+touch (tap sets pivot; drag rotates)

  // --- ROTATE HELPERS (beauty pass A) -------------------------------------------------
  function _rotateStepDeg(){
    // Shared degrees field (Angle Step input) is used as rotate step/quantizer.
    // 0 => free rotation.
    const v = (typeof angleSnapDegInput !== 'undefined' && angleSnapDegInput)
      ? (parseFloat(angleSnapDegInput.value) || 0)
      : 0;
    return v;
  }

  function _normalizeRad(rad){
    // Normalize to [-pi, pi] to avoid jump discontinuities.
    while (rad > Math.PI) rad -= 2*Math.PI;
    while (rad < -Math.PI) rad += 2*Math.PI;
    return rad;
  }

  function _quantizeRotateDeg(deg){
    const step = _rotateStepDeg();
    if (step > 0) return Math.round(deg / step) * step;
    return deg;
  }

  function _computeRotateDeltaDeg(world, pivot, startAngleRad){
    const ang = Math.atan2(world.yM - pivot.yM, world.xM - pivot.xM);
    const deltaRad = _normalizeRad(ang - startAngleRad);
    const rawDeg = deltaRad * 180 / Math.PI;
    return _quantizeRotateDeg(rawDeg);
  }
  // --- ROTATE HELPERS END --------------------------------------------------------------

  // --- ROTATE MOVE COMMON (Cleanup Pass B) --------------------------------------------
  // Shared mouse/touch rotate move handler. Keeps rotate math in one place and reduces drift.
  // Returns true if the event was handled by rotate.
  function _rotateHandleMoveAt(xPx, yPx){
    if (!(state.tool === 'inspect' && state.editMode === 'rotate' && rotateDrag)) return false;

    // Arm -> active when movement exceeds threshold
    if (rotateDrag.armed && !rotateDrag.active) {
      const dx = xPx - rotateDrag.downXPx;
      const dy = yPx - rotateDrag.downYPx;
      const dist2 = dx*dx + dy*dy;
      const startThreshPx = 8;
      if (dist2 >= startThreshPx*startThreshPx) {
        const sel = (_getSelectedFeature && _getSelectedFeature()) ? _getSelectedFeature() : null;
        if (sel) {
          const pivot = rotateDrag.pivotCandidate || (_pivotFromTap ? _pivotFromTap(sel, rotateDrag.downWorld) : null) || null;
          // (Re)base and lock pivot for this drag
          beginRotateSessionWithPivot(pivot);
          rotateDrag.active = true;
          rotateDrag.armed = false;
          if (rotateSession && rotateSession.pivot && rotateDrag.downWorld) {
            rotateDrag.startAngleRad = Math.atan2(rotateDrag.downWorld.yM - rotateSession.pivot.yM,
                                                 rotateDrag.downWorld.xM - rotateSession.pivot.xM);
          } else {
            rotateDrag.startAngleRad = 0;
          }
        }
      }
    }

    // Preview while active
    if (rotateDrag.active && rotateSession && rotateSession.pivot) {
      const world = canvasToWorldRawMouse(xPx, yPx);
      const pivot = rotateSession.pivot;
      const deltaDeg = _computeRotateDeltaDeg(world, pivot, rotateDrag.startAngleRad);
      rotateSession.pendingDeltaDeg = deltaDeg;
      rotateSession.pending = true;
      applyRotatePreview(deltaDeg);
      return true;
    }

    return rotateDrag.armed; // armed rotate consumes the gesture
  }

let cutoutOuterId = null;        // area id to subtract from

  // Gesture state for pinch + pan
  const navGesture = {
    active: false,

    // Pinch start snapshot
    startDist: 0,
    startGridPx: 0,
    startMidWorld: null,      // {xM,yM} under the pinch midpoint at gesture start
    startViewOriginXM: 0,
    startViewOriginYM: 0,

    // Latest pinch samples (touchmove can run > refresh rate)
    latestDist: 0,
    latestMidPx: null,        // {xPx,yPx} latest pinch midpoint in canvas pixels
    pendingGridPx: null,      // number
    rafId: 0
  };

  // Mouse nav (inspect pan)
  let navDragActive = false;
  let navDragStart = { xPx:0, yPx:0, viewXM:0, viewYM:0 };
  let navLastPos = null;
// --- chunk end 2 ---------------------------------------------------------------
  // --- Helpers: coordinates, geometry chunk 3 ----------------------------------------
  // --- chunk 3.1 · Scale helpers ------------------------------------------------------

  // SCRIPT PART 1.1 END (LLM ANCHOR)
</script>

<script>

  // SCRIPT PART 1.2 BEGIN (LLM ANCHOR)

// SUB-CHUNK 4.A BEGIN — Coordinate transforms + snap core
  function getPxPerMeter(){
    // Uses DISPLAY grid spacing (metersPerGrid), not snap step
    return state.gridPx / state.metersPerGrid;
  }

  // --- chunk 3.1B · Fit-to-project (View Board) ---------------------------------------
  // View Board should reveal the entire project without the user manually zooming out.
  // We compute world bounds across all drawable features and adjust view origin + zoom.
  // NOTE: This is a deliberate view change (not layout-driven), so a redraw is expected.

  function getProjectWorldBounds(){
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    const feats = Array.isArray(state.features) ? state.features : [];
    const bump = (xM, yM) => {
      if (!isFinite(xM) || !isFinite(yM)) return;
      if (xM < minX) minX = xM;
      if (xM > maxX) maxX = xM;
      if (yM < minY) minY = yM;
      if (yM > maxY) maxY = yM;
    };

    feats.forEach(f => {
      if (!f) return;

      if (Array.isArray(f.points) && f.points.length) {
        f.points.forEach(p => bump(p.xM, p.yM));
      }

      if (f.type === 'symbol' && isFinite(f.xM) && isFinite(f.yM)) {
        const s = (f.sizeM || state.metersPerGrid) * 0.75; // conservative extent
        bump(f.xM - s, f.yM - s);
        bump(f.xM + s, f.yM + s);
      }

      if (f.type === 'label') {
        if (isFinite(f.xM) && isFinite(f.yM)) bump(f.xM, f.yM);
        if (isFinite(f.txM) && isFinite(f.tyM)) bump(f.txM, f.tyM);
      }
    });

    if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) return null;
    if (maxX - minX < 1e-6) { maxX = minX + 1; }
    if (maxY - minY < 1e-6) { maxY = minY + 1; }

    return { minX, minY, maxX, maxY };
  }

  function fitViewToProject(opts = {}){
    const b = getProjectWorldBounds();
    if (!b) return false;

    const padPx = Number.isFinite(opts.padPx) ? opts.padPx : 56;
    const cw = roadCanvas ? roadCanvas.width  : 0;
    const ch = roadCanvas ? roadCanvas.height : 0;
    if (!(cw > 0 && ch > 0)) return false;

    const wM = (b.maxX - b.minX);
    const hM = (b.maxY - b.minY);

    const ppmX = (cw - padPx * 2) / wM;
    const ppmY = (ch - padPx * 2) / hM;
    let ppmTarget = Math.min(ppmX, ppmY);

    if (!isFinite(ppmTarget) || ppmTarget <= 0) return false;
    ppmTarget = Math.max(0.05, Math.min(ppmTarget, 5000));

    const newMetersPerGrid = state.gridPx / ppmTarget;

    const viewWm = cw / ppmTarget;
    const viewHm = ch / ppmTarget;

    const cx = (b.minX + b.maxX) / 2;
    const cy = (b.minY + b.maxY) / 2;

    state.metersPerGrid = newMetersPerGrid;
    state.viewOriginXM = cx - viewWm / 2;
    state.viewOriginYM = cy - viewHm / 2;

    return true;
  }
  function worldToCanvas(pt){
    const ppm = getPxPerMeter();
    return {
      xPx: (pt.xM - state.viewOriginXM) * ppm,
      yPx: (pt.yM - state.viewOriginYM) * ppm
    };
  }

  // --- chunk 3.2 · World conversion + snapping gate ---------------------------

  function canvasToWorld(xPx,yPx){
    const ppm = getPxPerMeter();
    let xM = xPx/ppm + state.viewOriginXM;
    let yM = yPx/ppm + state.viewOriginYM;

    // Snap OFF means NO interference
    if (!state.snapEnabled) {
      state._lastSnap = { kind: 'none', xM, yM, ts: Date.now() };
      return { xM, yM };
    }

    // POINT SNAP (CAD-ish): nearest vertex/midpoint/anchor within tolerance.
    // No grid rounding, no fallback. If nothing is close enough, return raw coords.
    if (state.snapMode === 'point') {
      const tolPx = 14;                 // screen-space tolerance
      const tolM  = Math.max(tolPx / ppm, 0.01);

      // Base snap candidates: committed features
      let near = findNearestVertex(xM, yM, tolM);

      // ALSO include the active in-progress path (manual commit / live drawing).
      // This is essential for snapping the closing click back onto the first point.
      if (state.currentPath && Array.isArray(state.currentPath.points) && state.currentPath.points.length) {
        const pts = state.currentPath.points;

        // Prefer snapping to the start vertex when attempting to close a loop.
        // (Only once we have at least 3 points, i.e. a potential polygon.)
        if (pts.length >= 3 && pts[0] && typeof pts[0].xM === 'number' && typeof pts[0].yM === 'number') {
          const dx0 = xM - pts[0].xM;
          const dy0 = yM - pts[0].yM;
          const d0 = Math.hypot(dx0, dy0);
          if (d0 <= tolM) {
            near = { xM: pts[0].xM, yM: pts[0].yM, kind: 'pathStart' };
          }
        }

        // Otherwise, snap to any existing vertex in the active path (helps chaining).
        if (!near) {
          let best = null;
          let bestD = tolM;
          for (let i = 0; i < pts.length; i++) {
            const p = pts[i];
            if (!p || typeof p.xM !== 'number' || typeof p.yM !== 'number') continue;
            const d = Math.hypot(xM - p.xM, yM - p.yM);
            if (d <= bestD) {
              bestD = d;
              best = p;
            }
          }
          if (best) near = { xM: best.xM, yM: best.yM, kind: 'pathVertex' };
        }
      }

      if (near) {
        xM = near.xM;
        yM = near.yM;
        state._lastSnap = { kind: near.kind || 'point', xM, yM, tolM, ts: Date.now() };
      } else {
        state._lastSnap = { kind: 'none', xM, yM, tolM, ts: Date.now() };
      }
      return { xM, yM };
    }

    

    // GRID SNAP: explicit grid intersection snap (no point candidates, no fallback).
    if (state.snapMode === 'grid') {
      const step = (typeof state.snapStepM === 'number' && state.snapStepM > 0) ? state.snapStepM
                  : (typeof state.metersPerGrid === 'number' && state.metersPerGrid > 0) ? state.metersPerGrid
                  : 1;

      const gx = Math.round(xM / step) * step;
      const gy = Math.round(yM / step) * step;

      state._lastSnap = { kind: 'grid', stepM: step, xM: gx, yM: gy, ts: Date.now() };
      return { xM: gx, yM: gy };
    }

// Other snap modes (e.g., ANGLE) are applied downstream (applyAngleSnapFromLast()).
    // Keep canvas→world pure: no grid rounding, no interference.
    state._lastSnap = { kind: 'none', xM, yM, ts: Date.now() };
    return { xM, yM };
  }

  // Nearest-vertex snap helper (world meters)
  function findNearestVertex(xM, yM, maxDistM){
    const maxD2 = maxDistM * maxDistM;
    let best = null;
    let bestD2 = Infinity;

    function consider(pt, kind){
      if (!pt) return;
      const dx = (pt.xM - xM);
      const dy = (pt.yM - yM);
      const d2 = dx*dx + dy*dy;
      if (d2 <= maxD2 && d2 < bestD2) {
        bestD2 = d2;
        best = { xM: pt.xM, yM: pt.yM, kind: kind || 'vertex' };
      }
    }

    function considerPointArray(arr, closed){
      if (!Array.isArray(arr) || arr.length === 0) return;
      // vertices
      for (let i = 0; i < arr.length; i++) {
        const p = arr[i];
        if (p && typeof p.xM === 'number' && typeof p.yM === 'number') {
          consider(p, 'vertex');
        }
      }
      // midpoints
      const last = arr.length - 1;
      for (let i = 0; i < last; i++) {
        const a = arr[i], b = arr[i+1];
        if (a && b && typeof a.xM === 'number' && typeof a.yM === 'number' && typeof b.xM === 'number' && typeof b.yM === 'number') {
          consider({ xM: (a.xM + b.xM)/2, yM: (a.yM + b.yM)/2 }, 'midpoint');
        }
      }
      if (closed && arr.length >= 3) {
        const a = arr[last], b = arr[0];
        if (a && b) {
          consider({ xM: (a.xM + b.xM)/2, yM: (a.yM + b.yM)/2 }, 'midpoint');
        }
      }
    }

    const feats = state.features || [];
    for (let i = 0; i < feats.length; i++){
      const f = feats[i];
      if (!f) continue;

      // common: polyline/polygon points
      if (Array.isArray(f.points)) {
        const isClosed = (f.type === 'area') || (f.closed === true);
        considerPointArray(f.points, isClosed);
      }

      // holes/rings (areas)
      if (Array.isArray(f.holes)) {
        for (let h = 0; h < f.holes.length; h++){
          considerPointArray(f.holes[h], true);
        }
      }

      // anchors (labels/symbols/etc.)
      if (typeof f.xM === 'number' && typeof f.yM === 'number') {
        consider({ xM: f.xM, yM: f.yM }, 'anchor');
      }

      // Circles (shapeMeta): snap to center, and to nearest point on perimeter.
      if (f && f.shapeMeta && f.shapeMeta.kind === 'circle') {
        const cx = Number(f.shapeMeta.cxM);
        const cy = Number(f.shapeMeta.cyM);
        const r  = Number(f.shapeMeta.rM);
        if (Number.isFinite(cx) && Number.isFinite(cy)) {
          consider({ xM: cx, yM: cy }, 'center');

          if (Number.isFinite(r) && r > 0) {
            let vx = (xM - cx);
            let vy = (yM - cy);
            const mag = Math.hypot(vx, vy);
            if (mag > 1e-12) { vx /= mag; vy /= mag; } else { vx = 1; vy = 0; }
            consider({ xM: cx + vx * r, yM: cy + vy * r }, 'perimeter');
          }
        }
      }

      // legacy endpoints (defensive)
      if (typeof f.x0M === 'number' && typeof f.y0M === 'number') consider({ xM: f.x0M, yM: f.y0M }, 'endpoint');
      if (typeof f.x1M === 'number' && typeof f.y1M === 'number') consider({ xM: f.x1M, yM: f.y1M }, 'endpoint');
    }

    return best;
  }

// SUB-CHUNK 4.A END — Coordinate transforms + snap core
// SUB-CHUNK 4.B BEGIN — Geometry helpers (length/area)
  function lineLengthMeters(points){
    if(!points || points.length < 2) return 0;
    let t = 0;
    for(let i=1;i<points.length;i++){
      const a = points[i-1];
      const b = points[i];
      const dx = b.xM-a.xM;
      const dy = b.yM-a.yM;
      t += Math.hypot(dx,dy);
    }
    return t;
  }

  function polygonAreaMeters2(points){
    if(!points || points.length < 3) return 0;
    let sum = 0;
    for(let i=0;i<points.length;i++){
      const p1 = points[i];
      const p2 = points[(i+1)%points.length];
      sum += p1.xM*p2.yM - p2.xM*p1.yM;
    }
    return Math.abs(sum)/2;
  }

  function areaWithHoles(f){
    if (!f || f.type !== 'area') return 0;
    let total = polygonAreaMeters2(f.points || []);
    const holes = f.holes || [];
    holes.forEach(h=>{
      if (Array.isArray(h) && h.length >= 3) {
        const ha = polygonAreaMeters2(h);
        // Truth-guard: ignore corrupt holes that are ~as large as the outer.
        if (total > 0 && ha >= total * 0.98) return;
        total -= ha;
      }
    });
    return Math.max(0, total);
  }

  // --- sub-chunk 4.B1 · Find Area helpers (closed-loop fill from line geometry) -----
  function _isClosedLoopPts(points, tolM){
    if (!points || points.length < 3) return false;
    const a = points[0];
    const b = points[points.length-1];
    const dx = b.xM - a.xM;
    const dy = b.yM - a.yM;
    return Math.hypot(dx,dy) <= (tolM || 0.05);
  }

  function _dedupeClosingPoint(points, tolM){
    if (!points || points.length < 3) return points || [];
    const a = points[0];
    const b = points[points.length-1];
    const dx = b.xM - a.xM;
    const dy = b.yM - a.yM;
    if (Math.hypot(dx,dy) <= (tolM || 0.05)) {
      return points.slice(0, -1);
    }
    return points.slice();
  }

  function _pointInPolyMeters(xM, yM, poly){
    // Ray-casting algorithm in world meters
    if (!poly || poly.length < 3) return false;
    let inside = false;
    for (let i=0, j=poly.length-1; i<poly.length; j=i++){
      const xi = poly[i].xM, yi = poly[i].yM;
      const xj = poly[j].xM, yj = poly[j].yM;
      const intersect = ((yi>yM)!==(yj>yM)) && (xM < (xj-xi)*(yM-yi)/(yj-yi+1e-12) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  function findSmallestClosedLoopContainingPoint(xM, yM){
    // Goal:
    //  1) Fast-path: already-closed single polyline features (roads/lanes)
    //  2) Fallback: assemble closed loops from multiple line features by building a planar-ish graph and walking faces
    const tolClose = 0.08; // meters (snap tolerance-ish)
    let best = null;

    // --- 1) Fast-path: existing closed polylines -----------------------------
    for (let i=0; i<state.features.length; i++){
      const f = state.features[i];
      if (!f || !(f.type === 'road' || f.type === 'lane')) continue;
      const pts = Array.isArray(f.points) ? f.points : null;
      if (!pts || pts.length < 3) continue;
      if (!_isClosedLoopPts(pts, tolClose)) continue;

      const poly = _dedupeClosingPoint(pts, tolClose);
      if (poly.length < 3) continue;

      if (_pointInPolyMeters(xM, yM, poly)){
        const a = polygonAreaMeters2(poly);
        if (!best || a < best.areaM2){
          best = { poly, areaM2: a, sourceId: f.id };
        }
      }
    }
    if (best) return best;

    // --- 2) Fallback: multi-feature loop finding -----------------------------
    // Build a node graph from all road/lane segments (open or closed).
    const nodes = [];        // [{xM,yM}]
    const out = [];          // outgoing half-edge indices per node
    const halfEdges = [];    // [{from,to,ang}]
    const visited = [];      // bool per half-edge

    function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

    function nodeForPoint(p){
      if (!p || typeof p.xM !== 'number' || typeof p.yM !== 'number') return -1;
      // Merge points within tolClose into the same node.
      const r2 = tolClose*tolClose;
      for (let i=0; i<nodes.length; i++){
        const n = nodes[i];
        if (dist2(p.xM,p.yM,n.xM,n.yM) <= r2) return i;
      }
      nodes.push({xM:p.xM, yM:p.yM});
      out.push([]);
      return nodes.length-1;
    }

    function addUndirectedEdge(a, b){
      if (a < 0 || b < 0 || a === b) return;
      const na = nodes[a], nb = nodes[b];
      const angAB = Math.atan2(nb.yM - na.yM, nb.xM - na.xM);
      const angBA = Math.atan2(na.yM - nb.yM, na.xM - nb.xM);

      const iAB = halfEdges.length;
      halfEdges.push({from:a, to:b, ang:angAB});
      visited.push(false);
      out[a].push(iAB);

      const iBA = halfEdges.length;
      halfEdges.push({from:b, to:a, ang:angBA});
      visited.push(false);
      out[b].push(iBA);
    }

    // Collect segments
    for (let i=0; i<state.features.length; i++){
      const f = state.features[i];
      if (!f || !(f.type === 'road' || f.type === 'lane')) continue;
      const pts = Array.isArray(f.points) ? f.points : null;
      if (!pts || pts.length < 2) continue;

      for (let k=0; k<pts.length-1; k++){
        const a = nodeForPoint(pts[k]);
        const b = nodeForPoint(pts[k+1]);
        addUndirectedEdge(a,b);
      }
    }

    if (halfEdges.length < 6) return null; // need at least a triangle (6 half-edges)

    // Sort outgoing half-edges by angle at each node
    for (let i=0; i<out.length; i++){
      out[i].sort((ia, ib) => halfEdges[ia].ang - halfEdges[ib].ang);
    }

    function nextHalfEdgeIndex(heIndex){
      const he = halfEdges[heIndex];
      const v = he.to;
      const outs = out[v];
      if (!outs || outs.length === 0) return -1;

      // Incoming direction at v is from v back to u = he.from
      const nv = nodes[v], nu = nodes[he.from];
      const incomingAng = Math.atan2(nu.yM - nv.yM, nu.xM - nv.xM);

      // Find insertion point for incomingAng in sorted outgoing list, then take the previous entry (clockwise turn)
      let lo = 0, hi = outs.length;
      while (lo < hi){
        const mid = (lo + hi) >> 1;
        if (halfEdges[outs[mid]].ang < incomingAng) lo = mid + 1;
        else hi = mid;
      }
      // Clockwise means previous index
      let idx = lo - 1;
      if (idx < 0) idx = outs.length - 1;
      return outs[idx];
    }

    function polyKey(poly){
      // normalize a cycle for dedupe
      const parts = [];
      for (let i=0;i<poly.length;i++){
        const p=poly[i];
        parts.push((Math.round(p.xM*1000)/1000)+','+(Math.round(p.yM*1000)/1000));
      }
      return parts.join('|');
    }

    const seenPolys = new Set();

    for (let i=0; i<halfEdges.length; i++){
      if (visited[i]) continue;

      const start = i;
      let cur = i;
      const cycle = [];
      let guard = 0;

      while (cur !== -1 && guard++ < 5000){
        if (visited[cur]) break;
        visited[cur] = true;

        const he = halfEdges[cur];
        const p = nodes[he.from];
        cycle.push({xM:p.xM, yM:p.yM});

        cur = nextHalfEdgeIndex(cur);
        if (cur === start) break;
      }

      // Must close back to start with enough vertices
      if (cur !== start) continue;
      if (cycle.length < 3) continue;

      // Remove immediate duplicates / collinear-ish noise
      const poly = [];
      for (let k=0; k<cycle.length; k++){
        const p = cycle[k];
        const prev = poly[poly.length-1];
        if (!prev || Math.hypot(p.xM - prev.xM, p.yM - prev.yM) > 1e-6) poly.push(p);
      }
      if (poly.length < 3) continue;

      const key = polyKey(poly);
      if (seenPolys.has(key)) continue;
      seenPolys.add(key);

      // Ignore huge "outside face" loops by requiring the point to be inside
      if (!_pointInPolyMeters(xM, yM, poly)) continue;

      const a = Math.abs(polygonAreaMeters2(poly));
      if (!(a > 1e-6)) continue;

      if (!best || a < best.areaM2){
        best = { poly, areaM2: a, sourceId: 'multi' };
      }
    }

    return best;
  }

  function tryFindAreaAtWorldPoint(xM, yM){
    const hit = findSmallestClosedLoopContainingPoint(xM, yM);
    if (!hit) return false;

    try { pushHistory('addArea(find)'); } catch(_){}

    const feature = {
      id: state.nextId++,
      shapeType: null,
      shapeMeta: null,
      type: 'area',
      fillColor: (state.areaDefaults && state.areaDefaults.color) ? String(state.areaDefaults.color) : '#38bdf8',
      fillOpacity: (state.areaDefaults && typeof state.areaDefaults.opacity==='number') ? state.areaDefaults.opacity : 0.12,
      points: hit.poly.slice(),
      holes: [],
      name: '',
      areaM2: polygonAreaMeters2(hit.poly)
    };

    state.features.push(feature);
    try { selectFeatureById(feature.id); } catch(_){ state.selectedId = feature.id; }
    try { setStatusHint('Find Area: created area from closed loop (source #' + hit.sourceId + ')'); } catch(_){}

    draw();
    return true;
  }
  // --- end sub-chunk 4.B1 -----------------------------------------------------------

// SUB-CHUNK 4.B END — Geometry helpers (length/area)
// SUB-CHUNK 4.C BEGIN — State snapshot + undo/redo
  function deepClone(obj){
    return JSON.parse(JSON.stringify(obj));
  }
// --- chunk end 3 ---------------------------------------------------------------
  // --- History (undo / redo) chunk 4 -------------------------------------------------
  // --- chunk 4.1 · Snapshot -----------------------------------------------------------

  function snapshotState(){
    return {
      gridPx: state.gridPx,
      metersPerGrid: state.metersPerGrid,
      snapStepM: state.snapStepM,

      viewOriginXM: state.viewOriginXM,
      viewOriginYM: state.viewOriginYM,

      axisLock: state.axisLock,
      features: deepClone(state.features),
      nextId: state.nextId,
      selectedId: state.selectedId,
      selectedIds: Array.isArray(state.selectedIds) ? state.selectedIds.slice() : [],
      multiSelectEnabled: !!state.multiSelectEnabled
    };
  }
function pushHistory(label){
    // Session recovery: any history-worthy mutation marks the draft dirty.
    _fdDirtySinceSave = true;
    scheduleSessionRecoveryWrite(0);
    state.history.push({
      state: snapshotState(),
      label: label || ''
    });
    state.future = []; // clear redo stack
  }

// --- GROUPING HELPERS (base group + authority overlay) ---------------------------
// Base group is set via Properties (groupId). Authority overlay (groupAuthorityId) is temporary.
function _normGroupStr(v){
  if (v == null) return null;
  const s = String(v).trim();
  return s ? s : null;
}
function getBaseGroupId(f){
  return f ? _normGroupStr(f.groupId) : null;
}
function getAuthorityGroupId(f){
  return f ? _normGroupStr(f.groupAuthorityId) : null;
}
function getEffectiveGroupId(f){
  return getAuthorityGroupId(f) || getBaseGroupId(f) || null;
}
function getEffectiveGroupMembers(effectiveId){
  const gid = _normGroupStr(effectiveId);
  if (!gid) return [];
  return state.features.filter(ff => ff && getEffectiveGroupId(ff) === gid);
}
// Combine two base groups under a single authority id (overlay). Base identities remain intact.
function applyAuthorityOverlay(authorityId, baseA, baseB){
  const auth = _normGroupStr(authorityId);
  const a = _normGroupStr(baseA);
  const b = _normGroupStr(baseB);
  if (!auth || !a || !b) return 0;
  let changed = 0;
  for (const ff of state.features) {
    if (!ff) continue;
    const base = getBaseGroupId(ff);
    if (base === a || base === b) {
      ff.groupAuthorityId = auth;
      changed++;
    }
  }
  return changed;
}
function clearAuthorityOverlay(authorityId){
  const auth = _normGroupStr(authorityId);
  if (!auth) return 0;
  let changed = 0;
  for (const ff of state.features) {
    if (!ff) continue;
    if (getAuthorityGroupId(ff) === auth) {
      delete ff.groupAuthorityId;
      changed++;
    }
  }
  return changed;
}

// --- chunk 4.2 · Restore ------------------------------------------------------------

  function restoreSnapshot(snap){
    if (!snap || !snap.state) return;

    state.gridPx        = snap.state.gridPx;
    state.metersPerGrid = snap.state.metersPerGrid;

    // Backward-safe: if old snapshot lacks snapStepM, fall back to metersPerGrid
    state.snapStepM     = (snap.state.snapStepM != null) ? snap.state.snapStepM : snap.state.metersPerGrid;

    state.viewOriginXM  = snap.state.viewOriginXM;
    state.viewOriginYM  = snap.state.viewOriginYM;

    state.axisLock      = snap.state.axisLock;
    state.features      = snap.state.features;
    state.nextId        = snap.state.nextId;
    state.selectedId    = snap.state.selectedId;
    state.selectedIds  = Array.isArray(snap.state.selectedIds) ? snap.state.selectedIds.slice() : [];
    state.multiSelectEnabled = (typeof snap.state.multiSelectEnabled === 'boolean') ? snap.state.multiSelectEnabled : !!state.multiSelectEnabled;

    // Backward-safe: ensure selectedId is consistent with selectedIds
    if (state.selectedIds.length > 0) {
      if (state.selectedId == null || !state.selectedIds.includes(state.selectedId)) state.selectedId = state.selectedIds[state.selectedIds.length-1];
    } else {
      state.selectedId = state.selectedId ?? null;
    }

    gridPxInput.value   = state.gridPx;
    metersPerGridInput.value = state.metersPerGrid;

    updateStatusScale();
    updateStatusConstraints();
    try{ updateContextHighlights(); }catch(_){ }
    updateFeatureSelect();
    refreshSelectedInspector();
    draw();
  }

  function undo(){
    if (document.body.classList.contains('full-board')) return;
    if (state.history.length === 0) return;

    const current = { state: snapshotState(), label: 'current' };
    const prev = state.history.pop();

    state.future.push(current);
    restoreSnapshot(prev);
  }

  function redo(){
    if (document.body.classList.contains('full-board')) return;
    if (state.future.length === 0) return;

    // IMPORTANT: redo must NOT clear the remaining future stack.
    // So we DO NOT call pushHistory() here (it wipes state.future).
    const current = { state: snapshotState(), label: 'current' };
    const snap = state.future.pop();

    state.history.push(current);
    restoreSnapshot(snap);
  }
// --- chunk end 4 ---------------------------------------------------------------
  // --- Status helpers chunk 5 --------------------------------------------------------

  const M_TO_FT = 3.280839895;
  const FT_TO_M = 1 / M_TO_FT;
  const M_TO_IN = 39.37007874;
  const IN_TO_M = 1 / M_TO_IN;

  // Square conversions
  const M2_TO_FT2 = M_TO_FT * M_TO_FT;
  const M2_TO_IN2 = M_TO_IN * M_TO_IN;

  // Unit label nodes (topbar/context toolspace)
  const metersPerGridUnit = document.getElementById('metersPerGridUnit');
  const snapStepUnit      = document.getElementById('snapStepUnit');
  const angleSnapDistUnit = document.getElementById('angleSnapDistUnit');

  // Unit label nodes (right properties panel)
  const selLengthUnit   = document.getElementById('selLengthUnit');
  const selSizeUnit     = document.getElementById('selSizeUnit');
  const selAreaUnit     = document.getElementById('selAreaUnit');
  const selMultiAreaUnit = document.getElementById('selMultiAreaUnit');
  const selLabelSizeUnit= document.getElementById('selLabelSizeUnit');

  // --- chunk 5.0a · Line Tool naming helpers (UI only) -------------------------------
// SUB-CHUNK 4.C END — State snapshot + undo/redo
// SUB-CHUNK 4.D BEGIN — Units + formatting
  function uiLineStyleName(style){
    const s = (style || '').toLowerCase();
    if (s === 'dashed') return 'Dashed';
    if (s === 'centerline') return 'Centerline';
    return 'Solid';
  }
  // --- chunk end 5.0a ---------------------------------------------------------------

  // Units modes:
  // - 'metric'  => meters (m)
  // - 'cm'      => centimeters
  // - 'mm'      => millimeters
  // - 'imperial'=> feet (ft)
  // - 'in'      => inches
  function unitFactorFromMeters(){
    const m = String(state.unitsMode || 'metric').toLowerCase();
    if (m === 'cm') return 100;
    if (m === 'mm') return 1000;
    if (m === 'in') return M_TO_IN;
    if (m === 'imperial') return M_TO_FT;
    return 1; // metric meters
  }

  function unitLabelDist(){
    const m = String(state.unitsMode || 'metric').toLowerCase();
    if (m === 'cm') return 'cm';
    if (m === 'mm') return 'mm';
    if (m === 'in') return 'in';
    if (m === 'imperial') return 'ft';
    return 'm';
  }

  function unitLabelArea(){
    const d = unitLabelDist();
    if (d === 'm')  return 'm²';
    if (d === 'cm') return 'cm²';
    if (d === 'mm') return 'mm²';
    if (d === 'ft') return 'ft²';
    if (d === 'in') return 'in²';
    return 'm²';
  }

  function fmtNum(v,d=2){
    return Number.isFinite(v) ? v.toFixed(d) : '0.00';
  }

  // Display helpers: convert meters -> current units
  function distDisplayValue(m){
    if (!Number.isFinite(m)) m = 0;
    return m * unitFactorFromMeters();
  }

  function areaDisplayValue(m2){
    if (!Number.isFinite(m2)) m2 = 0;
    const f = unitFactorFromMeters();
    return m2 * (f * f);
  }

  // Parse user-entered distance in current units -> meters (internal)
  function inputDistToMetersAny(v){
    const n = parseFloat(v);
    if(!Number.isFinite(n) || n <= 0) return null;
    const f = unitFactorFromMeters();
    return (f ? (n / f) : n);
  }
  function fmtCoordMeters(xM,yM){
    if (!Number.isFinite(xM)) xM = 0;
    if (!Number.isFinite(yM)) yM = 0;

    const f = unitFactorFromMeters();
    const u = unitLabelDist();
    return `${fmtNum(xM * f,2)}, ${fmtNum(yM * f,2)} ${u}`;
  }

  // Ring-1 + Ring-2: update all *unit labels* in UI
// SUB-CHUNK 4.D END — Units + formatting
// SUB-CHUNK 4.E BEGIN — Status + toolspace + highlight refresh
  function applyUnitLabels(){
    const uDist = unitLabelDist();
    const uArea = unitLabelArea();

    // Topbar/context
    if (metersPerGridUnit) metersPerGridUnit.textContent = `${uDist} / grid`;
    if (snapStepUnit)      snapStepUnit.textContent = uDist;
    if (angleSnapDistUnit) angleSnapDistUnit.textContent = uDist;

    // Right panel
    if (selLengthUnit)    selLengthUnit.textContent = uDist;
    if (selSizeUnit)      selSizeUnit.textContent = uDist;
    if (selAreaUnit)      selAreaUnit.textContent = uArea;
    if (selMultiAreaUnit) selMultiAreaUnit.textContent = uArea;
    if (selLabelSizeUnit) selLabelSizeUnit.textContent = uDist;

    // Background image calibration row
    if (bgImageCalUnit) bgImageCalUnit.textContent = uDist;
  }

  // --- PROPOSAL PATCH: constraints strip (status bar) -------------------------------
  function updateStatusConstraints(){
    // Status bar contract: no config echo. Safe no-op if legacy node absent.
    if (typeof statusConstraints === 'undefined' || !statusConstraints) return;
    const parts = [];
    // Snap summary
    if (!state.snapEnabled) {
      parts.push('Snap: OFF');
    } else {
      const mode = (state.snapMode === 'angle') ? 'Angle' : (state.snapMode === 'grid') ? 'Grid' : 'Point';
      parts.push(`Snap: ON · ${mode}`);
    }

    // Grid step (display units)
    const gridM = (state.metersPerGrid || 1);
    parts.push(`Grid: ${fmtNum(distDisplayValue(gridM),2)} ${unitLabelDist()}`);

    // XY lock
    parts.push(`XY lock: ${state.axisLock ? 'ON' : 'OFF'}`);

    // Auto-commit (line tools)
    parts.push(`Auto: ${state.autoCommitLine ? 'ON' : 'OFF'}`);

    // Angle step when relevant
    if (state.snapEnabled && state.snapMode === 'angle') {
      const deg = parseFloat(angleSnapDegInput ? angleSnapDegInput.value : '');
      if (Number.isFinite(deg) && deg > 0) parts.push(`Δ: ${fmtNum(deg,0)}°`);
    }

    statusConstraints.textContent = parts.join(' | ');
  }
  // --- PROPOSAL PATCH END ----------------------------------------------------------

  function updateStatusScale(){
    // Status bar contract: no scale/grid echo. Keep function as a safe no-op.
    // (Still used by a few call-sites; MUST NOT throw if legacy DOM nodes are missing.)
    if (typeof statusScale !== 'undefined' && statusScale) {
      const valM = state.metersPerGrid;
      const uDist = unitLabelDist();
      statusScale.textContent = fmtNum(distDisplayValue(valM),2) + ` ${uDist} / grid`;
    }
    // Do not call updateStatusConstraints() here.
  }

  function updateStatusSnap(){
    const v = state.snapEnabled ? 'ON' : 'OFF';
    if (statusSnap) statusSnap.textContent = v;

    // Topbar context toggle (if present)
    const btn = document.getElementById('snapToggleBtn');
    const val = document.getElementById('snapToggleValue');
    if (val) val.textContent = v;
    if (btn) {
      btn.classList.toggle('active', !!state.snapEnabled);
      btn.setAttribute('aria-pressed', state.snapEnabled ? 'true' : 'false');
    }
    updateStatusConstraints();
  }

  function updateStatusSnapMode(){
    // Snap is an explicit selector: Point | Angle | Grid
    // (Snap OFF already represents free movement.)
    const raw = String(state.snapMode || '').toLowerCase();
    const m = (raw === 'angle' || raw === 'grid') ? raw : 'point';
    state.snapMode = m;

    const label = (m === 'angle') ? 'Angle' : (m === 'grid') ? 'Grid' : 'Point';
    if (statusSnapMode) statusSnapMode.textContent = label;
    try{ updateContextHighlights(); }catch(_){ }
  }

function updateStatusUnits(){
    // Display symbol only (space-tight)
    statusUnits.textContent = unitLabelDist();
    applyUnitLabels();
    try{ updateContextHighlights(); }catch(_){ }
    // Status bar contract: no grid/scale echo here.
    // updateStatusScale();
  }
// --- chunk 5.3 · Context Toolspace swap (Step 7) ------------------------------------

  function updateToolspace(){
    // Context rows stay visible at all times (no UI jitter).
    // We enable/disable Angle inputs based on snapMode.
    if (toolspaceNA) toolspaceNA.style.display = ''; // hosts #statusMode

    const isAngle = (state.snapMode === 'angle') || (state.editMode === 'rotate');

    if (toolspaceAngle) {
      toolspaceAngle.style.display = ''; // always visible
      toolspaceAngle.style.opacity = isAngle ? '1' : '0.55';
    }

    if (angleSnapDegInput)  angleSnapDegInput.disabled  = !isAngle;
    if (angleSnapDistInput) angleSnapDistInput.disabled = !isAngle;

    // Auto-commit button label is action-based:
    // - In Rotate edit-mode, the button becomes APPLY (one-shot typed rotate without dragging).
    // - If Bend has a pending preview (manual mode), tapping the button will FINISH (commit) that bend.
    // - Else, if a path is finishable right now, tapping the button will FINISH (commit) that path.
    // - Otherwise, tapping will toggle Auto mode (ON/OFF).
    const rotateApplyMode = !!(state && state.editMode === 'rotate' && state.tool === 'inspect');
    const rotateFinishReady = !!(rotateApplyMode && state && state.selectedId != null && (angleSnapDegInput ? (parseFloat(angleSnapDegInput.value) || 0) : 0) !== 0);
    const bendFinishReady = !!(state && state.tool === 'bend' && state.bend && state.bend.pending && state.bend.previewPointsFull && state.bend.featureIndex != null);
    const pathFinishReady = (!rotateApplyMode && !bendFinishReady && typeof canCommitCurrentPath === 'function' && canCommitCurrentPath());

    const autoTapLabel = rotateApplyMode
      ? 'APPLY'
      : (bendFinishReady
      ? 'FINISH'
      : (pathFinishReady ? 'FINISH' : (state.autoCommitLine ? 'ON' : 'OFF')));

    if (autoCommitBtn) {
      // Visual state:
      // - Highlight when Auto is ON
      // - ALSO highlight when FINISH is available (truthful affordance)
      autoCommitBtn.classList.toggle('active', !!state.autoCommitLine || rotateFinishReady || bendFinishReady || pathFinishReady);
    }
    if (autoCommitValue) {
      autoCommitValue.textContent = autoTapLabel;
    }

    // Contextual hint-highlights (relevance) must be applied AFTER truth highlights are set.
    try{ updateContextHighlights(); }catch(_){ }
  }

  // --- chunk 16.X · Contextual hint-highlights (relevance) -------------------------------
  // Two highlight lanes:
  // 1) .active = truth (selected tool OR ON state OR FINISH available)
  // 2) .hint   = relevance (usable in the current mode; may be OFF)
  function updateContextHighlights(){
    // Tool relevance
    const t = state && state.tool ? state.tool : 'inspect';
    const e = state && state.editMode ? state.editMode : 'none';

    const isDrawTool = (t==='road' || t==='lane' || t==='area' || t==='freeDraw' || t==='rect' || t==='circle' || t==='rectLine' || t==='circleLine' || t==='bend');
    const isEditSnap = (e==='movePoint' || e==='moveShape' || e==='addVertex' || e==='removeVertex');

    // Bend can present as a tool or as an active/pending session depending on how it's armed.
    const bendArmed = !!(
      t==='bend' ||
      (state && state.bend && (state.bend.active || state.bend.pending || state.bend.inProgress))
    );

    // Relevance rules ("hint")
    // - Snap: relevant anywhere it can assist placement/dragging, including edit modes.
    // - Auto: only meaningful for tools that have an uncommitted/finishable state.
    // - XY lock + Units: only for measurement-producing draw tools (and measure), NOT while editing a shape.
    const snapRelevant  = (isDrawTool || t==='measure' || bendArmed || t==='symbol' || t==='label' || isEditSnap);
    // Measure is a measurement-producing draw tool: Auto (ON/FINISH) and XY lock must remain truthful/relevant there.
    const autoRelevant  = (isDrawTool || bendArmed || t==='measure');
    const axisRelevant  = (!bendArmed && ((t==='road' || t==='lane' || t==='area' || t==='measure') || (e==='moveShape')));
    const unitsRelevant = (e==='none' && (t==='road' || t==='lane' || t==='area' || t==='measure')); // Bend intentionally excluded for now

    const setHint = (el,on)=>{ if(!el) return; el.classList.toggle('hint', !!on); };
    const clearHL = (el)=>{ if(!el) return; el.classList.remove('hint'); el.classList.remove('active'); };

    // Snap ON/OFF button
    if (snapToggleBtn){
      if (!snapRelevant) {
        clearHL(snapToggleBtn);
      } else {
        snapToggleBtn.classList.toggle('active', !!state.snapEnabled);
        setHint(snapToggleBtn, !state.snapEnabled);
      }
    }

    // Snap-mode dropdown summary hint
    const snapSummary = snapModeMenu ? snapModeMenu.querySelector('summary.btn') : null;
    if (snapSummary){
      setHint(snapSummary, snapRelevant);
    }

    // Auto/Finish button:
    // updateToolspace() already sets .active when Auto is ON OR FINISH is available.
    if (autoCommitBtn){
      if (!autoRelevant) {
        clearHL(autoCommitBtn);
      } else {
        // If it's not currently truth-highlighted, show a hint (relevant setting).
        setHint(autoCommitBtn, !autoCommitBtn.classList.contains('active'));
      }
    }

    // XY lock toggle
    if (lockAxisBtn){
      // Truth-first: show ON/OFF state everywhere. Use .hint only when the control is context-relevant.
      lockAxisBtn.classList.toggle('active', !!state.axisLock);
      if (axisRelevant){
        setHint(lockAxisBtn, !state.axisLock);
      } else {
        lockAxisBtn.classList.remove('hint');
      }
    }

    // Units dropdown summary hint (never truth-highlighted)
    const unitsSummary = unitsMenu ? unitsMenu.querySelector('summary.btn') : null;
    if (unitsSummary){
      setHint(unitsSummary, unitsRelevant);
    }
  }
  // --- chunk end 16.X -------------------------------------------------------------------

  // --- chunk 5.2x · Armed config highlight (Line/Symbol/Label dropdown cue) ------------
  // Purpose:
  // - When a Draw-capable tool is armed, visually highlight the related configuration dropdown.
  // - This is an availability signal only (no behavior change).
  function updateArmedConfigUI(){
    try{
      const lineArmed = (state.tool === 'road' || state.tool === 'lane');
      const symArmed  = (state.tool === 'symbol');
      const labArmed  = (state.tool === 'label');      if (symbolSelect)    symbolSelect.classList.toggle('armed-config', !!symArmed);
      if (labelKindSelect) labelKindSelect.classList.toggle('armed-config', !!labArmed);
    }catch(_){}
  }
  // --- end chunk 5.2x -----------------------------------------------------------------

  function setModeLabel(){
    // Right info panel (Context rail) is the narrator: always show the armed tool,
    // and for tools with a variant selection, show the selected variant too.
    let m = (state.editMode && state.editMode !== 'none') ? 'Edit' : 'Inspect';
    // Truth: Bend is a first-class tool. If Bend is armed OR a bend session is active/pending, narrate Bend.
    if (state.tool === 'bend' || (state.bend && (state.bend.active || state.bend.pending))) {
      m = 'Bend';
    }

    else if (state.tool === 'quickVerify') {
      m = 'Quick Verify';
    }

    else if (state.tool === 'measure') {
      m = 'Measure';
    } else if (state.tool === 'road' || state.tool === 'lane') {
      m = 'Line Tool · ' + uiLineStyleName(state.lineStyle);
    } else if (state.tool === 'area') {
      m = 'Area';
    } else if (state.tool === 'symbol') {
      // Surface selected symbol name (option text) when available
      let symName = '';
      try{
        const opt = symbolSelect && symbolSelect.selectedOptions ? symbolSelect.selectedOptions[0] : null;
        symName = opt ? (opt.textContent || '').trim() : '';
      }catch(_){}
      m = symName ? ('Symbol · ' + symName) : 'Symbol';
    } else if (state.tool === 'label') {
      // Surface selected label kind name (option text) when available
      let labName = '';
      try{
        const opt = labelKindSelect && labelKindSelect.selectedOptions ? labelKindSelect.selectedOptions[0] : null;
        labName = opt ? (opt.textContent || '').trim() : '';
      }catch(_){}
      m = labName ? ('Label · ' + labName) : 'Label';
    } else if (state.tool === 'erase') {
      m = 'Erase';
    } else if (state.tool === 'freeDraw') {
      m = 'Sketch';
    } else if (state.tool === 'rect') {
      m = 'Rectangle';
    } else if (state.tool === 'circle') {
      m = 'Circle';
    } else if (state.tool === 'rectLine') {
      m = 'Rectangle (Lines)';
    } else if (state.tool === 'circleLine') {
      m = 'Circle (Lines)';
    } else if (state.tool === 'findArea') {
      m = 'Find Area';
    }

    // Edit-mode suffixes (truth-only; no side-effects)
    if (state.editMode === 'movePoint') m += ' · Move point';
    else if (state.editMode === 'moveShape') m += ' · Move shape';
    else if (state.editMode === 'rotate') m += ' · Rotate';
    else if (state.editMode === 'addVertex') m += ' · Add vertex';
    else if (state.editMode === 'removeVertex') m += ' · Remove vertex';
    else if (state.editMode === 'cutout') m += ' · Cut-out';

    // Draw dropdown label = armed tool ONLY (no subtype leakage)
if (drawToolLabel) {
      let d = '—';
      if (state.tool === 'road' || state.tool === 'lane') d = 'Line';
      else if (state.tool === 'area') d = 'Area';
      else if (state.tool === 'measure') d = 'Measure';
      else if (state.tool === 'label') d = 'Label';
      else if (state.tool === 'symbol') d = 'Symbol';
      else if (state.tool === 'erase') d = 'Erase';
      else if (state.tool === 'freeDraw') d = 'Free';
      else if (state.tool === 'bend') d = 'Bend';
      else if (state.tool === 'rect') d = 'Rect';
      else if (state.tool === 'circle') d = 'Circle';
      else if (state.tool === 'findArea') d = 'Find Area';
      drawToolLabel.textContent = d;
    }

    // Availability cue: highlight the related config dropdown
    if (typeof updateArmedConfigUI === 'function') updateArmedConfigUI();

    // Multi-select truth cue (non-invasive)
    const __selN = (Array.isArray(state.selectedIds) && state.selectedIds.length) ? state.selectedIds.length : (state.selectedId!=null ? 1 : 0);
    if (state.multiSelectEnabled){
      statusMode.textContent = __selN ? (m + ' · Multi ' + __selN) : (m + ' · Multi');
    } else {
      statusMode.textContent = m;
    }

    updateStatusSnap();
    updateStatusSnapMode();
    updateStatusUnits();
    updateToolspace();
  }

  // --- chunk 5.5x · Variant change reflects in right info panel (no behavior change) ---
  // When a variant dropdown changes while its tool is armed, refresh the narrator.
  try{
    if (symbolSelect){
      symbolSelect.addEventListener('change', ()=>{
        const v = String(symbolSelect.value||'');
        if (v) state.lastSymbolType = v;
        if (state.tool === 'symbol') setModeLabel();
      });
    }
    if (labelKindSelect){
      labelKindSelect.addEventListener('change', ()=>{
        if (state.tool === 'label') setModeLabel();
      });
    }
  }catch(_){}
  // --- end chunk 5.5x -----------------------------------------------------------------

// --- chunk end 5 ---------------------------------------------------------------
  // --- Resize & grid chunk 6 ---------------------------------------------------------
  // --- chunk 6.1 · Canvas resize ----------------------------------------------------

// SUB-CHUNK 4.E END — Status + toolspace + highlight refresh
// SUB-CHUNK 4.F BEGIN — Canvas resize + grid draw
  function resizeCanvas() {
    // Never trust window.innerHeight/100vh for the drawing surface.
    const r = container.getBoundingClientRect();
    let w = (r && r.width)  ? Math.floor(r.width)  : 0;
    let h = (r && r.height) ? Math.floor(r.height) : 0;

    // Fallbacks (should rarely be needed once layout is flex-filled)
    if (!w) w = Math.floor(container.clientWidth  || 1);
    if (!h) h = Math.floor(container.clientHeight || 1);

    // Hard floor: never allow a zero-sized canvas
    if (!w) w = 1;
    if (!h) h = 1;

    // Skip redundant resizes (prevents draw storms in Runway)
    if (resizeCanvas.__w === w && resizeCanvas.__h === h) return;
    resizeCanvas.__w = w;
    resizeCanvas.__h = h;

    canvas.width  = w;
    canvas.height = h;

    draw();
  }

  let __resizeRAF = 0;
  function requestResizeCanvas(){
    if (__resizeRAF) return;
    __resizeRAF = requestAnimationFrame(() => {
      __resizeRAF = 0;
      resizeCanvas();
    });
  }

  // --- chunk 6.1x · Draw scheduler (compat + jitter guard) ------------------------------
  // Many subsystems call requestDraw() expecting a single RAF-throttled render.
  // Keep this as the ONE stable entry point for redraw requests.
  let __drawRAF = 0;
  function requestDraw(){
    if (__drawRAF) return;
    __drawRAF = requestAnimationFrame(() => {
      __drawRAF = 0;
      try { draw(); } catch(e){ console.error(e); }
    });
  }
  // --- end chunk 6.1x ------------------------------------------------------------------

  // Window resize (rotation / address bar / iframe changes)
  window.addEventListener('resize', requestResizeCanvas, { passive: true });

  // Container resize (Runway iframe height changes / flex recalcs)
  if (window.ResizeObserver) {
    try{
      const ro = new ResizeObserver(() => requestResizeCanvas());
      ro.observe(container);
}catch(_){}
  }

  // --- chunk 6.2 · Grid drawing ------------------------------------------------------

  function drawGrid() {
    const w = canvas.width;
    const h = canvas.height;
    if (!w || !h) return;

    // Minor grid step in METERS (internal truth)
    const stepM = state.metersPerGrid;
    const ppm   = getPxPerMeter();

    // Major grid is every 5 "units" (5 m in metric, 5 ft in imperial),
    // expressed in meters so it always lands on the same lattice as the minor grid.
    const majorEvery = 5;

    // If stepM is invalid, bail safely
    if (!Number.isFinite(stepM) || stepM <= 0) return;

    const startXM = Math.floor(state.viewOriginXM / stepM) * stepM - stepM;
    const endXM   = state.viewOriginXM + w / ppm + stepM;
    const startYM = Math.floor(state.viewOriginYM / stepM) * stepM - stepM;
    const endYM   = state.viewOriginYM + h / ppm + stepM;

    const isFullBoard = document.body.classList.contains('full-board');

    ctx.save();
    ctx.clearRect(0, 0, w, h);

    // Background (user-selectable)
    const bg = (state && state.canvasBg) ? String(state.canvasBg) : '#020617';
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, w, h);

    // Background image (optional; drawn in world space so it pans/zooms with the grid)
    if (state && state.bgImageEnabled && state._bgImageObj && state.bgImageMpp && state.bgImageMpp > 0) {
      try{
        const img = state._bgImageObj;
        const mppImg = Number(state.bgImageMpp);
        const xM0 = Number(state.bgImageOriginXM) || 0;
        const yM0 = Number(state.bgImageOriginYM) || 0;

        const xPx = (xM0 - state.viewOriginXM) * ppm;
        const yPx = (yM0 - state.viewOriginYM) * ppm;
        const wPx = img.width  * mppImg * ppm;
        const hPx = img.height * mppImg * ppm;

        const a = (typeof state.bgImageOpacity === 'number' && isFinite(state.bgImageOpacity)) ? clamp(state.bgImageOpacity, 0, 1) : 0.6;
        ctx.save();
        ctx.globalAlpha = a;
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(img, xPx, yPx, wPx, hPx);
        ctx.restore();
      }catch(_){}
    }

    // Grid colors
    const baseGridColor  = isFullBoard ? '#1f2937' : '#111827';
    const majorGridColor = isFullBoard ? '#374151' : '#1f2937';

    ctx.lineWidth = 1;

    // Grid visibility (0..1) — user control (minor + major)
    const legacyAlpha = (typeof state.gridOpacity === 'number' && isFinite(state.gridOpacity)) ? clamp(state.gridOpacity, 0, 1) : 1;
    const minorAlpha  = (typeof state.gridOpacityMinor === 'number' && isFinite(state.gridOpacityMinor)) ? clamp(state.gridOpacityMinor, 0, 1) : legacyAlpha;
    const majorAlpha  = (typeof state.gridOpacityMajor === 'number' && isFinite(state.gridOpacityMajor)) ? clamp(state.gridOpacityMajor, 0, 1) : legacyAlpha;
    ctx.globalAlpha = 1;

    // Vertical grid lines
    let idx = 0;
    for (let xM = startXM; xM <= endXM; xM += stepM, idx++) {
      const xPx = (xM - state.viewOriginXM) * ppm;
      const k = Math.round(xM / stepM);
      const isMajor = (k % majorEvery === 0); // anchor majors to world lattice
      ctx.globalAlpha = isMajor ? majorAlpha : minorAlpha;
      ctx.lineWidth = isMajor ? 1.5 : 1;
      ctx.strokeStyle = isMajor ? majorGridColor : baseGridColor;

      const x = Math.round(xPx) + 0.5;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
      ctx.stroke();
    }

    // Horizontal grid lines
    idx = 0;
    for (let yM = startYM; yM <= endYM; yM += stepM, idx++) {
      const yPx = (yM - state.viewOriginYM) * ppm;
      const k = Math.round(yM / stepM);
      const isMajor = (k % majorEvery === 0); // anchor majors to world lattice
      ctx.globalAlpha = isMajor ? majorAlpha : minorAlpha;
      ctx.lineWidth = isMajor ? 1.5 : 1;
      ctx.strokeStyle = isMajor ? majorGridColor : baseGridColor;

      const y = Math.round(yPx) + 0.5;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }

    ctx.restore();
  }
 // --- chunk end 6 ---------------------------------------------------------------
  // --- chunk 7.1 · Lines & areas -----------------------------------------------------------
  // sub-chunk 7.1A · Legacy renderers (kept for reference only) ----------------------------
  // IMPORTANT:
  // - Canonical renderers are defined later in the file (inside chunk 17).
  // - Historically, these earlier definitions were silently overridden.
  // - To remove ambiguity (and prevent “why didn’t my change apply?” failures),
  //   we rename these early duplicates so ONLY ONE active drawLineFeature/drawAreaFeature exists.
  // - No visual / behavior change intended.

// SUB-CHUNK 4.F END — Canvas resize + grid draw
// SUB-CHUNK 4.G BEGIN — Feature draw primitives (symbols/labels/measure/path)
  function drawLineFeature__legacy_UNUSED(f) {
    const pts = f.points || [];
    if (pts.length < 2) return;

    ctx.save();

    const isRoad = f.type === 'road';
    const isLane = f.type === 'lane';

    if (isRoad) {
      if (!state.layers.roads) { ctx.restore(); return; }
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 6;
    } else if (isLane) {
      if (!state.layers.lanes) { ctx.restore(); return; }
      ctx.strokeStyle = '#facc15';
      ctx.lineWidth = 2;
      // Match active line style (dashed vs centerline vs custom)
      try{
        const s = String(state.lineStyle || 'dashed').toLowerCase();
        if (s === 'centerline') ctx.setLineDash([18, 6, 3, 6]);
        else if (s === 'custom'){
          const d = (state && state.lineDefaults) ? state.lineDefaults : null;
          const parsed = (typeof parseDashList === 'function') ? parseDashList(d && d.customDash) : null;
          ctx.setLineDash((parsed && parsed.length >= 2) ? parsed : [10, 8]);
        } else {
          ctx.setLineDash([10, 8]);
        }
      }catch(_){ ctx.setLineDash([10, 8]); }
    } else {
      ctx.restore();
      return;
    }

    ctx.lineCap = 'round';

    // Tracer preview: mirror line defaults so free draw is visible BEFORE pen-up.
    try{
      const d = (state && state.lineDefaults) ? state.lineDefaults : null;
      let col = (d && typeof d.color==='string' && d.color) ? d.color : '#e5e7eb';
      ctx.strokeStyle = col;
      ctx.globalAlpha = 0.75; // tracer intensity
      const style = String((d && d.style) ? d.style : 'auto');
      if (style === 'dashed') ctx.setLineDash([10,8]);
      else if (style === 'centerline') ctx.setLineDash([18,6,3,6]);
      else ctx.setLineDash([]);
    }catch(_){
      ctx.globalAlpha = 0.75;
      ctx.strokeStyle = '#e5e7eb';
      try{ ctx.setLineDash([]); }catch(e){}
    }

    ctx.lineJoin = 'round';

    const first = worldToCanvas(pts[0]);
    ctx.beginPath();
    ctx.moveTo(first.xPx, first.yPx);
    for (let i = 1; i < pts.length; i++) {
      const p = worldToCanvas(pts[i]);
      ctx.lineTo(p.xPx, p.yPx);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    if (isSelectedId(f.id)) {
      ctx.strokeStyle = '#22c55e';
      ctx.lineWidth = isRoad ? 2 : 1.5;
      ctx.beginPath();
      ctx.moveTo(first.xPx, first.yPx);
      for (let i = 1; i < pts.length; i++) {
        const p = worldToCanvas(pts[i]);
        ctx.lineTo(p.xPx, p.yPx);
      }
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawAreaFeature__legacy_UNUSED(f){
    // Legacy alias: preserve name, prevent drift.
    return drawAreaFeature(f);
  }

  // sub-chunk 7.1B · End legacy renderer stabilization -----------------------------------

  // --- chunk 7.2 · Symbols ---------------------------------------------------------------

  function drawSymbolFeature(f){
    if (!state.layers.symbols) return;
    if (!f || f.type !== 'symbol') return;

    const ppm      = getPxPerMeter();
    const sizeM    = f.sizeM || state.metersPerGrid;      // nominal symbol size in meters
    const sizePx   = sizeM * ppm;
    const angleRad = (f.angleDeg || 0) * Math.PI / 180;
    const posPx    = worldToCanvas({ xM: f.xM, yM: f.yM });

    const t = f.symbolType || 'arrow';

    ctx.save();
    ctx.translate(posPx.xPx, posPx.yPx);
    ctx.rotate(angleRad);

// User preset symbols: draw from library template (still ONE symbol feature)
if (typeof t === 'string' && t.startsWith('user:')) {
  const userId = t.slice(5);
  try{ _drawUserPresetSymbol(userId, f, ppm, sizeM); }catch(_){}

  // Keep selection indicator consistent with built-in symbols
  if (isSelectedId(f.id)) {
    ctx.save();
    ctx.strokeStyle = '#22c55e';
    ctx.lineWidth   = 1.5;
    ctx.beginPath();
    ctx.arc(0, 0, sizePx * 1.3, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }

  ctx.restore();
  return;
}

    // Blueprint / drafting look
    const strokeColor = '#e5e7eb';
    ctx.strokeStyle   = strokeColor;
    ctx.fillStyle     = strokeColor;
    ctx.lineWidth     = Math.max(sizePx * 0.08, 1.5); // scale-aware stroke
    ctx.lineCap       = 'round';
    ctx.lineJoin      = 'round';

    // Helpers
    function drawArrowStraight(baseLen, headLen, headWidth){
      // Lane-style arrow, pointing +X by default
      const shaft = baseLen - headLen;
      ctx.beginPath();
      ctx.moveTo(-shaft / 2, 0);
      ctx.lineTo( shaft / 2, 0);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo( shaft / 2, 0);
      ctx.lineTo( shaft / 2 - headLen, -headWidth);
      ctx.moveTo( shaft / 2, 0);
      ctx.lineTo( shaft / 2 - headLen,  headWidth);
      ctx.stroke();
    }

    function drawOctagon(radius){
      ctx.beginPath();
      for (let i = 0; i < 8; i++) {
        const a = (Math.PI / 4) * i + Math.PI / 8;
        const x = radius * Math.cos(a);
        const y = radius * Math.sin(a);
        if (i === 0) ctx.moveTo(x, y);
        else         ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.stroke();
    }

    function drawTriangle(width, height){
      ctx.beginPath();
      ctx.moveTo(0, -height / 2);
      ctx.lineTo(-width / 2,  height / 2);
      ctx.lineTo( width / 2,  height / 2);
      ctx.closePath();
      ctx.stroke();
    }

    // --- SYMBOLS --------------------------------------------------------------

    if (t === 'arrow' || t === 'arrow-left' || t === 'arrow-right' || t === 'arrow-u') {
      // Lane/turn arrows, MUTCD-ish proportions
      const baseLen   = sizePx * 2.4;
      const headLen   = sizePx * 0.9;
      const headWidth = sizePx * 0.7;

      if (t === 'arrow-left') {
        // single-direction LEFT arrow
        ctx.save();
        ctx.rotate(Math.PI);
        drawArrowStraight(baseLen, headLen, headWidth);
        ctx.restore();
      } else {
        // 'arrow' and 'arrow-right' render as straight/right
        drawArrowStraight(baseLen, headLen, headWidth);
      }

      

    } else if (t === 'stopbar') {
      // Stop bar across lane
      const lengthPx = sizePx * 3.0;
      const thickPx  = Math.max(sizePx * 0.35, ctx.lineWidth * 1.6);
      ctx.save();
      ctx.lineWidth = Math.max(thickPx, 3);
      ctx.beginPath();
      ctx.moveTo(-lengthPx / 2, 0);
      ctx.lineTo( lengthPx / 2, 0);
      ctx.stroke();
      ctx.restore();

    } else if (t === 'manhole') {
      // Circular casting with hatch
      const rPx = sizePx * 0.7;
      ctx.beginPath();
      ctx.arc(0, 0, rPx, 0, Math.PI * 2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-rPx * 0.8, 0);
      ctx.lineTo( rPx * 0.8, 0);
      ctx.moveTo(0, -rPx * 0.8);
      ctx.lineTo(0,  rPx * 0.8);
      ctx.stroke();

    } else if (t === 'crosswalk') {
      // Series of bars across roadway
      const totalWidth = sizePx * 4.0;
      const barWidth   = sizePx * 0.45;
      const spacing    = barWidth * 0.9;
      const count      = 6;
      const startX     = -totalWidth / 2;

      for (let i = 0; i < count; i++) {
        const x = startX + i * (barWidth + spacing);
        ctx.beginPath();
        ctx.rect(x, -sizePx * 0.9, barWidth, sizePx * 1.8);
        ctx.stroke();
      }

    } else if (t === 'stop-sign') {
      // STOP octagon + small text
      const R = sizePx * 0.9;
      drawOctagon(R);

      ctx.save();
      ctx.font = `${R * 0.45}px system-ui, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('STOP', 0, 0);
      ctx.restore();

    } else if (t === 'yield-sign') {
      // Triangle, vertex down (blueprint MUTCD YIELD)
      const h = sizePx * 2.0;
      const w = h * 1.15;
      drawTriangle(w, h);

    } else if (t === 'speed-sign') {
      // Rectangular speed sign with outline + fixed 50 for now
      const h = sizePx * 2.4;
      const w = h * 0.75;
      const r = sizePx * 0.2;

      ctx.beginPath();
      ctx.moveTo(-w/2 + r, -h/2);
      ctx.lineTo( w/2 - r, -h/2);
      ctx.quadraticCurveTo( w/2, -h/2,  w/2, -h/2 + r);
      ctx.lineTo( w/2,  h/2 - r);
      ctx.quadraticCurveTo( w/2,  h/2,  w/2 - r,  h/2);
      ctx.lineTo(-w/2 + r,  h/2);
      ctx.quadraticCurveTo(-w/2,  h/2, -w/2,  h/2 - r);
      ctx.lineTo(-w/2, -h/2 + r);
      ctx.quadraticCurveTo(-w/2, -h/2, -w/2 + r, -h/2);
      ctx.stroke();

      ctx.save();
      ctx.font = `${h * 0.22}px system-ui, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('km/h', 0, 0);
      ctx.restore();

    } else if (t === 'no-parking') {
      // Circle with diagonal slash
      const rPx = sizePx * 0.9;
      ctx.beginPath();
      ctx.arc(0, 0, rPx, 0, Math.PI * 2);
      ctx.stroke();

      // Letter inside sign
      ctx.save();
      ctx.font = `bold ${sizePx * 0.9}px system-ui, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('P', 0, 0);
      ctx.restore();

      ctx.beginPath();
      ctx.moveTo(-rPx * 0.7,  rPx * 0.7);
      ctx.lineTo( rPx * 0.7, -rPx * 0.7);
      ctx.stroke();

    } else if (t === 'ped-sign') {
      // Diamond warning sign, simplified pedestrian
      const h = sizePx * 2.0;
      const w = h;
      ctx.beginPath();
      ctx.moveTo(0, -h/2);
      ctx.lineTo( w/2, 0);
      ctx.lineTo(0,  h/2);
      ctx.lineTo(-w/2, 0);
      ctx.closePath();
      ctx.stroke();

      // Small stylised person
      const body = h * 0.18;
      const headR = h * 0.07;
      ctx.beginPath();
      ctx.arc(0, -body * 0.9, headR, 0, Math.PI * 2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -body * 0.3);
      ctx.lineTo(0,  body * 0.6);
      ctx.moveTo(0, 0);
      ctx.lineTo(-body * 0.6,  body * 0.6);
      ctx.moveTo(0, 0);
      ctx.lineTo( body * 0.6,  body * 0.6);
      ctx.stroke();

    
      // Legs (added for clarity)
      ctx.beginPath();
      ctx.moveTo(0, sizePx * 0.15);
      ctx.lineTo(-sizePx * 0.25, sizePx * 0.45);
      ctx.moveTo(0, sizePx * 0.15);
      ctx.lineTo(sizePx * 0.25, sizePx * 0.45);
      ctx.stroke();

    } else if (t === 'signal') {
      // Traffic signal head
      const h = sizePx * 2.4;
      const w = h * 0.5;
      const r = w * 0.35;

      ctx.beginPath();
      ctx.rect(-w/2, -h/2, w, h);
      ctx.stroke();

      const centers = [-h/3, 0, h/3];
      centers.forEach(cy => {
        ctx.beginPath();
        ctx.arc(0, cy, r, 0, Math.PI * 2);
        ctx.stroke();
      });

    } else {
      // Fallback: simple cross marker
      const s = sizePx;
      ctx.beginPath();
      ctx.moveTo(-s, 0);
      ctx.lineTo( s, 0);
      ctx.moveTo(0, -s);
      ctx.lineTo(0,  s);
      ctx.stroke();
    }

    // Selection halo
    if (isSelectedId(f.id)) {
      ctx.strokeStyle = '#22c55e';
      ctx.lineWidth   = 1.5;
      ctx.beginPath();
      ctx.arc(0, 0, sizePx * 1.3, 0, Math.PI * 2);
      ctx.stroke();
    }

    ctx.restore();
  }

  // --- chunk 7.3 · Labels, measure, move-guide & main draw -------------------------------
  // --- sub-chunk 7.3A · Label + measure feature rendering ------------------------------

  function drawLabelFeature(f){
    if (!state.layers.labels) return;
    const ppm = getPxPerMeter();
    const sizePx = (f.sizeM || state.metersPerGrid * 0.5) * ppm;
    const text   = f.text || '';
    const kind   = f.kind || 'point';

    const anchorPx = worldToCanvas({ xM: f.xM, yM: f.yM });

    // Text position:
    // - If explicit txM/tyM exists, use it (leader/box edits).
    // - Otherwise default to a small offset from the anchor.
    const textPx   = (f.txM != null && f.tyM != null)
      ? worldToCanvas({ xM: f.txM, yM: f.tyM })
      : { xPx: anchorPx.xPx + sizePx * 1.5, yPx: anchorPx.yPx - sizePx * 0.3 };

    const angleRad = (f.angleDeg || 0) * Math.PI / 180;

    // IMPORTANT: All label drawing is anchored to the label's anchor point.
    // (The previous build accidentally drew in "delta space" without translating,
    // which makes labels appear far from the user's tap.)
    const dxText = textPx.xPx - anchorPx.xPx;
    const dyText = textPx.yPx - anchorPx.yPx;

    ctx.save();
    ctx.translate(anchorPx.xPx, anchorPx.yPx);
    if (angleRad) ctx.rotate(angleRad);

    ctx.font = `${sizePx}px system-ui,sans-serif`;
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#e5e7eb';
    ctx.strokeStyle = '#e5e7eb';
    ctx.lineWidth = 1;

    if (kind === 'point') {
      // Centered text on the anchor/text point (symbols are centered; labels should feel the same).
      ctx.textAlign = 'center';
      ctx.fillText(text, dxText, dyText);
      // Reset for downstream drawing that assumes default.
      ctx.textAlign = 'left';
      ctx.textBaseline = 'alphabetic';
    } else {
      const pad   = sizePx * 0.4;
      const width = ctx.measureText(text).width + pad * 2;
      const height = sizePx * 1.4;
      const x = dxText;
      const y = dyText;

      ctx.beginPath();
      ctx.rect(x - pad, y - height / 2, width, height);
      ctx.stroke();

      ctx.textAlign = 'left';
      ctx.fillText(text, x, y);

      if (kind === 'leader') {
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(x - pad, y);
        ctx.stroke();
      }
    }

    if (isSelectedId(f.id)) {
      ctx.strokeStyle = '#22c55e';
      ctx.beginPath();
      ctx.arc(0, 0, sizePx * 0.4, 0, Math.PI * 2);
      ctx.stroke();
    }

    ctx.restore();
  }

  // --- sub-chunk 7.3B · Measure rendering + draft paths ---------------------------------

  
  // Helper: default label position for Measure (world meters)
  function _defaultMeasureLabelPos(pts){
    try{
      if (!Array.isArray(pts) || pts.length < 2) return { xM: 0, yM: 0 };
      const ax = +pts[0].xM, ay = +pts[0].yM, bx = +pts[1].xM, by = +pts[1].yM;
      const mx = (ax + bx) / 2;
      const my = (ay + by) / 2;
      // Perpendicular offset (in world meters) so the label doesn't sit on the line
      const dx = bx - ax, dy = by - ay;
      const L = Math.hypot(dx, dy) || 1;
      const nx = -dy / L, ny = dx / L;
      const off = Math.max(0.15, (state.metersPerGrid || 1) * 0.25);
      return { xM: mx + nx * off, yM: my + ny * off };
    }catch(_){
      return { xM: 0, yM: 0 };
    }
  }

function drawMeasureFeature(f){
    if (!state.layers.measure) return;
    const pts = f.points || [];
    if (pts.length < 2) return;

    const a = worldToCanvas(pts[0]);
    const b = worldToCanvas(pts[1]);

    ctx.save();
    const _ms = (typeof resolveLineStyleForFeature==='function') ? resolveLineStyleForFeature(f) : {widthPx:1.5,color:'#a855f7',dash:[10, 8]};
    ctx.strokeStyle = _ms.color;
    ctx.lineWidth   = _ms.widthPx;
    if (_ms.dash && _ms.dash.length) ctx.setLineDash(_ms.dash); else ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(a.xPx, a.yPx);
    ctx.lineTo(b.xPx, b.yPx);
    ctx.stroke();

    // Label (persistent + adjustable)
    try{
      const lenM = lineLengthMeters(pts);
      // keep derived fields in sync for exports / snapshots
      f.length = lenM;
      try{
        const dx = (pts[1].xM - pts[0].xM);
        const dy = (pts[1].yM - pts[0].yM);
        f.angleDeg = Math.atan2(dy,dx)*180/Math.PI;
      }catch(_){ }
      const val = distDisplayValue(lenM);
      const u   = unitLabelDist();
      let dp = Number.isFinite(Number(f.measureDecimals)) ? Number(f.measureDecimals) : 2;
      dp = Math.max(0, Math.min(6, Math.round(dp)));

      const distTxt = (Number.isFinite(val) ? val.toFixed(dp) : (0).toFixed(dp)) + u;

      // Label content mode
      const mode = (typeof f.measureMode === 'string' && f.measureMode) ? f.measureMode : 'distance';

      let txt = distTxt;
      if (mode === 'distance_angle') {
        const aDeg = Number.isFinite(Number(f.angleDeg)) ? Number(f.angleDeg) : 0;
        txt = distTxt + ' • ' + aDeg.toFixed(1) + '°';
      } else if (mode === 'angle') {
        const aDeg = Number.isFinite(Number(f.angleDeg)) ? Number(f.angleDeg) : 0;
        txt = aDeg.toFixed(1) + '°';
      } else if (mode === 'none') {
        txt = '';
      }

      // If label is disabled, do not draw text (but keep line itself)
      if (!txt) {
        ctx.restore();
        return;
      }

      // Use saved label position if present; otherwise compute a default
      let txM = (Number.isFinite(f.txM) ? f.txM : NaN);
      let tyM = (Number.isFinite(f.tyM) ? f.tyM : NaN);
      if (!Number.isFinite(txM) || !Number.isFinite(tyM)) {
        const d = _defaultMeasureLabelPos(pts);
        txM = d.xM; tyM = d.yM;
      }

      const t = worldToCanvas({xM:txM,yM:tyM});
      ctx.setLineDash([]);
      ctx.font = '12px system-ui';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = _ms.color;
      ctx.strokeStyle = 'rgba(0,0,0,0.65)';
      ctx.lineWidth = 3;
      ctx.strokeText(txt, t.xPx + 6, t.yPx);
      ctx.lineWidth = 1;
      ctx.fillText(txt, t.xPx + 6, t.yPx);

      // Label handle when selected in Move Point mode
      if (state.editMode === 'movePoint' && state.selectedId === f.id) {
        ctx.fillStyle = _ms.color;
        ctx.beginPath();
        ctx.arc(t.xPx, t.yPx, 4, 0, Math.PI*2);
        ctx.fill();
      }
    }catch(_){}

    ctx.setLineDash([]);

    ctx.fillStyle = _ms.color;
    ctx.beginPath();
    ctx.arc(a.xPx, a.yPx, 3, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(b.xPx, b.yPx, 3, 0, Math.PI*2);
    ctx.fill();

    // Handles when editing
    if (state.editMode === 'movePoint' && state.selectedId === f.id) {
      ctx.beginPath();
      ctx.arc(a.xPx,a.yPx,4,0,Math.PI*2);ctx.fill();
      ctx.beginPath();
      ctx.arc(b.xPx,b.yPx,4,0,Math.PI*2);ctx.fill();
    }

    ctx.restore();
  }

  // --- sub-chunk 7.3C · Current path preview + move guide + main draw -------------------

  function drawCurrentPath(){
    const p = state.currentPath;
    if (!p || !p.points || !p.points.length) return;

    const pts = p.points;
    ctx.save();

    // Preview should match Line Defaults (thickness/color/style)
    if (p.type === 'road' || p.type === 'lane') {
      const ld = state.lineDefaults || { widthPx: 2, color: '#e5e7eb', style: 'auto' };
      const thick = Math.max(0.25, Number(ld.widthPx || 2));
      const col = String(ld.color || '#e5e7eb');

      // Determine style: 'auto' maps road->solid, lane->dashed
      let st = String(ld.style || 'auto').toLowerCase();
      if (st === 'auto') st = (p.type === 'road') ? 'solid' : 'dashed';

      ctx.strokeStyle = col;
      ctx.lineWidth = thick;

      if (st === 'centerline') ctx.setLineDash([18, 6, 3, 6]);
      else if (st === 'dashed') ctx.setLineDash([10, 8]);
      else ctx.setLineDash([]);
    } else if (p.type === 'area') {
      ctx.strokeStyle = '#38bdf8';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([]);
    } else if (p.type === 'measure') {
      ctx.strokeStyle = '#a855f7';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([10, 8]);
    }

    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    const p0 = worldToCanvas(pts[0]);
    ctx.beginPath();
    ctx.moveTo(p0.xPx, p0.yPx);
    for (let i = 1; i < pts.length; i++) {
      const c = worldToCanvas(pts[i]);
      ctx.lineTo(c.xPx, c.yPx);
    }
    if (p.type === 'area' && pts.length > 2) ctx.closePath();
    ctx.stroke();

    // Always clear dash after stroke
    ctx.setLineDash([]);
    ctx.restore();
  }

  // --- sub-chunk 7.3D · Move-shape guide overlay ---------------------------------------

  function drawMoveShapeGuide(){
    if (!moveShapeDrag || !moveShapeDrag.guideLine) return;
    if (state.tool !== 'inspect' || state.editMode !== 'moveShape') return;

    const a = worldToCanvas(moveShapeDrag.guideLine.a);
    const b = worldToCanvas(moveShapeDrag.guideLine.b);

    ctx.save();
    ctx.strokeStyle = '#22c55e';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([8,6]);

    ctx.beginPath();
    ctx.moveTo(a.xPx, a.yPx);
    ctx.lineTo(b.xPx, b.yPx);
    ctx.stroke();

    // drop dot
    ctx.setLineDash([]);
    ctx.fillStyle = '#22c55e';
    ctx.beginPath();
    ctx.arc(b.xPx, b.yPx, 4, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  // --- sub-chunk 7.3E · Main draw orchestrator + measurement overlay --------------------

  // SCRIPT PART 1.2 END (LLM ANCHOR)
</script>

<script>

  // SCRIPT PART 1.3 BEGIN (LLM ANCHOR)

// SUB-CHUNK 4.G END — Feature draw primitives (symbols/labels/measure/path)
// SUB-CHUNK 4.H BEGIN — Main draw loop + snap feedback + inspector refresh
  function draw(){
    drawGrid();

    // hide measure overlay by default
    if (measureOverlay) {
      measureOverlay.style.display = 'none';
    }

    const selected = state.features.find(f => f.id === state.selectedId);

    state.features.forEach(f => {
      if (f.type === 'road' || f.type === 'lane') {
        drawLineFeature(f);
      } else if (f.type === 'area') {
        drawAreaFeature(f);
      } else if (f.type === 'symbol') {
        drawSymbolFeature(f);
      } else if (f.type === 'label') {
        drawLabelFeature(f);
      } else if (f.type === 'measure') {
        drawMeasureFeature(f);
      }
    });

    // draw guide after features so it’s always visible
    drawMoveShapeGuide();

    drawCurrentPath();

    // Quick Verify segment (transient; shown even though no feature is created)
    if (state.tool === 'quickVerify' && state.quickVerify && state.quickVerify.points && state.quickVerify.points.length >= 2) {
      try {
        drawMeasureFeature({ id: -999999, type: 'measure', points: state.quickVerify.points });
      } catch(_) {}
    }

    // Step 1 Free-Capture preview (debug-only; no schema changes)
    if (typeof drawFreeCapturePreview === 'function') drawFreeCapturePreview();

    // Measure overlay disabled: Measure now renders its own persistent, adjustable canvas label.

    drawBgCalMarkers();

    drawEditActionMarkers();

// --- PROPOSAL PATCH: snap feedback glyph ----------------------------------------
    drawSnapFeedbackGlyph();
    // --- PROPOSAL PATCH END ----------------------------------------------------------
  }

  function drawEditActionMarkers(){
    try{
      const mark = state && state._editMarks && state._editMarks.last;
      if (!mark) return;
      const now = Date.now();
      const age = now - (mark.ts || 0);
      const dur = 1200; // ms
      if (!isFinite(age) || age < 0 || age > dur) return;

      const t = age / dur; // 0..1
      const p = worldToCanvas({ xM: mark.xM, yM: mark.yM });

      // Expand + fade ring
      const r = 10 + (t * 10);

      ctx.save();
      ctx.globalAlpha = 0.9 * (1 - t);
      ctx.strokeStyle = '#22c55e';
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.arc(p.xPx, p.yPx, r, 0, Math.PI * 2);
      ctx.stroke();

      // center dot
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#22c55e';
      ctx.beginPath();
      ctx.arc(p.xPx, p.yPx, 3, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }catch(_){}
  }

  function drawBgCalMarkers(){
    try{
      const cal = state && state._bgCal;
      if (!cal) return;
      const now = Date.now();

      // Show live markers while active; otherwise show the last completed / attempted markers briefly.
      const last = cal._lastMarks;
      const showLast = last && (now - (last.ts || 0) < 8000);

      const p1 = (cal.active && cal.p1) ? cal.p1 : (showLast ? last.p1 : null);
      const p2 = (cal.active && cal._p2Mark) ? cal._p2Mark : (showLast ? last.p2 : null);

      if (!p1 && !p2) return;

      const a = p1 ? worldToCanvas(p1) : null;
      const b = p2 ? worldToCanvas(p2) : null;

      ctx.save();
      ctx.globalAlpha = 1;

      // Draw line if both points exist
      if (a && b) {
        ctx.beginPath();
        ctx.moveTo(a.xPx, a.yPx);
        ctx.lineTo(b.xPx, b.yPx);
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#00ff00';
        ctx.stroke();
      }

      // Draw point helper
      function dot(x,y,fill,stroke){
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI*2);
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = stroke;
        ctx.stroke();
      }

      if (a) dot(a.xPx, a.yPx, 'rgba(0,255,0,0.20)', '#00ff00');
      if (b) dot(b.xPx, b.yPx, 'rgba(0,255,255,0.20)', '#00ffff');

      ctx.restore();
    }catch(_){}
  }

  function drawSnapFeedbackGlyph(){
    try{
      if (!state.snapEnabled) return;
      const info = state._lastSnap;
      if (!info || !Number.isFinite(info.xM) || !Number.isFinite(info.yM)) return;

      // Only show very recent snap feedback to avoid stale markers
      const age = Date.now() - (info.ts || 0);
      if (age > 250) return;

      const p = worldToCanvas({ xM: info.xM, yM: info.yM });
      const r = 6;

      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,0,0,0.55)';
      ctx.fillStyle = 'rgba(255,255,255,0.75)';

      if (info.kind === 'angle') {
        // angle: small tick mark + dot
        ctx.beginPath();
        ctx.arc(p.xPx, p.yPx, r, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(p.xPx + r + 2, p.yPx);
        ctx.lineTo(p.xPx + r + 10, p.yPx);
        ctx.stroke();
      } else if (info.kind === 'point') {
        // point: dot ring
        ctx.beginPath();
        ctx.arc(p.xPx, p.yPx, r, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
      } else {
        // grid: tiny crosshair
        ctx.beginPath();
        ctx.moveTo(p.xPx - r, p.yPx);
        ctx.lineTo(p.xPx + r, p.yPx);
        ctx.moveTo(p.xPx, p.yPx - r);
        ctx.lineTo(p.xPx, p.yPx + r);
        ctx.stroke();
      }
      ctx.restore();
    }catch(_){/* no-op */}
  }
// --- chunk end 7 ---------------------------------------------------------------
  // --- Feature dropdown & inspector chunk 8 ------------------------------------------

  // --- chunk 8.0a · UI label helpers (no schema change) -------------------------------
  function uiLabelForLineType(t){
    if (t === 'lane') return 'Dashed line';
    if (t === 'road') return 'Solid line';
    return '';
  }

  // Friendly label for symbols (preserves routing value like "user:<id>"; display uses saved name)
  function uiLabelForSymbolType(symbolType){
    const t = String(symbolType || '');
    if (t.startsWith('user:')){
      const id = t.slice(5);
      try{
        const u = _getUserSymbolById(id);
        if (u && u.name) return String(u.name);
      }catch(_){/* no-op */}
      return 'Preset';
    }
    // Built-in: show the raw built-in key (kept short)
    return t || 'Symbol';
  }
  // --- chunk end 8.0a ---------------------------------------------------------------

  // --- chunk 8.1 · Feature dropdown -------------------------------------------------

  function updateFeatureSelect(){
    featureSelect.innerHTML = '';
    const optNone = document.createElement('option');
    optNone.value = '';
    optNone.textContent = '(none)';
    featureSelect.appendChild(optNone);

    const uDist = unitLabelDist();
    const uArea = unitLabelArea();

    state.features.forEach((f,index)=>{
      const opt = document.createElement('option');
      opt.value = String(f.id);

      let labelType =
        (f.type==='road' || f.type==='lane') ? uiLabelForLineType(f.type) :
        f.type==='area'    ? 'Area' :
        f.type==='measure' ? 'Measure' :
        f.type==='label'   ? 'Label' : 'Symbol';

      let measure = '';
      if(f.type==='road' || f.type==='lane' || f.type==='measure'){
        const m = lineLengthMeters(f.points);
        const v = distDisplayValue(m);
        measure = fmtNum(v,2) + uDist;
      } else if(f.type==='area'){
        const a = areaWithHoles(f) || 0;
        const v = areaDisplayValue(a);
        measure = fmtNum(v,1) + uArea;
      }

      let details = '';
      if(f.type==='area'){
        details = f.name || '';
      } else if(f.type==='label'){
        details = f.text || '';
      } else if(f.type==='symbol'){
        details = uiLabelForSymbolType(f.symbolType);
      } else if(f.type==='measure'){
        details = '';
      } else {
        details = `${(f.points||[]).length} pts`;
      }

      opt.textContent = `${index+1}. ${labelType} ${details ? '· '+details : ''}${measure ? ' · '+measure : ''}`;
      featureSelect.appendChild(opt);
    });

    if(state.selectedId != null){
      featureSelect.value = String(state.selectedId);
    } else {
      featureSelect.value = '';
    }
  }

  // --- chunk 8.2 · Inspector state & field visibility --------------------------------

  function refreshSelectedInspector(){
    const f = state.features.find(x=>x.id===state.selectedId);

    // Reset
    selType.textContent = f ? '' : '–';
    propTypeValue.textContent = '–';
    propIdValue.textContent = '–';
    propGroupInput.value = (f && f.groupId != null && String(f.groupId).trim() !== '') ? String(f.groupId).trim() : '';

    selLineFields.style.display   = 'none';
    selSymbolFields.style.display = 'none';
    selAreaFields.style.display   = 'none';
    if (selShapeDimFields) selShapeDimFields.style.display = 'none';
    if (selShapeWidthRow) selShapeWidthRow.style.display = 'none';
    if (selShapeHeightRow) selShapeHeightRow.style.display = 'none';
    if (selShapeDiameterRow) selShapeDiameterRow.style.display = 'none';
    selLabelFields.style.display  = 'none';
// Default: enable edits
    selLengthInput.disabled = false;
    selSizeInput.disabled = false;
    selLabelSizeInput.disabled = false;

    // Hide custom dash row by default (only show when custom is active)
    if (selStrokeDashRow) selStrokeDashRow.style.display = 'none';
    if (selMultiAreaFields) selMultiAreaFields.style.display = 'none';

    // --- sub-chunk 8.2M · Multi-select area total (selection summary) -----------------
    if (state.multiSelectEnabled && Array.isArray(state.selectedIds) && state.selectedIds.length >= 2) {
      const selected = state.features.filter(x => state.selectedIds.includes(x.id));
      const areas = selected.filter(x => x && x.type === 'area');
      if (areas.length >= 2) {
        // Show summary even if mixed selection; total counts only areas.
        propTypeValue.textContent = 'area';
        propIdValue.textContent   = '—';

        if (selMultiAreaCountInput) selMultiAreaCountInput.value = String(areas.length);

        let totalM2 = 0;
        for (const a of areas) totalM2 += (areaWithHoles(a) || 0);

        if (selMultiAreaTotalInput) selMultiAreaTotalInput.value = fmtNum(areaDisplayValue(totalM2), 2);

        if (selMultiAreaFields) selMultiAreaFields.style.display = 'block';

        // Hide single-feature editors
        if (selLineFields)   selLineFields.style.display = 'none';
        if (selSymbolFields) selSymbolFields.style.display = 'none';
        if (selAreaFields)   selAreaFields.style.display = 'none';
        if (selLabelFields)  selLabelFields.style.display = 'none';
        if (selShapeDimFields) selShapeDimFields.style.display = 'none';
        if (selStrokeDashRow) selStrokeDashRow.style.display = 'none';

        return;
      }
    }

    if(!f){
      return;
    }

    // Human-facing type label (keep internal schema unchanged)
    if (f.type === 'road' || f.type === 'lane') {
      propTypeValue.textContent = uiLabelForLineType(f.type);
    } else {
      propTypeValue.textContent = f.type;
    }
    propIdValue.textContent   = f.id;

    // --- sub-chunk 8.2A · Line/measure inspector (length + style) ----------------------
    if(f.type==='road' || f.type==='lane' || f.type==='measure'){
      selType.textContent =
        (f.type==='road' || f.type==='lane') ? uiLabelForLineType(f.type) :
                             'Measure';

      const lenM = lineLengthMeters(f.points);
      selLengthInput.value = fmtNum(distDisplayValue(lenM), 2);

      // still only editable when it is a simple 2-pt segment
      selLengthInput.disabled = (f.points.length !== 2);

      // Populate style controls for road/lane only (measure uses same block but style is optional)
      if (selStrokeWidthInput && selStrokeColorInput && selStrokePatternSelect) {
        // Compute “effective” style without mutating features
        let effWidth = (f.type === 'road') ? 6 : 2;
        let effColor = (f.type === 'road') ? '#e5e7eb' : '#facc15';
        let effDash  = null;

        // If the renderer resolver exists (Step 3), use it as truth.
        if (typeof resolveLineStyleForFeature === 'function' && (f.type === 'road' || f.type === 'lane' || f.type === 'measure')) {
          const s = resolveLineStyleForFeature(f);
          if (s && Number.isFinite(s.widthPx)) effWidth = s.widthPx;
          if (s && typeof s.color === 'string') effColor = s.color;
          effDash = (s && Array.isArray(s.dash)) ? s.dash : null;
        } else {
          // Fallback (should rarely be used)
          if (Number.isFinite(Number(f.strokeWidthPx))) effWidth = Number(f.strokeWidthPx);
          if (typeof f.strokeColor === 'string' && f.strokeColor.length) effColor = f.strokeColor;
          if (Array.isArray(f.strokeDash)) effDash = f.strokeDash;
        }

        selStrokeWidthInput.value = String(effWidth);

        // Color
        try { selStrokeColorInput.value = effColor; } catch(_) {}
        if (selStrokeColorText) selStrokeColorText.textContent = String(effColor || '').toLowerCase();

        // Pattern label logic (deterministic UI)
        const presetDashed = [10,8];
        const presetCenter = [18,6,3,6];

        const sameArray = (a,b)=>{
          if (!Array.isArray(a) || !Array.isArray(b)) return false;
          if (a.length !== b.length) return false;
          for (let i=0;i<a.length;i++){
            if (Number(a[i]) !== Number(b[i])) return false;
          }
          return true;
        };

        let pattern = 'auto';

        // Explicit null dash means SOLID override
        if (f.strokeDash === null) {
          pattern = 'solid';
        } else if (Array.isArray(f.strokeDash)) {
          // Explicit custom/preset override
          if (sameArray(f.strokeDash, presetCenter)) pattern = 'centerline';
          else if (sameArray(f.strokeDash, presetDashed)) pattern = 'dashed';
          else pattern = 'custom';
        } else {
          // No strokeDash field: use lineStyle hint for lane, solid for road
          if (f.type === 'lane') {
            const ls = String(f.lineStyle || 'dashed').toLowerCase();
            pattern = (ls === 'centerline') ? 'centerline' : 'dashed';
          } else {
            pattern = 'solid';
          }
        }

        selStrokePatternSelect.value = pattern;

        if (pattern === 'custom') {
          if (selStrokeDashRow) selStrokeDashRow.style.display = '';
          if (selStrokeDashInput) selStrokeDashInput.value = Array.isArray(f.strokeDash) ? f.strokeDash.join(',') : '';
        } else {
          if (selStrokeDashRow) selStrokeDashRow.style.display = 'none';
          if (selStrokeDashInput) selStrokeDashInput.value = '';
        }
      }
      selLineFields.style.display='block';

    // --- end sub-chunk 8.2A ------------------------------------------------------------
    } else if(f.type==='symbol'){
      selType.textContent = 'Symbol: ' + uiLabelForSymbolType(f.symbolType);
      selAngleInput.value = f.angleDeg || 0;

      const sizeM = f.sizeM || state.metersPerGrid;
      selSizeInput.value  = fmtNum(distDisplayValue(sizeM), 2);

      selSymbolFields.style.display='block';

    } else if(f.type==='area'){
      selType.textContent = 'Area region';
      selAreaNameInput.value    = f.name || '';
      selAreaSurfaceInput.value = f.surface || '';
      selAreaJobInput.value     = f.jobRef || '';

      const aM2 = areaWithHoles(f) || 0;
      selAreaValueInput.value   = fmtNum(areaDisplayValue(aM2), 1);

      // Shape dimensions (only for true shapes: rect/circle area)
      try{
        if (selShapeDimFields && (f.shapeType === 'rect' || f.shapeType === 'circle') && f.shapeMeta){
          selShapeDimFields.style.display = 'block';
          // Mirror current distance unit label used by Length field
          const u = (selLengthUnit && selLengthUnit.textContent) ? selLengthUnit.textContent : 'm';
          if (selShapeWidthUnit) selShapeWidthUnit.textContent = u;
          if (selShapeHeightUnit) selShapeHeightUnit.textContent = u;
          if (selShapeDiameterUnit) selShapeDiameterUnit.textContent = u;

          if (f.shapeType === 'rect' && f.shapeMeta.kind === 'rect'){
            const wM = Math.abs(f.shapeMeta.maxX - f.shapeMeta.minX);
            const hM = Math.abs(f.shapeMeta.maxY - f.shapeMeta.minY);
            if (selShapeWidthRow) selShapeWidthRow.style.display = 'flex';
            if (selShapeHeightRow) selShapeHeightRow.style.display = 'flex';
            if (selShapeDiameterRow) selShapeDiameterRow.style.display = 'none';
            if (selShapeWidthInput) selShapeWidthInput.value = fmtNum(distDisplayValue(wM), 2);
            if (selShapeHeightInput) selShapeHeightInput.value = fmtNum(distDisplayValue(hM), 2);
          } else if (f.shapeType === 'circle' && f.shapeMeta.kind === 'circle'){
            const dM = 2 * Math.abs(f.shapeMeta.rM || 0);
            if (selShapeWidthRow) selShapeWidthRow.style.display = 'none';
            if (selShapeHeightRow) selShapeHeightRow.style.display = 'none';
            if (selShapeDiameterRow) selShapeDiameterRow.style.display = 'flex';
            if (selShapeDiameterInput) selShapeDiameterInput.value = fmtNum(distDisplayValue(dM), 2);
          } else {
            selShapeDimFields.style.display = 'none';
          }
        }
      }catch(_){}

      selAreaFields.style.display='block';

    } else if(f.type==='label'){
      selType.textContent = 'Label (' + (f.kind || 'point') + ')';
      selLabelTextInput.value = f.text || '';

      const sM = f.sizeM || state.metersPerGrid*0.5;
      selLabelSizeInput.value = fmtNum(distDisplayValue(sM), 2);

      selLabelFields.style.display='block';
    }
  }
  // --- chunk end 8 ---------------------------------------------------------------
  // --- Hit testing & vertex helpers chunk 9 ------------------------------------------
// SUB-CHUNK 4.H END — Main draw loop + snap feedback + inspector refresh
// SUB-CHUNK 9.B1 BEGIN — Bend target hit-test + segment pick helpers (markers-only)

function hitTestFeature(xPx,yPx){
  // Labels
  for(let i=state.features.length-1;i>=0;i--){
    const f=state.features[i];
    if(f.type==='label'){
      const anchor=worldToCanvas({xM:f.xM,yM:f.yM});
      const sizePx=(f.sizeM||state.metersPerGrid*0.5)*getPxPerMeter();
      const dx=xPx-anchor.xPx,dy=yPx-anchor.yPx;
      if(Math.sqrt(dx*dx+dy*dy)<=sizePx*0.8) return {feature:f};
    }
  }
  // Symbols
  for(let i=state.features.length-1;i>=0;i--){
    const f=state.features[i];
    if(f.type==='symbol'){
      const pos=worldToCanvas({xM:f.xM,yM:f.yM});
      const sizePx=(f.sizeM||state.metersPerGrid)*getPxPerMeter();
      const dx=xPx-pos.xPx,dy=yPx-pos.yPx;
      if(Math.sqrt(dx*dx+dy*dy)<=sizePx+4) return {feature:f};
    }
  }
  // Areas (point-in-polygon; bbox precheck for speed)
  const pointInPoly = (x,y,poly)=>{
    // Ray-casting algorithm in canvas space
    let inside=false;
    for(let i=0,j=poly.length-1;i<poly.length;j=i++){
      const xi=poly[i].x, yi=poly[i].y;
      const xj=poly[j].x, yj=poly[j].y;
      const intersect = ((yi>y)!==(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi+1e-12) + xi);
      if(intersect) inside=!inside;
    }
    return inside;
  };
  for(let i=state.features.length-1;i>=0;i--){
    const f=state.features[i];
    if(f.type!=='area') continue;
    const pts=f.points||[];
    if(pts.length<3) continue;

    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    const poly=[];
    for(const p of pts){
      const c=worldToCanvas(p);
      poly.push({x:c.xPx,y:c.yPx});
      minX=Math.min(minX,c.xPx); maxX=Math.max(maxX,c.xPx);
      minY=Math.min(minY,c.yPx); maxY=Math.max(maxY,c.yPx);
    }
    if(xPx<minX || xPx>maxX || yPx<minY || yPx>maxY) continue;

    // Hit-test contract for areas-with-holes:
    // insideOuter && !insideAnyHole
    if(!pointInPoly(xPx,yPx,poly)) continue;

    // Exclude cutouts (holes) if present
    const holes = f.holes || [];
    let insideHole = false;
    for(const ring of holes){
      if(!ring || ring.length < 3) continue;
      // bbox precheck for hole ring (canvas space)
      let hMinX=Infinity,hMaxX=-Infinity,hMinY=Infinity,hMaxY=-Infinity;
      const hPoly=[];
      for(const hp of ring){
        const hc=worldToCanvas(hp);
        hPoly.push({x:hc.xPx,y:hc.yPx});
        hMinX=Math.min(hMinX,hc.xPx); hMaxX=Math.max(hMaxX,hc.xPx);
        hMinY=Math.min(hMinY,hc.yPx); hMaxY=Math.max(hMaxY,hc.yPx);
      }

      // Truth-guard: ignore corrupt holes that effectively cover the whole outer.
      // This prevents "area becomes unselectable" if a bad hole ring was recorded.
      const outerA = polygonAreaMeters2(pts);
      const holeA  = polygonAreaMeters2(ring);
      if (outerA > 0 && holeA >= outerA * 0.98) continue;
      if (isFinite(hMinX) && isFinite(hMaxX) && isFinite(hMinY) && isFinite(hMaxY)) {
        const coverX = (hMinX <= minX + 2) && (hMaxX >= maxX - 2);
        const coverY = (hMinY <= minY + 2) && (hMaxY >= maxY - 2);
        if (coverX && coverY) continue;
      }
      if(xPx<hMinX || xPx>hMaxX || yPx<hMinY || yPx>hMaxY) continue;
      if(pointInPoly(xPx,yPx,hPoly)){ insideHole = true; break; }
    }
    if(insideHole) continue;

    return {feature:f};
  }
  // Lines (roads, lanes, measures)
  const hitDist=10;
  for(let i=state.features.length-1;i>=0;i--){
    const f=state.features[i];
    if(f.type!=='road' && f.type!=='lane' && f.type!=='measure') continue;
    const pts=f.points||[];
    for(let j=1;j<pts.length;j++){
      const a=worldToCanvas(pts[j-1]),b=worldToCanvas(pts[j]);
      const dx=b.xPx-a.xPx;
      const dy=b.yPx-a.yPx;
      const len2=dx*dx+dy*dy;
      if(!len2) continue;
      const t=((xPx-a.xPx)*dx+(yPx-a.yPx)*dy)/len2;
      if(t<0||t>1) continue;
      const projX=a.xPx+t*dx;
      const projY=a.yPx+t*dy;   // ✅ fixed: proper projection onto segment
      const dist=Math.sqrt((xPx-projX)**2+(yPx-projY)**2);
      if(dist<=hitDist) return {feature:f, segmentIndex:j-1};
    }
  }
  return null;
}

  function pickNearestVertexOnArea(f,xPx,yPx){
    const candidates = [];
    (f.points || []).forEach((p,idx)=>{
      candidates.push({ring:'outer', holeIndex:null, index:idx, pt:p});
    });
    (f.holes || []).forEach((poly,hIndex)=>{
      (poly||[]).forEach((p,idx)=>{
        candidates.push({ring:'hole', holeIndex:hIndex, index:idx, pt:p});
      });
    });

    let best=null, bestD2=Infinity;
    candidates.forEach(c=>{
      const cv = worldToCanvas(c.pt);
      const dx=xPx-cv.xPx, dy=yPx-cv.yPx;
      const d2=dx*dx+dy*dy;
      if(d2<bestD2){
        bestD2=d2; best=c;
      }
    });
    return best;
  }

  function findNearestSegmentIndex(points,xPx,yPx){
    if (!points || points.length < 2) return null;
    let bestIdx = null;
    let bestD2 = Infinity;
    for (let i=0;i<points.length-1;i++){
      const a = worldToCanvas(points[i]);
      const b = worldToCanvas(points[i+1]);
      const dx=b.xPx-a.xPx;
      const dy=b.yPx-a.yPx;
      const len2=dx*dx+dy*dy;
      if(!len2) continue;
      const t=((xPx-a.xPx)*dx+(yPx-a.yPx)*dy)/len2;
      if(t<0||t>1) continue;
      const projX=a.xPx+t*dx;
      const projY=a.yPx+t*dy;
      const dist2=(xPx-projX)**2+(yPx-projY)**2;
      if (dist2<bestD2){
        bestD2=dist2;
        bestIdx=i;
      }
    }
    return bestIdx;
  }

  // --- sub-chunk 9.A1 · Bend support for closed rings (Areas)
  // Areas store boundary points as an implicit closed ring (last connects back to first).
  // For bending the closing edge (last -> first) we temporarily rotate the ring so the edge becomes internal,
  // splice normally, then rotate back to keep point order stable.
  function findNearestSegmentIndexClosed(points, xPx, yPx){
    if (!points || points.length < 2) return null;
    let bestIdx = null;
    let bestD2 = Infinity;
    const n = points.length;
    for (let i=0;i<n;i++){
      const a = worldToCanvas(points[i]);
      const b = worldToCanvas(points[(i+1)%n]);
      const dx=b.xPx-a.xPx;
      const dy=b.yPx-a.yPx;
      const len2=dx*dx+dy*dy;
      if(!len2) continue;
      const t=((xPx-a.xPx)*dx+(yPx-a.yPx)*dy)/len2;
      if(t<0||t>1) continue;
      const projX=a.xPx+t*dx;
      const projY=a.yPx+t*dy;
      const d2=(xPx-projX)*(xPx-projX)+(yPx-projY)*(yPx-projY);
      if(d2<bestD2){ bestD2=d2; bestIdx=i; }
    }
    return bestIdx;
  }

  function spliceSegmentWithCurvePointsClosed(basePoints, segIndex, curvePts){
    // Closed-ring splice: replace edge [segIndex -> (segIndex+1)%n] with curvePts.
    const n = (basePoints && basePoints.length) ? basePoints.length : 0;
    if (n < 2) return (basePoints || []).slice();

    // Non-wrapping edge: safe to use standard splice.
    if (segIndex >= 0 && segIndex < n-1) {
      return spliceSegmentWithCurvePoints(basePoints, segIndex, curvePts);
    }

    // Wrapping edge (last -> first): rotate so it becomes internal, splice, rotate back.
    if (segIndex === n-1) {
      const rotated = basePoints.slice(1).concat(basePoints.slice(0,1)); // start at p1, end at p0
      const splicedRot = spliceSegmentWithCurvePoints(rotated, n-2, curvePts); // replace edge p(n-1)->p0
      // rotate back: move last element (p0) to the front
      return splicedRot.slice(-1).concat(splicedRot.slice(0, -1));
    }

    return (basePoints || []).slice();
  }

// SUB-CHUNK 9.B1 END
// --- chunk end 9 ---------------------------------------------------------------
// --- Edit mode actions chunk 10 ------------------------------------------------------
// SUB-CHUNK 10.B1 BEGIN — Bend edit-mode routing (safe-edit boundary)
// --- chunk 10.1 · Edit mode state & button highlighting ------------------------------ 

function setEditMode(mode){
  const _prevEditMode = state.editMode;
  // Leaving rotate mode cancels any uncommitted rotate preview (truth: no silent commits).
  if (_prevEditMode === 'rotate' && mode !== 'rotate') {
    try { cancelRotateSession('setEditMode'); } catch(_){ }
  }
  state.editMode = mode || 'none';

  // reset transient edit state
  movePointSelection = null;
  moveShapeDrag = null;

  // Only clear cutoutOuterId when leaving cutout mode
  if (mode !== 'cutout') {
    cutoutOuterId = null;
  }

  // Reset edit buttons
  [editMovePointBtn, editMoveShapeBtn, editAddVertexBtn,
   editRemoveVertexBtn, editCutoutBtn].forEach(btn=>{
    if (!btn) return;
    btn.classList.remove('active');
  });

  if (mode === 'movePoint'   && editMovePointBtn)   editMovePointBtn.classList.add('active');
if (mode === 'moveShape'   && editMoveShapeBtn)   editMoveShapeBtn.classList.add('active');
if (mode === 'addVertex'   && editAddVertexBtn)   editAddVertexBtn.classList.add('active');
if (mode === 'removeVertex'&& editRemoveVertexBtn)editRemoveVertexBtn.classList.add('active');
if (mode === 'cutout'      && editCutoutBtn)      editCutoutBtn.classList.add('active');
// Status text
  if (mode === 'none') {
  // --- SUB-CHUNK 10.R1 BEGIN — Inspect/nav/move-shape/edit routing ---
    if (state.tool === 'inspect') {
      setStatusHint('Tool: Inspect / Nav · Tap to select, drag to pan');
    }
  } else if (mode === 'pastePlace') {
    setStatusHint('Paste: tap a location to place.');
  } else if (mode === 'movePoint') {
    setStatusHint('Edit: Move point · Tap a vertex, then tap new location.');
  } else if (mode === 'moveShape') {
    setStatusHint('Edit: Move shape · Drag selected feature.');
  } else if (mode === 'rotate') {
    setStatusHint('Edit: Rotate · Drag around selection or enter degrees, then Finish/Auto.');
  } else if (mode === 'addVertex') {
    setStatusHint('Edit: Add vertex · Tap on an edge to insert a vertex.');
  } else if (mode === 'removeVertex') {
    setStatusHint('Edit: Remove vertex · Tap a vertex to delete it.');
  } else if (mode === 'cutout') {
    setStatusHint('Cut-out mode · Tap an inner area to subtract.');
  }
  // Accuracy note: current undo/redo snapshots are geometry/view only (tool/UI state is not rewound).
  // PROTECT: do not write statusLeft directly; route through presenter and never overwrite incidents.
  try{
    if (window.FO_STATUS && !FO_STATUS.getActiveIncident?.()){
      const base = (statusLeft && statusLeft.textContent) ? String(statusLeft.textContent) : '';
      setStatusHint(base ? (base + ' · Undo: geometry-only') : 'Undo: geometry-only');
    }
  }catch(_){ }

setModeLabel();
  
        try{ syncTopbarEditUI(); }catch(_){ }
    try{ updateContextHighlights(); }catch(_){ }
    draw();
}

// --- chunk 10.2 · Tool switching + status text --------------------------------------- 

function lineStyleToTool(style){
  // Deterministic mapping (NO guessing)
  if (style === 'dashed') return 'lane';
  if (style === 'centerline') return 'lane';
  return 'road'; // solid (default)
}

function lineStyleLabelText(style){
  if (style === 'dashed') return 'Dashed';
  if (style === 'centerline') return 'Centerline';
  return 'Solid';
}

function setTool(tool){
  state.tool = tool;
  state.phase = (tool === 'inspect') ? 'idle' : 'tool_active';

  // Inspect/Nav is a global escape: leaving any active edit mode when entering inspect.
  if (tool === 'inspect') {
    try { setEditMode('none'); } catch(_) {}
  }

  // If leaving Bend, cancel any active/pending Bend preview (no silent commits)
  if (tool !== 'bend') {
    try { if (typeof cancelBendSession === 'function') cancelBendSession('toolSwitch'); } catch(_) {}
  }
  // Quick Verify is transient: clear when switching tools (no lasting marks)
  if (tool !== 'quickVerify') {
    try { if (typeof clearQuickVerify === 'function') clearQuickVerify('toolSwitch'); } catch(_) {}
  }

  state.currentPath = null;
  navDragActive = false;
  // If leaving freeDraw while capturing, abort capture safely.
  if (tool !== 'freeDraw' && state.freeCapture && state.freeCapture.active) {
    freeCaptureAbort();
  }

  // Keep the Line Tool label in sync
  if (lineStyleLabel) {
    lineStyleLabel.textContent = lineStyleLabelText(state.lineStyle);
  }

  // Reset tool buttons (Line Tool is separate)
  // Truth highlights: reset then apply category + specific truths (single-source sets, no overlaps)
  const TOPBAR_TOOL_BTNS = [toolInspectBtn, toolMeasureBtn, toolAreaBtn, toolSymbolBtn, toolLabelBtn, toolEraseBtn, freeDrawBtn];
  TOPBAR_TOOL_BTNS.forEach(btn => {
    if (!btn) return;
    btn.classList.remove('active');
  });

  // Reset legacy + summary buttons
  if (lineToolBtn) lineToolBtn.classList.remove('active');
  if (typeof drawToolBtn !== 'undefined' && drawToolBtn) drawToolBtn.classList.remove('active');

  // Definition: "Draw" means the mode creates a new object the user can see on the canvas.
  const isDrawFamily = DRAW_FAMILY_TOOLS.has(tool);

  // Category truth: draw summary can be active alongside a specific tool highlight.
  if (isDrawFamily) {
    if (typeof drawToolBtn !== 'undefined' && drawToolBtn) drawToolBtn.classList.add('active');
    if (lineToolBtn) lineToolBtn.classList.add('active');
  }

  // Specific truth: highlight the active tool's own button (when one exists).
  if (tool === 'inspect' && toolInspectBtn) toolInspectBtn.classList.add('active');
  else if (tool === 'measure' && toolMeasureBtn) toolMeasureBtn.classList.add('active');
  else if (tool === 'area' && toolAreaBtn) toolAreaBtn.classList.add('active');
  else if (tool === 'freeDraw' && freeDrawBtn) freeDrawBtn.classList.add('active');
  else if (tool === 'symbol' && toolSymbolBtn) toolSymbolBtn.classList.add('active');
  else if (tool === 'label' && toolLabelBtn) toolLabelBtn.classList.add('active');
  else if (tool === 'erase' && toolEraseBtn) toolEraseBtn.classList.add('active');

  // Leaving inspect turns off edit modes
  if (tool !== 'inspect') {
    setEditMode('none');
  }

  // Status text by tool
  if (tool === 'inspect') {
    if (state.editMode === 'none') {
      setStatusHint('Tool: Inspect / Nav · Tap to select, drag to pan');
    }
  } else if (tool === 'bend') {
    setStatusHint('Tool: Bend · Drag a line segment to bend · Auto/Finish controls commit');
  } else if (tool === 'quickVerify') {
    setStatusHint('Tool: Quick Verify · Tap start, then end. Third tap starts a new check.');
  } else if (tool === 'measure') {
    setStatusHint('Tool: Measure · Tap start, then end point.');
  } else if (tool === 'road' || tool === 'lane') {
    const styleName = lineStyleLabelText(state.lineStyle);
    if (state.autoCommitLine) {
      setStatusHint(`Tool: Line Tool · ${styleName} · Tap start, then end (auto-commit)`);
    } else {
      setStatusHint(`Tool: Line Tool · ${styleName} · Tap to add points, “Finish path” to end`);
    }
  } else if (tool === 'area') {
    setStatusHint('Tool: Area region · Tap corners, “Finish path” to close');
  } else if (tool === 'symbol') {
    try{
      if (symbolSelect){
        const want = String(state.lastSymbolType || '');
        let has = false;
        if (want){
          for (const o of symbolSelect.options){ if (o && String(o.value)===want){ has = true; break; } }
        }
        symbolSelect.value = (has ? want : '');
      }
    }catch(_){}
    if (symbolSelect && !String(symbolSelect.value||'')){
      setStatusHint('Tool: Symbol · Choose a symbol in the dropdown, then tap to place');
    } else {
      setStatusHint('Tool: Symbol · Tap to place symbol');
    }
  } else if (tool === 'label') {
    setStatusHint('Tool: Label · Tap to place label');
  } else if (tool === 'erase') {
    setStatusHint('Tool: Erase · Tap a feature to delete');
  } else if (tool === 'freeDraw') {
    setStatusHint('Tool: Sketch · Drag to draw (points-only)');
  } else if (tool === 'rect') {
    setStatusHint('Tool: Rectangle (Area) · Drag to size · Auto/Finish controls commit');
  } else if (tool === 'circle') {
    setStatusHint('Tool: Circle (Area) · Drag to set radius · Auto/Finish controls commit');
  } else if (tool === 'rectLine') {
    setStatusHint('Tool: Rectangle (Lines) · Drag to size · Auto/Finish controls commit');
  } else if (tool === 'circleLine') {
    setStatusHint('Tool: Circle (Lines) · Drag to set radius · Auto/Finish controls commit');
  }

  setModeLabel();
  
        try{ syncTopbarEditUI(); }catch(_){ }
    try{ updateContextHighlights(); }catch(_){ }
    draw();
}

// SUB-CHUNK 10.B1 END — Bend edit-mode routing (safe-edit boundary)
// --- chunk end 10.2 ---------------------------------------------------------------

// --- chunk 10.3 · Feature selection helper -------------------------------------------
function isSelectedId(id){
  if (id == null) return false;
  if (state.multiSelectEnabled && Array.isArray(state.selectedIds)) {
    return state.selectedIds.indexOf(id) !== -1;
  }
  return state.selectedId === id;
}

function _setSelectionSingle(id){
  state.selectedId = (id == null) ? null : id;
  state.selectedIds = (id == null) ? [] : [id];
}

function _setSelectionMulti(ids, primaryId){
  const clean = Array.isArray(ids) ? ids.filter(x=>x!=null) : [];
  // de-dupe while preserving order
  const out = [];
  for (const x of clean){ if (out.indexOf(x)===-1) out.push(x); }
  state.selectedIds = out;
  state.selectedId = (primaryId != null) ? primaryId : (out.length ? out[out.length-1] : null);
}

function selectFeatureById(id){
  _setSelectionSingle(id);
  updateFeatureSelect();
  refreshSelectedInspector();
  try{ if (typeof window.refreshMeasureDefaultsPanel === 'function') window.refreshMeasureDefaultsPanel(); }catch(_){ }
  if (window.__fc_applyAreaPanelUI) window.__fc_applyAreaPanelUI();
  draw();
}

function toggleMultiSelectHit(id){
  if (id == null){
    _setSelectionMulti([], null);
    updateFeatureSelect();
    refreshSelectedInspector();
    try{ if (typeof window.refreshMeasureDefaultsPanel === 'function') window.refreshMeasureDefaultsPanel(); }catch(_){ }
  if (window.__fc_applyAreaPanelUI) window.__fc_applyAreaPanelUI();
    draw();
    return;
  }
  const ids = Array.isArray(state.selectedIds) ? state.selectedIds.slice() : [];
  const ix = ids.indexOf(id);
  if (ix >= 0){
    ids.splice(ix,1);
    const newPrimary = (state.selectedId === id) ? (ids.length ? ids[ids.length-1] : null) : state.selectedId;
    _setSelectionMulti(ids, newPrimary);
  } else {
    ids.push(id);
    _setSelectionMulti(ids, id);
  }
  updateFeatureSelect();
  refreshSelectedInspector();
  draw();
}

// --- MOVE POINT ------------------------------------------------------
// --- chunk 10.4 · Edit operations (move point / add / remove / cutout) --------------- 
function handleMovePointTap(xPx,yPx){
  const world = canvasToWorld(xPx,yPx);

  // Step 1: choose which vertex to move
  if (!movePointSelection) {
    const hitInfo = hitTestFeature(xPx,yPx);
    const hit = hitInfo && hitInfo.feature;
    if (!hit ||
        !hit.points ||
        !hit.points.length ||
        (hit.type!=='road' && hit.type!=='lane' &&
         hit.type!=='area' && hit.type!=='measure'))
      return;

    // Measure label move: if tap is near the measurement label, move the label instead of a vertex.
    if (hit.type === 'measure') {
      try{
        let txM = (Number.isFinite(hit.txM) ? hit.txM : NaN);
        let tyM = (Number.isFinite(hit.tyM) ? hit.tyM : NaN);
        if (!Number.isFinite(txM) || !Number.isFinite(tyM)) {
          const d = _defaultMeasureLabelPos(hit.points || []);
          txM = d.xM; tyM = d.yM;
        }
        const t = worldToCanvas({xM:txM,yM:tyM});
        const dxp = (xPx - t.xPx);
        const dyp = (yPx - t.yPx);
        if ((dxp*dxp + dyp*dyp) <= (12*12)) {
          movePointSelection = { featureId: hit.id, ring: 'label', holeIndex: null, pointIndex: null };
          selectFeatureById(hit.id);
          setStatusHint('Edit: Move measure label · Tap new location.');
          return;
        }
      }catch(_){}
    }

    if (hit.type === 'area') {
      const best = pickNearestVertexOnArea(hit,xPx,yPx);
      if (!best) return;
      movePointSelection = {
        featureId: hit.id,
        ring: best.ring,
        holeIndex: best.holeIndex,
        pointIndex: best.index
      };
    } else {
      // simple polyline
      let bestIdx = 0;
      let bestD2 = Infinity;
      hit.points.forEach((p,idx)=>{
        const c=worldToCanvas(p);
        const dx=xPx-c.xPx, dy=yPx-c.yPx;
        const d2=dx*dx+dy*dy;
        if(d2<bestD2){ bestD2=d2; bestIdx=idx; }
      });
      movePointSelection = {
        featureId: hit.id,
        ring: 'outer',
        holeIndex: null,
        pointIndex: bestIdx
      };
    }

    selectFeatureById(hit.id);
    setStatusHint('Edit: Move point · Tap new location.');
    return;
  }

  // Step 2: move it
  const sel = movePointSelection;
  const f = state.features.find(x=>x.id===sel.featureId);
  if (!f) {
    movePointSelection = null;
    // Stay in Move point mode; return to Step 1 (pick vertex)
    try { setStatusHint('Edit: Move point · Tap a vertex.'); } catch(_) {}
    return;
  }

  const _sel = _getSelectedFeature ? _getSelectedFeature() : null;

  if (_sel && _isFeatureLocked(_sel)) { _denyLockedEdit('move', _sel); return; }

  pushHistory('movePoint');

  if (f.type === 'area') {
    if (sel.ring === 'outer') {
      if (f.points && f.points[sel.pointIndex]) {
        f.points[sel.pointIndex] = {xM:world.xM,yM:world.yM};
      }
    } else if (sel.ring === 'label') {
    f.txM = world.xM;
    f.tyM = world.yM;
  } else if (sel.ring === 'hole') {
      if (f.holes &&
          f.holes[sel.holeIndex] &&
          f.holes[sel.holeIndex][sel.pointIndex]) {
        f.holes[sel.holeIndex][sel.pointIndex] = {xM:world.xM,yM:world.yM};
      }
    }
    f.areaM2 = areaWithHoles(f);
  } else {
    if (f.points && f.points[sel.pointIndex]) {
      f.points[sel.pointIndex] = {xM:world.xM,yM:world.yM};
    }
  }

  // Keep measure derived fields truthful when vertices move
  if (f && f.type === 'measure') {
    try{
      const pts = f.points || [];
      if (pts.length >= 2) {
        f.length = lineLengthMeters(pts);
        const dx = pts[1].xM - pts[0].xM;
        const dy = pts[1].yM - pts[0].yM;
        f.angleDeg = Math.atan2(dy,dx)*180/Math.PI;
        // If label has never been placed, seed it once
        if (!Number.isFinite(f.txM) || !Number.isFinite(f.tyM)) {
          const d = _defaultMeasureLabelPos(pts);
          f.txM = d.xM; f.tyM = d.yM;
        }
      }
    }catch(_){ }
  }

  movePointSelection = null;
  // Stay in Move point mode; return to Step 1 (pick vertex)
  try { setStatusHint('Edit: Move point · Tap a vertex.'); } catch(_) {}
  updateFeatureSelect();
  refreshSelectedInspector();
  draw();
}

// --- ADD VERTEX ------------------------------------------------------

function handleAddVertexTap(xPx,yPx){
  const world = canvasToWorld(xPx,yPx);
  const hitInfo = hitTestFeature(xPx,yPx);
  const hit = hitInfo && hitInfo.feature;
  if (!hit || !hit.points || hit.points.length < 2) return;

  const _sel = _getSelectedFeature ? _getSelectedFeature() : null;

  if (_sel && _isFeatureLocked(_sel)) { _denyLockedEdit('edit', _sel); return; }

  pushHistory('addVertex');

  const idx = findNearestSegmentIndex(hit.points,xPx,yPx);
  if (idx == null) return;

  hit.points.splice(idx+1, 0, {xM:world.xM,yM:world.yM});
  if (hit.type === 'area') hit.areaM2 = areaWithHoles(hit);

  // Transient visual proof: flash where the vertex was inserted (no schema changes)
  try{
    if (!state._editMarks) state._editMarks = {};
    state._editMarks.last = { kind:'addVertex', xM:world.xM, yM:world.yM, ts: Date.now(), featureId: hit.id, segIndex: idx };
  }catch(_){}

  selectFeatureById(hit.id);
  draw();
}

// --- REMOVE VERTEX ---------------------------------------------------

function handleRemoveVertexTap(xPx,yPx){
  const hitInfo = hitTestFeature(xPx,yPx);
  const hit = hitInfo && hitInfo.feature;
  if (!hit || !hit.points || hit.points.length < 2) return;

  const _sel = _getSelectedFeature ? _getSelectedFeature() : null;

  if (_sel && _isFeatureLocked(_sel)) { _denyLockedEdit('edit', _sel); return; }

  pushHistory('removeVertex');

  if (hit.type === 'road' || hit.type === 'lane' || hit.type === 'measure') {
    // remove nearest vertex, but keep ≥2 points
    let bestIdx=0,bestD2=Infinity;
    hit.points.forEach((p,idx)=>{
      const c=worldToCanvas(p);
      const dx=xPx-c.xPx,dy=yPx-c.yPx;
      const d2=dx*dx+dy*dy;
      if(d2<bestD2){ bestD2=d2; bestIdx=idx; }
    });
    if (hit.points.length > 2) {
      hit.points.splice(bestIdx,1);
    }
  } else if (hit.type === 'area') {
    const best = pickNearestVertexOnArea(hit,xPx,yPx);
    if (!best) return;

    if (best.ring === 'outer') {
      if ((hit.points||[]).length <= 3) return;
      hit.points.splice(best.index,1);
    } else if (best.ring === 'hole') {
      const ring = hit.holes[best.holeIndex];
      if (!ring || ring.length <= 3) return;
      ring.splice(best.index,1);
    }
    hit.areaM2 = areaWithHoles(hit);
  }

  selectFeatureById(hit.id);
  draw();
}
function handleSplitLineTap(xPx,yPx){
  // Split a selected polyline/line into two independent line features.
  const hitInfo = hitTestFeature(xPx,yPx);
  const hit = hitInfo && hitInfo.feature;

  // Require a line-like feature with points (not area)
  if (!hit || !hit.points || hit.points.length < 2 || hit.type === 'area') {
    setStatus('Split line: tap a line to select it.');
    return;
  }

  // If tapping a different feature than selection, just select it first
  if (state.selectedId !== hit.id) {
    selectFeatureById(hit.id);
    setStatus('Split line: line selected. Tap on the line to choose a split point.');
    return;
  }

  // Locked edit protection (match other edit tools)
  const _sel = _getSelectedFeature ? _getSelectedFeature() : null;
  if (_sel && _isFeatureLocked && _isFeatureLocked(_sel)) { _denyLockedEdit('edit', _sel); return; }

  // Find nearest segment + projection
  const pts = hit.points;
  let best = { segIndex: null, t: 0, dist2: Infinity };
  for (let i=0;i<pts.length-1;i++){
    const aC = worldToCanvas(pts[i]);
    const bC = worldToCanvas(pts[i+1]);
    const dx = bC.xPx - aC.xPx;
    const dy = bC.yPx - aC.yPx;
    const len2 = dx*dx + dy*dy;
    if (!len2) continue;
    const t = ((xPx - aC.xPx)*dx + (yPx - aC.yPx)*dy) / len2;
    if (t < 0 || t > 1) continue;
    const projX = aC.xPx + t*dx;
    const projY = aC.yPx + t*dy;
    const d2 = (xPx - projX)**2 + (yPx - projY)**2;
    if (d2 < best.dist2){
      best = { segIndex: i, t, dist2: d2 };
    }
  }

  // Too far from any segment → no split
  const PICK_PX = 14;
  if (best.segIndex == null || best.dist2 > PICK_PX*PICK_PX){
    setStatus('Split line: tap on the selected line to choose a split point.');
    return;
  }

  // Determine split point: reuse existing vertex if very close
  const VERT_PX = 10;
  let useIndex = null;
  let bestV2 = Infinity;
  for (let i=0;i<pts.length;i++){
    const c = worldToCanvas(pts[i]);
    const d2 = (xPx - c.xPx)**2 + (yPx - c.yPx)**2;
    if (d2 < bestV2){
      bestV2 = d2;
      useIndex = i;
    }
  }

  let pointsForSplit = pts.slice();
  let splitIndex = useIndex;

  if (bestV2 > VERT_PX*VERT_PX){
    // Insert a new vertex at the projected point on the chosen segment
    const aW = pts[best.segIndex];
    const bW = pts[best.segIndex+1];
    const t = best.t;
    const pW = {
      xM: aW.xM + (bW.xM - aW.xM) * t,
      yM: aW.yM + (bW.yM - aW.yM) * t
    };
    splitIndex = best.segIndex + 1;
    pointsForSplit.splice(splitIndex, 0, pW);
  }

  // Disallow endpoint splits (would create a zero-length part)
  if (splitIndex <= 0 || splitIndex >= pointsForSplit.length-1){
    setStatus('Split line: choose a point along the line (not an endpoint).');
    return;
  }

  pushHistory('splitLine');

  const idx = state.features.findIndex(f => f.id === hit.id);
  if (idx < 0) return;

  const base = { ...hit };
  // Ensure we don't share point array references
  const partA = { ...base, id: state.nextId++, points: deepClone(pointsForSplit.slice(0, splitIndex+1)) };
  const partB = { ...base, id: state.nextId++, points: deepClone(pointsForSplit.slice(splitIndex)) };

  // Replace original with A + B at same z-order position
  state.features.splice(idx, 1, partA, partB);

  // Keep selection on the first piece for predictable follow-up grouping
  selectFeatureById(partA.id);
  draw();
  setStatus('Split line: created two lines.');
}

// --- CUT-OUT (SUBTRACT INNER AREA FROM OUTER) -------------------------

function handleCutoutTap(xPx,yPx){
  if (cutoutOuterId == null) return;

  const hitInfo = hitTestFeature(xPx,yPx);
  const hit = hitInfo && hitInfo.feature;

  if (!hit || hit.type !== 'area') {
    setStatusHint('Cut-out: tap an inner area region.');
    return;
  }

  if (hit.id === cutoutOuterId) {
    setStatusHint('Cut-out: select a DIFFERENT area inside the outer one.');
    return;
  }

  const outer = state.features.find(f=>f.id === cutoutOuterId);
  const inner = state.features.find(f=>f.id === hit.id);
  if (!outer || !inner) {
    setEditMode('none');
    return;
  }

  const _sel = _getSelectedFeature ? _getSelectedFeature() : null;

  if (_sel && _isFeatureLocked(_sel)) { _denyLockedEdit('cutout', _sel); return; }

  pushHistory('cutout');

  if (!Array.isArray(outer.holes)) outer.holes = [];

  // Copy inner polygon as hole
  const innerPoly = (inner.points || []).map(
    p => ({ xM: p.xM, yM: p.yM })
  );

  if (innerPoly.length >= 3) {
    // Truth-guards: prevent corrupt / inverted cutouts that would zero-out or break picking.
    const outerA = polygonAreaMeters2(outer.points || []);
    const holeA  = polygonAreaMeters2(innerPoly);

    // Basic sanity: hole must be smaller than outer by a clear margin.
    // (If not, reject rather than poisoning the feature into an unselectable 0-area state.)
    if (outerA <= 0 || holeA <= 0 || holeA >= outerA * 0.98) {
      setStatusHint('Cut-out failed: inner area must be smaller than the outer area.');
      setEditMode('none');
      return;
    }

    // Containment sanity: require the hole's vertices to be inside the outer polygon.
    // (Avoid cases where mismatched coordinate space / selection bugs create invalid holes.)
    const _pipWorld = (pt, poly)=>{
      let inside=false;
      for(let i=0,j=poly.length-1;i<poly.length;j=i++){
        const xi=poly[i].xM, yi=poly[i].yM;
        const xj=poly[j].xM, yj=poly[j].yM;
        const intersect = ((yi>pt.yM)!==(yj>pt.yM)) && (pt.xM < (xj-xi)*(pt.yM-yi)/(yj-yi+1e-12) + xi);
        if(intersect) inside=!inside;
      }
      return inside;
    };
    const outerPoly = outer.points || [];
    const allInside = innerPoly.every(p => _pipWorld(p, outerPoly));
    if (!allInside) {
      setStatusHint('Cut-out failed: inner area must be fully inside the outer area.');
      setEditMode('none');
      return;
    }

    outer.holes.push(innerPoly);
    outer.areaM2 = areaWithHoles(outer);
  }

  // Remove the inner area feature completely
  state.features = state.features.filter(f => f.id !== inner.id);

  selectFeatureById(outer.id);
  setEditMode('none');
  updateFeatureSelect();
  refreshSelectedInspector();
  draw();

  // Units-aware status message
  const areaDisp = areaDisplayValue(outer.areaM2);
  setStatusHint('Cut-out applied · New area: ' + fmtNum(areaDisp, 1) + ' ' + unitLabelArea());
}

// --- Inspect click routing -------------------------------------------

// --- GROUPING HANDLERS (armed modes) --------------------------------------------
function handleGroupAddTap(xPx,yPx){
  const sel = state.features.find(x=>x.id===state.selectedId);
  if(!sel){ setStatusHint('Add to group: select an object in a group first.'); return; }
  const base = getBaseGroupId(sel);
  if(!base){
    // user chose Add but has no base group yet; prompt via Properties.
    setStatusHint('Add to group: set a base Group name in Properties, then tap objects.');
    return;
  }
  const hitInfo = hitTestFeature(xPx,yPx);
  const tgt = hitInfo && hitInfo.feature;
  if(!tgt) return;
  if(tgt.id === sel.id) return;

  const tgtBase = getBaseGroupId(tgt);
  if(!tgtBase){
    pushHistory('groupAdd');
    tgt.groupId = base;
    delete tgt.groupAuthorityId;
    setStatusHint('Added to group '+base+'.');
    draw();
    return;
  }
  if(tgtBase === base){
    setStatusHint('Already in group '+base+'.');
    return;
  }
  // Target is in another group: offer combine.
  const okCombine = confirm('Target is already in group "'+tgtBase+'". Combine groups under authority "'+base+'"?');
  if(!okCombine){
    setStatusHint('Add to group: cancelled.');
    return;
  }
  pushHistory('combineGroups');
  applyAuthorityOverlay(base, base, tgtBase);
  setStatusHint('Combined groups under authority '+base+' (base groups preserved).');
  draw();
}

function handleGroupRemoveTap(xPx,yPx){
  const sel = state.features.find(x=>x.id===state.selectedId);
  if(!sel){ setStatusHint('Remove from group: select an object in a group first.'); return; }
  const eff = getEffectiveGroupId(sel);
  if(!eff){ setStatusHint('Remove from group: selected object is not in a group.'); return; }

  const hitInfo = hitTestFeature(xPx,yPx);
  const tgt = hitInfo && hitInfo.feature;
  if(!tgt) return;

  const tgtEff = getEffectiveGroupId(tgt);
  if(tgtEff !== eff){
    setStatusHint('Remove from group: target is not in this group.');
    return;
  }
  pushHistory('groupRemove');
  delete tgt.groupId;
  delete tgt.groupAuthorityId;
  setStatusHint('Removed from group '+eff+'.');
  draw();
}

function handleGroupCombineTap(xPx,yPx){
  const sel = state.features.find(x=>x.id===state.selectedId);
  if(!sel){ setStatusHint('Combine groups: select an object in a group first.'); return; }
  const base = getBaseGroupId(sel);
  if(!base){
    setStatusHint('Combine groups: set a base Group name in Properties, then tap an object in another group.');
    return;
  }
  const hitInfo = hitTestFeature(xPx,yPx);
  const tgt = hitInfo && hitInfo.feature;
  if(!tgt) return;
  const tgtBase = getBaseGroupId(tgt);
  if(!tgtBase){
    setStatusHint('Combine groups: target is not in a group.');
    return;
  }
  if(tgtBase === base){
    setStatusHint('Combine groups: target already in same base group.');
    return;
  }
  const okCombine = confirm('Target is in group "'+tgtBase+'". Combine under authority "'+base+'"?');
  if(!okCombine){
    setStatusHint('Combine groups: cancelled.');
    return;
  }
  pushHistory('combineGroups');
  applyAuthorityOverlay(base, base, tgtBase);
  setStatusHint('Combined groups under authority '+base+' (base groups preserved).');
  draw();
}
function handleInspectClickAt(xPx,yPx){
  if (state.tool === 'inspect') {
    if (state.editMode === 'pastePlace') {
      try {
        if (!_fdClipboard || !_fdClipboard.feats || !_fdClipboard.feats.length){
          setStatusHint('Paste: clipboard empty.');
          setEditMode('none');
          return;
        }
        // Re-check locked rule at commit time (truth: place step is the edit).
        const locked = _fdClipboard.feats.find(f => _isFeatureLocked(f));
        if (locked) { _denyLockedEdit('paste', locked); setStatusHint('Paste blocked: layer is locked.'); setEditMode('none'); return; }

        const w = canvasToWorld(xPx, yPx);
        const dx = (w.xM - (_fdPastePlace.anchor && isFinite(_fdPastePlace.anchor.xM) ? _fdPastePlace.anchor.xM : 0));
        const dy = (w.yM - (_fdPastePlace.anchor && isFinite(_fdPastePlace.anchor.yM) ? _fdPastePlace.anchor.yM : 0));

        pushHistory('paste');

        const newIds = [];
        for (const src of _fdClipboard.feats){
          const clone = deepClone(src);
          clone.id = state.nextId++;
          clone.groupId = null;
          clone.groupAuthorityId = null;

          _applyPointTransformToFeature(clone, (xM,yM)=>({xM: xM + dx, yM: yM + dy}));

          if (clone.type === 'area'){
            try { clone.areaM2 = areaWithHoles(clone); } catch(_) {}
          }

          state.features.push(clone);
          newIds.push(clone.id);
        }

        // Select pasted
        if (newIds.length){
          state.multiSelectEnabled = newIds.length > 1;
          if (newIds.length > 1){
            _setSelectionMulti(newIds, newIds[0]);
          } else {
            _setSelectionSingle(newIds[0]);
          }
        }

        updateFeatureSelect();
        refreshSelectedInspector();
        draw();
        setStatusHint(`Pasted ${newIds.length} item${newIds.length===1?'':'s'} at location.`);
      } catch(e) {
        try { console.error(e); } catch(_) {}
        setStatusHint('Paste failed: ' + (e && e.message ? e.message : 'unknown error'));
      }
      try { setEditMode('none'); } catch(_) {}
      return;
    }
    if (state.editMode === 'movePoint') {
      handleMovePointTap(xPx,yPx);
      return;
    }
    if (state.editMode === 'addVertex') {
      handleAddVertexTap(xPx,yPx);
      return;
    }
    if (state.editMode === 'removeVertex') {
      handleRemoveVertexTap(xPx,yPx);
      return;
    }
    if (state.editMode === 'splitLine') {
      handleSplitLineTap(xPx,yPx);
      return;
    }
    if (state.editMode === 'cutout') {
      handleCutoutTap(xPx,yPx);
      return;
    }
    if (state.editMode === 'groupAdd') {
      handleGroupAddTap(xPx,yPx);
      return;
    }
    if (state.editMode === 'groupRemove') {
      handleGroupRemoveTap(xPx,yPx);
      return;
    }
    if (state.editMode === 'groupCombine') {
      handleGroupCombineTap(xPx,yPx);
      return;
    }
  }

  const hitInfo = hitTestFeature(xPx,yPx);
  const hit = hitInfo && hitInfo.feature;
  const hitId = hit ? hit.id : null;

  // Multi-select only applies in pure Inspect (no edit mode armed)
  if (state.multiSelectEnabled && state.tool === 'inspect' && (!state.editMode || state.editMode === 'none')) {
    toggleMultiSelectHit(hitId);
    return;
  }

  if (hitId != null) {
    selectFeatureById(hitId);
  } else {
    selectFeatureById(null);
  }
}
  // --- SUB-CHUNK 10.R1 END — Inspect/nav/move-shape/edit routing ---

// --- chunk end 10 ---------------------------------------------------------------

  // SCRIPT PART 1 END (LLM ANCHOR)

  // SCRIPT PART 1.3 END (LLM ANCHOR)
</script>

<script>

  // SCRIPT PART 2.1 BEGIN (LLM ANCHOR)

// --- FIELD DRAFT v1.0 · SCRIPT PART 2 · INTERACTION + SAVE/LOAD ---------

  // --- Interaction: mouse & touch chunk 11 -------------------------------------------
// SUB-CHUNK 11.B1 BEGIN — Bend pointer lifecycle hooks (safe-edit boundary)
// --- chunk 11.1 · Pointer helpers & canvasDown routing ------------------------------ 

  function getCanvasPos(evt){
    const r=canvas.getBoundingClientRect();
    const cx=evt.touches?evt.touches[0].clientX:evt.clientX;
    const cy=evt.touches?evt.touches[0].clientY:evt.clientY;
    return{ xPx:cx-r.left, yPx:cy-r.top };
  }

  // --- Bend helpers (segment pick + preview + commit) --------------------------------
  function isLineLikeFeature(f){
    return f && (f.type === 'road' || f.type === 'lane') && Array.isArray(f.points) && f.points.length >= 2;
  }

  function getSegmentNormalUnit(a, b){
    const dx = (b.xM - a.xM);
    const dy = (b.yM - a.yM);
    const len = Math.hypot(dx, dy) || 1;
    // Left-hand normal (-dy, dx)
    return { xM: (-dy) / len, yM: (dx) / len };
  }

  function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }

  function buildQuadraticBezierPoints(a, b, bulgeM, samples, grabT){
    // Quadratic Bézier bulge along segment a->b.
    // By default the control point is anchored at the segment midpoint (grabT=0.5),
    // but Bend can pass a user-picked grabT (0..1) to create asymmetric bends.
    const t0 = (typeof grabT === 'number' && Number.isFinite(grabT)) ? clamp(grabT, 0, 1) : 0.5;

    // Anchor point along the segment where the bulge is applied
    const base = { xM: a.xM + (b.xM - a.xM) * t0, yM: a.yM + (b.yM - a.yM) * t0 };

    const n = getSegmentNormalUnit(a, b);
    const c = { xM: base.xM + n.xM * bulgeM, yM: base.yM + n.yM * bulgeM };

    const out = [];
    const N = Math.max(6, Math.min(64, samples || 18));
    for (let i=0; i<=N; i++){
      const t = i / N;
      const mt = 1 - t;
      const xM = (mt*mt)*a.xM + (2*mt*t)*c.xM + (t*t)*b.xM;
      const yM = (mt*mt)*a.yM + (2*mt*t)*c.yM + (t*t)*b.yM;
      out.push({ xM, yM });
    }
    return out;
  }

  function spliceSegmentWithCurvePoints(basePoints, segIndex, curvePts){
    // Replace segment [segIndex -> segIndex+1] with curvePts, avoiding duplicate endpoints.
    const head = basePoints.slice(0, segIndex);
    const tail = basePoints.slice(segIndex+2);
    const curve = (curvePts || []).slice();
    if (curve.length >= 2){
      // Ensure we don't duplicate junctions
      const a = basePoints[segIndex];
      const b = basePoints[segIndex+1];
      curve[0] = { xM: a.xM, yM: a.yM };
      curve[curve.length-1] = { xM: b.xM, yM: b.yM };
    }
    return head.concat(curve, tail);
  }

  function cancelBendSession(reason){
    if (!state || !state.bend) return;
    state.bend.active = false;
    state.bend.pending = false;
    state.bend.featureIndex = null;
    state.bend.segIndex = null;
    state.bend.isClosedRing = false;
    state.bend.basePoints = null;
    state.bend.startWorld = null;
    state.bend.grabT = 0.5;
    state.bend.startGrabT = 0.5;
    state.bend.a = null;
    state.bend.b = null;
    state.bend.n = null;
    state.bend.bulgeM = 0;
    state.bend.startBulgeM = 0;
    state.bend.previewPointsFull = null;

    // Clear preview overlay
    if (state.currentPath && state.currentPath.__bendPreview) state.currentPath = null;

    // Ensure freeCapture gate is not left armed
    if (state.freeCapture && state.freeCapture.active && state.freeCapture.mode === 'bend') {
      state.freeCapture.active = false;
      state.freeCapture.mode = null;
    }

    try { if (statusHint) statusHint.textContent = ''; } catch(_) {}
    try { draw(); } catch(_) {}
  }

  function commitBendSession(reason){
    if (!state || !state.bend) return false;
    const b = state.bend;
    if (!b.previewPointsFull || b.featureIndex == null) return false;
    const f = state.features && state.features[b.featureIndex];
    if (!f || (!isLineLikeFeature(f) && f.type !== 'area')) return false;

    const _sel = _getSelectedFeature ? _getSelectedFeature() : null;
    if (_sel && _isFeatureLocked(_sel)) { _denyLockedEdit('bend', _sel); return; }

    pushHistory('bend');

    // Commit into the correct geometry container
    if (f.type === 'area' && b.ringType === 'hole' && b.holeIndex != null && Array.isArray(f.holes) && f.holes[b.holeIndex]) {
      f.holes[b.holeIndex] = b.previewPointsFull.slice();
      // keep area value truthful after hole edit
      try { f.areaM2 = areaWithHoles(f); } catch(_) {}
    } else {
      f.points = b.previewPointsFull.slice();
      if (f.type === 'area') {
        try { f.areaM2 = areaWithHoles(f); } catch(_) {}
      }
    }

    // clear
    cancelBendSession(reason || 'bendCommit');

    updateFeatureSelect();
    refreshSelectedInspector();
    setModeLabel();
    draw();
    return true;
  }

  function beginBendAtCanvas(xPx, yPx){
    // pick nearest line-like feature + segment within a px threshold
    const thresholdPx = 14;
    let best = null;

    // helper: test a closed ring (area outer or hole ring)
    function _considerRing(i, ringPoints, ringType, holeIndex){
      const pts = ringPoints || [];
      if (pts.length < 2) return;
      const segIdx = findNearestSegmentIndexClosed(pts, xPx, yPx);
      if (segIdx == null) return;

      const aC = worldToCanvas(pts[segIdx]);
      const bC = worldToCanvas(pts[(segIdx+1)%pts.length]);

      const dx = bC.xPx - aC.xPx;
      const dy = bC.yPx - aC.yPx;
      const len2 = dx*dx + dy*dy;
      if (!len2) return;

      const t = ((xPx - aC.xPx)*dx + (yPx - aC.yPx)*dy)/len2;
      const tt = clamp(t, 0, 1);
      const projX = aC.xPx + tt*dx;
      const projY = aC.yPx + tt*dy;
      const d2 = (xPx - projX)*(xPx - projX) + (yPx - projY)*(yPx - projY);
      if (d2 > thresholdPx*thresholdPx) return;

      if (!best || d2 < best.d2) best = { featureIndex:i, segIndex:segIdx, d2, ringType:ringType || 'outer', holeIndex: (holeIndex==null? null: holeIndex) };
    }

    for (let i=0;i<state.features.length;i++){
      const f = state.features[i];
      const isArea = !!(f && f.type === 'area');

      if (isArea){
        // Outer ring
        _considerRing(i, f.points || [], 'outer', null);

        // Hole rings (bendable too: click near the hole boundary)
        if (Array.isArray(f.holes)){
          for (let h=0; h<f.holes.length; h++){
            const ring = f.holes[h];
            if (!ring || ring.length < 2) continue;
            _considerRing(i, ring, 'hole', h);
          }
        }
        continue;
      }

      // Lines / polylines
      if (!isLineLikeFeature(f)) continue;
      const pts = f.points || [];
      const segIdx = findNearestSegmentIndex(pts, xPx, yPx);
      if (segIdx == null) continue;

      const aC = worldToCanvas(pts[segIdx]);
      const bC = worldToCanvas(pts[segIdx+1]);

      const dx = bC.xPx - aC.xPx;
      const dy = bC.yPx - aC.yPx;
      const len2 = dx*dx + dy*dy;
      if (!len2) continue;

      const t = ((xPx - aC.xPx)*dx + (yPx - aC.yPx)*dy)/len2;
      const tt = clamp(t, 0, 1);
      const projX = aC.xPx + tt*dx;
      const projY = aC.yPx + tt*dy;
      const d2 = (xPx - projX)*(xPx - projX) + (yPx - projY)*(yPx - projY);
      if (d2 > thresholdPx*thresholdPx) continue;

      if (!best || d2 < best.d2) best = { featureIndex:i, segIndex:segIdx, d2, ringType:null, holeIndex:null };
    }

    if (!best) {
      try { statusHint.textContent = 'Bend: no line/area edge hit'; } catch(_) {}
      return false;
    }

    const f = state.features[best.featureIndex];
    const isArea = !!(f && f.type === 'area');

    // Determine which point array we're bending
    let base = null;
    if (isArea && best.ringType === 'hole' && Array.isArray(f.holes) && f.holes[best.holeIndex]) {
      base = (f.holes[best.holeIndex] || []).slice();
    } else {
      base = (f.points || []).slice();
      best.ringType = isArea ? 'outer' : null;
      best.holeIndex = null;
    }

    const a = base[best.segIndex];
    const bpt = (isArea ? base[(best.segIndex+1)%base.length] : base[best.segIndex+1]);

    // Arm bend session
    state.bend.active = true;
    state.bend.pending = false;
    state.bend.featureIndex = best.featureIndex;
    state.bend.segIndex = best.segIndex;
    state.bend.isClosedRing = !!isArea; // both outer and hole rings are closed
    state.bend.basePoints = base;
    state.bend.a = { xM: a.xM, yM: a.yM };
    state.bend.b = { xM: bpt.xM, yM: bpt.yM };
    state.bend.n = getSegmentNormalUnit(state.bend.a, state.bend.b);
    state.bend.bulgeM = 0;
    state.bend.startBulgeM = 0;

    // Anchor: startWorld at the current cursor (world)
    const world = canvasToWorldRawMouse(xPx, yPx);
    state.bend.startWorld = { xM: world.xM, yM: world.yM };
    // Capture where along the segment the user grabbed (0..1). This enables asymmetric bends.
    (function(){
      const ax = state.bend.a.xM, ay = state.bend.a.yM;
      const bx = state.bend.b.xM, by = state.bend.b.yM;
      const vx = bx - ax, vy = by - ay;
      const len2 = vx*vx + vy*vy;
      let t = 0.5;
      if (len2 > 1e-12){
        t = ((world.xM - ax)*vx + (world.yM - ay)*vy) / len2;
      }
      const tt = clamp(t, 0, 1);
      state.bend.grabT = tt;
      state.bend.startGrabT = tt;
    })();

    // identify target ring for commit
    state.bend.ringType = best.ringType;
    state.bend.holeIndex = best.holeIndex;

    // Use freeCapture lifecycle to reuse mouse/touch up commit gates (no new listeners).
    if (!state.freeCapture) state.freeCapture = { active:false };
    if (state.freeCapture) {
      state.freeCapture.active = true;
      state.freeCapture.mode = 'bend';
      state.freeCapture.lastXM = null;
      state.freeCapture.lastYM = null;
    }

    try {
      const targetLabel = (best.ringType === 'hole') ? 'hole edge' : (isArea ? 'area edge' : 'line');
      statusHint.textContent = state.autoCommitLine ? ('Bend: ' + targetLabel + ' · release commits (Auto)') : ('Bend: ' + targetLabel + ' · Finish to commit');
    } catch(_) {}
    return true;
  }

  // --- sub-chunk 11.6S · Shape capture (Rect/Circle) — drag-generate preview then Finish/Auto ----------
  // Design:
  // - Shapes are "drawing tools" (Draw ▾ dropdown).
  // - Shapes do NOT require pre-existing objects.
  // - Drag generates a preview polygon in state.currentPath (type:'area').
  // - On release: Auto commits immediately; Manual holds preview for Finish.
  // - This intentionally mirrors the Bend gesture lifecycle, but commits via the canonical commitCurrentPath() pipe.

  function beginShapeAtCanvas(xPx, yPx){
    if (!(state.tool === 'rect' || state.tool === 'circle' || state.tool === 'rectLine' || state.tool === 'circleLine')) return false;
    // Manual adjust: if a shape preview already exists, allow re-drag to resize until Finish
    if (!state.autoCommitLine && state.currentPath && state.currentPath.__shapePreview && state.freeCapture && state.freeCapture.mode === 'shape_hold' && state.freeCapture.shapeStart && state.freeCapture.shapeType === state.tool){
      state.freeCapture.active = true;
      state.freeCapture.mode = 'shape';
      // keep the original anchor (shapeStart); just start updating from the new pointer
      state.freeCapture.lastXpx = xPx;
      state.freeCapture.lastYpx = yPx;
      updateShapePreviewAt(xPx, yPx, false);
      try { statusHint.textContent = 'Shape: adjust · Finish to commit'; } catch(_) {}
      return true;
    }

    // Disarm any existing capture first
    if (!state.freeCapture) state.freeCapture = { active:false };
    state.freeCapture.active = true;
    state.freeCapture.mode = 'shape';
    state.freeCapture.shapeType = state.tool;

    // Anchor uses normal snap rules (matches other tools)
    const start = canvasToWorld(xPx, yPx); // snap-aware
    state.freeCapture.shapeStart = { xM: start.xM, yM: start.yM };

    // Track last pointer in both pixel + world space for finalization
    state.freeCapture.lastXpx = xPx;
    state.freeCapture.lastYpx = yPx;
    state.freeCapture.lastXM = start.xM;
    state.freeCapture.lastYM = start.yM;

    // Seed a tiny preview immediately (raw drag, but anchored to snapped start)
    updateShapePreviewAt(xPx, yPx, false);

    try {
      if (state.tool === 'rect') statusHint.textContent = 'Rectangle (Area): drag to size · Release then Finish';
      if (state.tool === 'circle') statusHint.textContent = 'Circle (Area): drag to set radius · Release then Finish';
      if (state.tool === 'rectLine') statusHint.textContent = 'Rectangle (Lines): drag to size · Release then Finish';
      if (state.tool === 'circleLine') statusHint.textContent = 'Circle (Lines): drag to set radius · Release then Finish';
    } catch(_) {}

    draw();
    return true;
  }

  function updateShapePreviewAt(xPx, yPx, forceSnapFinal){
    if (!state.freeCapture || !state.freeCapture.active || state.freeCapture.mode !== 'shape') return false;

    // IMPORTANT: during drag we must not let snap collapse motion to a single point.
    // Use raw world coords while dragging; only snap once when finalizing on release.
    const cur = (forceSnapFinal ? canvasToWorld(xPx, yPx) : canvasToWorldRawMouse(xPx, yPx));

    state.freeCapture.lastXpx = xPx;
    state.freeCapture.lastYpx = yPx;
    state.freeCapture.lastXM = cur.xM;
    state.freeCapture.lastYM = cur.yM;

    const a = state.freeCapture.shapeStart;
    if (!a) return false;

    const shapeType = state.freeCapture.shapeType;

    // Build preview as a polygon area (reuses existing render+commit pipeline)
    let pts = null;

    let shapeMeta = null;
    if (shapeType === 'rect' || shapeType === 'rectLine') {
      const x0 = a.xM, y0 = a.yM;
      const x1 = cur.xM, y1 = cur.yM;
      const minX = Math.min(x0, x1), maxX = Math.max(x0, x1);
      const minY = Math.min(y0, y1), maxY = Math.max(y0, y1);
      const w = (maxX - minX), h = (maxY - minY);

      shapeMeta = { kind:'rect', minX, minY, maxX, maxY }; // persisted for post-edit width/height

      // Ignore micro drags (keeps Finish truth clean)
      if (w > 0.0005 && h > 0.0005) {
        pts = [
          {xM:minX, yM:minY},
          {xM:maxX, yM:minY},
          {xM:maxX, yM:maxY},
          {xM:minX, yM:maxY}
        ];
      }
    } else if (shapeType === 'circle' || shapeType === 'circleLine') {
      const dx = cur.xM - a.xM;
      const dy = cur.yM - a.yM;
      const r = Math.hypot(dx, dy);

      shapeMeta = { kind:'circle', cxM:a.xM, cyM:a.yM, rM:r };
      // Ignore micro drags (keeps Finish truth clean)
      if (r > 0.0005) {
        const N = 48;
        pts = [];
        for (let i=0;i<N;i++){
          const t = (i / N) * Math.PI * 2;
          pts.push({ xM: a.xM + Math.cos(t)*r, yM: a.yM + Math.sin(t)*r });
        }
      }
    }

    if (pts) {
      // Two shape families:
      // - (Area) shapes commit as polygon areas
      // - (Lines) shapes commit as closed polylines using the current Line Style (solid=road, dashed/centerline=lane)
      if (shapeType === 'rect' || shapeType === 'circle') {
        state.currentPath = { type: 'area', points: pts, __shapePreview: true, __shapeType: shapeType, __shapeMeta: shapeMeta };
      } else if (shapeType === 'rectLine' || shapeType === 'circleLine') {
        const ls = String(state.lineStyle || 'solid').toLowerCase();
        const lineType = (ls === 'solid') ? 'road' : 'lane';

        const linePts = pts.slice();
        if (linePts.length) {
          const p0 = linePts[0];
          linePts.push({ xM: p0.xM, yM: p0.yM }); // close
        }
        state.currentPath = { type: lineType, points: linePts, __shapePreview: true, __shapeType: shapeType, __shapeMeta: shapeMeta };
      } else {
        state.currentPath = { type: 'area', points: pts, __shapePreview: true, __shapeType: shapeType };
      }
    } else {
      // Keep a blank currentPath to avoid lying "Finish" state
      state.currentPath = null;
    }

    draw();
    return true;
  }

  function finalizeShapeCapture(){
    if (!state.freeCapture || !state.freeCapture.active || state.freeCapture.mode !== 'shape') return false;

    // Snap final once on release (matches other tools: drag is smooth, result can still land on snap)
    try {
      if (state.snapEnabled && state.freeCapture && state.freeCapture.lastXpx != null && state.freeCapture.lastYpx != null) {
        updateShapePreviewAt(state.freeCapture.lastXpx, state.freeCapture.lastYpx, true);
      }
    } catch(_) {}
    // Disarm pointer capture on release.
    // - Auto: clear all capture state (matches current behavior)
    // - Manual: keep anchor+type so the user can re-drag to adjust until Finish
    state.freeCapture.active = false;
    const shapeType = state.freeCapture.shapeType;

    if (state.autoCommitLine) {
      state.freeCapture.mode = null;
      state.freeCapture.shapeType = null;
      state.freeCapture.shapeStart = null;
    } else {
      state.freeCapture.mode = 'shape_hold';
      // keep state.freeCapture.shapeType + shapeStart
    }

    // If we don't have a valid preview, nothing to do
    if (!state.currentPath || !Array.isArray(state.currentPath.points) || ((state.currentPath.type === 'area') ? (state.currentPath.points.length < 3) : (state.currentPath.points.length < 2))) {
      try { statusHint.textContent = 'Shape: cancelled'; } catch(_) {}
      draw();
      return true;
    }

    if (state.autoCommitLine) {
      // Auto: commit immediately via canonical commit pipe
      commitCurrentPath();
      try {
        if (shapeType === 'circle') statusHint.textContent = 'Circle (Area) committed';
        else if (shapeType === 'rect') statusHint.textContent = 'Rectangle (Area) committed';
        else if (shapeType === 'circleLine') statusHint.textContent = 'Circle (Lines) committed';
        else if (shapeType === 'rectLine') statusHint.textContent = 'Rectangle (Lines) committed';
        else statusHint.textContent = 'Shape committed';
      } catch(_) {}
      draw();
      return true;
    } else {
      // Manual: hold preview; user must press Finish
      try { statusHint.textContent = 'Shape preview ready · Press Finish to commit'; } catch(_) {}
      // Force truth refresh for Finish label/highlights
      try{ updateContextHighlights(); }catch(_){}
      // Shapes (manual mode) must also refresh the Auto/Finish narrator label immediately,
      // same as manual Line does (truth: FINISH is available when a preview path exists).
      try{ if (typeof setModeLabel === 'function') setModeLabel(); }catch(_){}
      try{ if (typeof syncTopbarEditUI === 'function') syncTopbarEditUI(); }catch(_){}
      draw();
      return true;
    }
  }
  // --- sub-chunk 11.6S END ---------------------------------------------------------------------------

  // Parse distance override from Angle toolspace into METERS (internal)
  function getAngleDistOverrideMeters(){
    if (!angleSnapDistInput) return null;
    const raw = parseFloat(angleSnapDistInput.value);
    if (!Number.isFinite(raw) || raw <= 0) return null;
    return inputDistToMetersAny(raw);
  }

  // Angle snap (STEP snapping):
  // angleSnapDegInput is treated as the STEP size (e.g., 45 means snap to nearest multiple of 45).
  function applyAngleSnapFromLast(last, xM, yM){
    if (!last) return { xM, yM };
    if (!state.snapEnabled) return { xM, yM };
    if (state.snapMode !== 'angle') return { xM, yM };

    let stepDeg = parseFloat(angleSnapDegInput ? angleSnapDegInput.value : '45');
    if (!Number.isFinite(stepDeg) || stepDeg <= 0) stepDeg = 45;

    // Optional distance override (meters internally)
    const distOverrideM = getAngleDistOverrideMeters();

    const dx = xM - last.xM;
    const dy = yM - last.yM;

    const rawDist = Math.hypot(dx, dy);
    const dist = (distOverrideM != null) ? distOverrideM : rawDist;

    if (!Number.isFinite(dist) || dist === 0) return { xM, yM };

    const rawAng = Math.atan2(dy, dx);
    const stepRad = stepDeg * Math.PI / 180;
    const snappedAng = Math.round(rawAng / stepRad) * stepRad;

    const out = {
      xM: last.xM + Math.cos(snappedAng) * dist,
      yM: last.yM + Math.sin(snappedAng) * dist
    };

    // --- PROPOSAL PATCH: snap feedback (angle) --------------------------------------
    const applied = Math.abs(rawAng - snappedAng) > 1e-6;
    if (applied) {
      state._lastSnap = { kind: 'angle', xM: out.xM, yM: out.yM, stepDeg, ts: Date.now() };
    }
    // --- PROPOSAL PATCH END ----------------------------------------------------------

    return out;
  }

  function handleCanvasDown(evt){
    // --- BG image calibration capture gate (2-point) -------------------------------
    // Uses RAW world coords (no snapping) and sets bgImageMpp so image scale matches grid.
    if (state._bgCal && state._bgCal.active) {
      const { xPx, yPx } = getCanvasPos(evt);
      const world = (typeof canvasToWorldRawMouse === 'function')
        ? canvasToWorldRawMouse(xPx, yPx)
        : (typeof canvasToWorldRaw === 'function')
          ? canvasToWorldRaw(xPx, yPx)
          : { xM: xPx/getPxPerMeter() + state.viewOriginXM, yM: yPx/getPxPerMeter() + state.viewOriginYM };

      if (!state._bgImageObj || !state.bgImageMpp || !(state.bgImageMpp > 0)) {
        state._bgCal.active = false;
        if (bgImageCalCancelBtn) bgImageCalCancelBtn.style.display = 'none';
        toast('Load a background image first');
        return;
      }

      const ix = (world.xM - state.bgImageOriginXM) / state.bgImageMpp;
      const iy = (world.yM - state.bgImageOriginYM) / state.bgImageMpp;

      if (!state._bgCal.p1) {
        state._bgCal.p1 = { xM: world.xM, yM: world.yM };
        state._bgCal.p1Img = { xPx: ix, yPx: iy };
        state._bgCal._p2Mark = null;
        state._bgCal._lastMarks = { p1: { xM: world.xM, yM: world.yM }, p2: null, ts: Date.now() };
        draw();
        toast('BG Calibrate: click second point');
        return;
      }

      const p1 = state._bgCal.p1;
      const p1i = state._bgCal.p1Img || { xPx: 0, yPx: 0 };
      const dx = ix - p1i.xPx;
      const dy = iy - p1i.yPx;
      const dpx = Math.sqrt(dx*dx + dy*dy);

      if (!isFinite(dpx) || dpx < 1) {
        toast('BG Calibrate: points too close');
        state._bgCal.p1 = null;
        state._bgCal.p1Img = null;
        return;
      }

      const n = Number(bgImageCalLenInput ? bgImageCalLenInput.value : '');
      if (!isFinite(n) || n <= 0) {
        toast('Enter a known length first');
        return;
      }

      // Convert display units -> meters (internal)
      const f = unitFactorFromMeters(); // displayUnits per meter
      const knownMeters = n / (isFinite(f) && f > 0 ? f : 1);

      const newMpp = knownMeters / dpx;
      if (!isFinite(newMpp) || newMpp <= 0) {
        toast('BG Calibrate: invalid scale');
        return;
      }

      // Anchor: keep first clicked point fixed in world space while changing scale
      // Visual proof marks
      state._bgCal._p2Mark = { xM: world.xM, yM: world.yM };
      state._bgCal._lastMarks = { p1: { xM: p1.xM, yM: p1.yM }, p2: { xM: world.xM, yM: world.yM }, ts: Date.now() };

      state.bgImageMpp = newMpp;
      state.bgImageOriginXM = p1.xM - (p1i.xPx * newMpp);
      state.bgImageOriginYM = p1.yM - (p1i.yPx * newMpp);

      if (bgImageMppInput) bgImageMppInput.value = String(state.bgImageMpp);
      try { saveDisplayPrefs(); } catch(_){}
      state._bgCal.active = false;
      state._bgCal.p1 = null;
      state._bgCal.p1Img = null;
      if (bgImageCalCancelBtn) bgImageCalCancelBtn.style.display = 'none';
      draw();
      toast('Background calibrated');
      return;
    }

    // Find Area: click inside a closed loop (lines) to generate an Area object
    if (state.tool === 'findArea') {
      const { xPx, yPx } = getCanvasPos(evt);
      const world = (typeof canvasToWorldRawMouse === 'function')
        ? canvasToWorldRawMouse(xPx, yPx)
        : (typeof canvasToWorldRaw === 'function')
          ? canvasToWorldRaw(xPx, yPx)
          : { xM: xPx/getPxPerMeter() + state.viewOriginXM, yM: yPx/getPxPerMeter() + state.viewOriginYM };

      if (!tryFindAreaAtWorldPoint(world.xM, world.yM)) {
        try { toast('Find Area: no closed loop found at that point'); } catch(_){}
      }
      return;
    }

    // Shape capture gate (Rect/Circle): drag-generate then release to Finish/Auto
    if (state.tool === 'rect' || state.tool === 'circle' || state.tool === 'rectLine' || state.tool === 'circleLine') {
      const { xPx, yPx } = getCanvasPos(evt);
      if (beginShapeAtCanvas(xPx, yPx)) return;
    }

    // Rotate gate (mouse/tap):
    // - In inspect + rotate mode:
    //   * Tap on the selected object sets the pivot (no extra UI/buttons).
    //   * Drag rotates around the latest pivot (tap pivot or default center).
    // - Quantization uses the shared degrees field (angleSnapDegInput) even if snap toggle is OFF.
    if (state.tool === 'inspect' && state.editMode === 'rotate') {
      const sel = _getSelectedFeature && _getSelectedFeature();
      if (sel) {
        const { xPx, yPx } = getCanvasPos(evt);
        const world = canvasToWorldRawMouse(xPx, yPx);

        // If a preview exists and user begins a new gesture, re-base on current live geometry
        if (rotateSession && rotateSession.featureId === sel.id && rotateSession.pending) {
          try {
            const live = _findFeatureById(sel.id);
            if (live) rotateSession.base = deepClone(live);
            rotateSession.pending = false;
            rotateSession.pendingDeltaDeg = 0;
          } catch(_){}
        }

        rotateDrag.armed = true;
        rotateDrag.active = false;
        rotateDrag.downXPx = xPx;
        rotateDrag.downYPx = yPx;
        rotateDrag.downWorld = world;
        rotateDrag.pivotCandidate = _pivotFromTap(sel, world) || null;
        return;
      }
    }

    // Bend gate:
    // - If a bend preview is pending (manual mode), re-arm the SAME session for further editing.
    // - Otherwise, start a new bend session on line hit.
    if (state.tool === 'bend') {
      const { xPx, yPx } = getCanvasPos(evt);

      // Resume existing pending preview (lets the user keep editing after pen-lift)
      try {
        if (state.bend && state.bend.pending && state.bend.previewPointsFull && state.bend.featureIndex != null) {
          if (!state.freeCapture) state.freeCapture = { active:false };
          state.freeCapture.active = true;
          state.freeCapture.mode = 'bend';

          // Re-anchor drag without resetting the session
          const world = canvasToWorldRawMouse(xPx, yPx);
          state.bend.startWorld = { xM: world.xM, yM: world.yM };
          state.bend.startBulgeM = state.bend.bulgeM || 0;

          state.bend.active = true;
          state.bend.pending = false;

          try { statusHint.textContent = 'Bend: editing preview · release to hold or Auto-commit'; } catch(_) {}
          draw();
          return;
        }
      } catch(_) {}

      if (beginBendAtCanvas(xPx, yPx)) return;
      // If no hit, fall through to nav/pan behavior.
    }
const {xPx,yPx}=getCanvasPos(evt);
    let {xM,yM}=canvasToWorld(xPx,yPx);

    // DRAWING TOOLS -----------------------------------------------------------
    if(state.tool==='road' || state.tool==='lane'){
      if (state.currentPath && state.currentPath.points && state.currentPath.points.length) {
        const last = state.currentPath.points[state.currentPath.points.length-1];
        const snapped = applyAngleSnapFromLast(last, xM, yM);
        xM = snapped.xM; yM = snapped.yM;
      }

      if (state.snapEnabled && state.snapMode === 'angle') {
        // skip axis lock
      } else if(state.axisLock &&
         state.currentPath &&
         state.currentPath.points &&
         state.currentPath.points.length){
        const last=state.currentPath.points[state.currentPath.points.length-1];
        const dx=xM-last.xM,dy=yM-last.yM;
        if(Math.abs(dx)>=Math.abs(dy)) yM=last.yM; else xM=last.xM;
      }

      // SUB-CHUNK 11.1C BEGIN — Auto-commit line segments (Line Tool)
      // Auto-commit line mode:
      // - 1st tap sets the start point
      // - 2nd tap commits a 2-point line feature immediately
      // NOTE: This applies to road/lane only. Areas remain manual finish.
      if (state.autoCommitLine) {
        if(!state.currentPath){
          state.currentPath={ type:state.tool, points:[{xM,yM}] };
          draw();
          return;
        }

        // Expected: one start point already exists
        if (state.currentPath.points && state.currentPath.points.length === 1) {
          pushHistory('addLine');

          const p0 = state.currentPath.points[0];
          const p1 = { xM, yM };

          // Persist line style per feature (backward-safe)
          let ls = 'solid';
          if (state.tool === 'lane') {
            ls = (state.lineStyle === 'centerline') ? 'centerline' : 'dashed';
          }

          // Style fields (schema-safe defaults; preserves current look)
          let defaultWidthPx = (state.tool === 'road') ? 6 : 2;
          let defaultColor   = (state.tool === 'road') ? '#e5e7eb' : '#facc15';
          let defaultDash = null;
          if (state.tool === 'lane') {
            defaultDash = (ls === 'centerline') ? [18, 6, 3, 6] : [10, 8];
          }

          // Apply user defaults from Properties → Line panel (persistent)
          try{
            const d = (state && state.lineDefaults) ? state.lineDefaults : null;
            if (d){
              if (Number.isFinite(Number(d.widthPx))) defaultWidthPx = Number(d.widthPx);
              if (typeof d.color === 'string' && d.color.length) defaultColor = d.color;

              const style = String(d.style || 'auto');
              if (style && style !== 'auto'){
                // Adopt requested style deterministically
                ls = style; // safe: used only as a style label downstream
                if (style === 'solid') {
                  defaultDash = null;
                } else if (style === 'dashed') {
                  defaultDash = [10, 8];
                } else if (style === 'centerline') {
                  defaultDash = [18, 6, 3, 6];
                } else if (style === 'custom') {
                  const parsed = (typeof parseDashList === 'function') ? parseDashList(state.lineDefaults && state.lineDefaults.customDash) : null;
                  defaultDash = (parsed && parsed.length >= 2) ? parsed : [10, 8];
                }
              }
            }
          }catch(_){}
const feature = {
            id: state.nextId++,
            type: state.tool,
            points: [ { xM: p0.xM, yM: p0.yM }, p1 ],
            lineStyle: ls,
            strokeWidthPx: defaultWidthPx,
            strokeColor: defaultColor,
            strokeDash: defaultDash
          };

          state.features.push(feature);
          state.currentPath = null;
          selectFeatureById(feature.id);
          draw();
          return;
        }
        // Defensive fallback: if path has unexpected length, continue in polyline mode
      }
      // SUB-CHUNK 11.1C END — Auto-commit line segments (Line Tool)

      if(!state.currentPath){
        state.currentPath={ type:state.tool, points:[{xM,yM}] };
      }else{
        state.currentPath.points.push({xM,yM});
      }
      draw();
      // Keep context rail label accurate (Auto button may show FINISH when commit is possible).
      if (typeof updateToolspace === 'function') updateToolspace();
      return;
    }

    if(state.tool==='area'){
      if (state.currentPath && state.currentPath.points && state.currentPath.points.length) {
        const last = state.currentPath.points[state.currentPath.points.length-1];
        const snapped = applyAngleSnapFromLast(last, xM, yM);
        xM = snapped.xM; yM = snapped.yM;
      }

      if (state.snapEnabled && state.snapMode === 'angle') {
        // skip axis lock
      } else if(state.axisLock &&
               state.currentPath &&
               state.currentPath.points &&
               state.currentPath.points.length){
        const last=state.currentPath.points[state.currentPath.points.length-1];
        const dx=xM-last.xM,dy=yM-last.yM;
        if(Math.abs(dx)>=Math.abs(dy)) yM=last.yM; else xM=last.xM;
      }

      if(!state.currentPath){
        state.currentPath={ type:'area', points:[{xM,yM}] };
      }else{
        state.currentPath.points.push({xM,yM});
      }
      draw();
      // Keep context rail label accurate (Auto button may show FINISH when commit is possible).
      if (typeof updateToolspace === 'function') updateToolspace();
      return;
    }

    if(state.tool==='quickVerify'){
      handleQuickVerifyClick(xPx,yPx);
      return;
    }

    if(state.tool==='quickVerify'){
      handleQuickVerifyClick(xPx,yPx);
      return;
    }

    if(state.tool==='measure'){
      handleMeasureClick(xPx,yPx);
      return;
    }

    if(state.tool==='symbol'){
      const st = String(symbolSelect && symbolSelect.value || '');
      if (!st){
        setStatusHint('Tool: Symbol · Choose a symbol in the dropdown, then tap to place');
        return;
      }
      state.lastSymbolType = st;
      pushHistory('addSymbol');
      const f={
        id:state.nextId++,
        type:'symbol',
        symbolType:st,
        xM,yM,
        angleDeg:0,
        sizeM:state.metersPerGrid
      };
      state.features.push(f);
      selectFeatureById(f.id);
      return;
    }

    if(state.tool==='label'){
      pushHistory('addLabel');
      const kind = labelKindSelect.value || 'point';
      const baseSize = state.metersPerGrid*0.5;
      let txM = xM + baseSize*1.5;
      let tyM = yM - baseSize*0.3;
      const f={
        id:state.nextId++,
        type:'label',
        kind,
        xM,yM,
        txM,tyM,
        text:'Label',
        sizeM:baseSize
      };
      state.features.push(f);
      selectFeatureById(f.id);
      return;
    }

    if(state.tool==='erase'){
      const hitInfo = hitTestFeature(xPx,yPx);
      const hit = hitInfo && hitInfo.feature;
      if(hit){
        if (_isFeatureLocked(hit)) { _denyLockedEdit('erase', hit); return; }
        pushHistory('erase');
        state.features=state.features.filter(f=>f!==hit);
        if(state.selectedId===hit.id) state.selectedId=null;
        updateFeatureSelect(); refreshSelectedInspector(); draw();
      }
      return;
    }
    // --- chunk 12.1 · Logical group (see chunks 10 & 11 for implementation) ------------- 
    if(state.tool==='inspect'){
      if (state.editMode === 'moveShape' && state.selectedId != null) {
        const f = state.features.find(x=>x.id===state.selectedId);
        if (f) {
          if (_isFeatureLocked(f)) { _denyLockedEdit('move', f); return; }
          pushHistory('moveShape');
          const startWorld = canvasToWorldRawMouse(xPx,yPx); // raw (no snap) for move-shape start

          // Move ref point: prefer the point the user actually grabbed.
          let refPoint = { xM: startWorld.xM, yM: startWorld.yM };
          if (Array.isArray(f.points) && f.points.length) {
            let best = f.points[0];
            let bestD2 = Infinity;
            for (const p of f.points) {
              const dx = (p.xM - startWorld.xM);
              const dy = (p.yM - startWorld.yM);
              const d2 = dx*dx + dy*dy;
              if (d2 < bestD2) { bestD2 = d2; best = p; }
            }
            refPoint = { xM: best.xM, yM: best.yM };
          } else if (f.shapeMeta && f.shapeMeta.kind === 'circle' &&
                     Number.isFinite(f.shapeMeta.cxM) && Number.isFinite(f.shapeMeta.cyM) && Number.isFinite(f.shapeMeta.rM)) {
            const cx = f.shapeMeta.cxM, cy = f.shapeMeta.cyM, r = Math.max(0, f.shapeMeta.rM);
            const dx = startWorld.xM - cx;
            const dy = startWorld.yM - cy;
            const d  = Math.hypot(dx, dy) || 0;
            if (d <= r) refPoint = { xM: cx, yM: cy };
            else if (r > 0) refPoint = { xM: cx + (dx/d)*r, yM: cy + (dy/d)*r };
            else refPoint = { xM: cx, yM: cy };
          } else if (Number.isFinite(f.xM) && Number.isFinite(f.yM)) {
            refPoint = { xM: f.xM, yM: f.yM };
          }

          // Group-aware move: if the selected feature has a groupId, drag moves the whole group.
          // Multi-select override: if Multi is ON and multiple ids are selected, drag moves that explicit set.
          let _gid = getEffectiveGroupId(f);
          let _members = (_gid == null) ? [f] : getEffectiveGroupMembers(_gid);

          if (state.multiSelectEnabled && Array.isArray(state.selectedIds) && state.selectedIds.length > 1) {
            _gid = null;
            _members = state.selectedIds
              .map(id => state.features.find(ff=>ff && ff.id===id))
              .filter(Boolean);
          }

          // Multi-select move: choose the refPoint from the actually-grabbed member, not just the last-selected feature.
          // We pick the closest meaningful handle across all moving members to the pointer-down world position.
          if (state.multiSelectEnabled && Array.isArray(state.selectedIds) && state.selectedIds.length > 1 && Array.isArray(_members) && _members.length) {
            let _best = { xM: refPoint.xM, yM: refPoint.yM, d2: Infinity, sourceId: state.selectedId };
            for (const _mf of _members) {
              if (!_mf) continue;
              // Candidate ref for a member
              let _rp = null;
              if (Array.isArray(_mf.points) && _mf.points.length) {
                let _bp = _mf.points[0];
                let _bd2 = Infinity;
                for (const _p of _mf.points) {
                  const _dx = (_p.xM - startWorld.xM);
                  const _dy = (_p.yM - startWorld.yM);
                  const _d2 = _dx*_dx + _dy*_dy;
                  if (_d2 < _bd2) { _bd2 = _d2; _bp = _p; }
                }
                _rp = { xM: _bp.xM, yM: _bp.yM };
              } else if (_mf.shapeMeta && _mf.shapeMeta.kind === 'circle' &&
                         Number.isFinite(_mf.shapeMeta.cxM) && Number.isFinite(_mf.shapeMeta.cyM) && Number.isFinite(_mf.shapeMeta.rM)) {
                const _cx = _mf.shapeMeta.cxM, _cy = _mf.shapeMeta.cyM, _r = Math.max(0, _mf.shapeMeta.rM);
                const _dx = startWorld.xM - _cx;
                const _dy = startWorld.yM - _cy;
                const _d  = Math.hypot(_dx, _dy) || 0;
                if (_d <= _r) _rp = { xM: _cx, yM: _cy };
                else if (_r > 0) _rp = { xM: _cx + (_dx/_d)*_r, yM: _cy + (_dy/_d)*_r };
                else _rp = { xM: _cx, yM: _cy };
              } else if (Number.isFinite(_mf.xM) && Number.isFinite(_mf.yM)) {
                _rp = { xM: _mf.xM, yM: _mf.yM };
              }
              if (!_rp) continue;
              const _dx = _rp.xM - startWorld.xM;
              const _dy = _rp.yM - startWorld.yM;
              const _d2 = _dx*_dx + _dy*_dy;
              if (_d2 < _best.d2) {
                _best = { xM: _rp.xM, yM: _rp.yM, d2: _d2, sourceId: _mf.id };
              }
            }
            if (Number.isFinite(_best.xM) && Number.isFinite(_best.yM) && _best.d2 !== Infinity) {
              refPoint = { xM: _best.xM, yM: _best.yM };
            }
          }

          const _originalsById = {};
          for (const mf of _members) { _originalsById[mf.id] = deepClone(mf); }

          moveShapeDrag = {
            featureId: f.id,
            groupId: _gid,
            memberIds: _members.map(mf => mf.id),
            startWorld,
            originalsById: _originalsById,
            guideLine: null,
            refPoint
          };
        }
        return;
      }

      if (state.editMode === 'movePoint' ||
          state.editMode === 'addVertex' ||
          state.editMode === 'removeVertex' ||
          state.editMode === 'cutout') {
        handleInspectClickAt(xPx, yPx);
        return;
      }

      navDragActive = true;
      navDragStart = {
        xPx, yPx,
        viewXM: state.viewOriginXM,
        viewYM: state.viewOriginYM
      };
      navLastPos = { xPx, yPx };
      return;
    }
  }
// --- chunk 11.2 · Mouse move + status cursor ----------------------------------------

  function handleCanvasMove(evt){
    const {xPx,yPx}=getCanvasPos(evt);
    const {xM,yM}=canvasToWorldRawMouse(xPx,yPx); // raw cursor readout (no snap)
    statusCursor.textContent = fmtCoordMeters(xM, yM);
  }

  // --- chunk 11.2.4 · Free-Capture helpers (Step 1: isolated, debug-only) ---------
  // Console API:
  //   tool==='freeDraw'  -> arms capture for next pointer/touch down
  //   window.FREECAP.stop()   -> disarms and clears buffer (no commit)
  // Notes:
  // - No UI changes.
  // - No schema changes.
  // - Captured geometry commits as a standard 'road' polyline (points[]).
  /* (Step1 debug console API removed in Step2 toolization) */
function freeCaptureBeginAt(xPx, yPx){
    if (!state.freeCapture || state.tool !== 'freeDraw') return false;
    const w = canvasToWorldRaw(xPx, yPx);
    state.freeCapture.active = true;
    state.freeCapture.points = [{ xM: w.xM, yM: w.yM }];
    state.freeCapture.lastXM = w.xM;
    state.freeCapture.lastYM = w.yM;
    pushHistory('freeCapture(begin)');
    draw();
    return true;
  }

  function freeCaptureAddAt(xPx, yPx){
    // Bend preview update (reuses freeCapture move gate)
    if (state.freeCapture && state.freeCapture.active && state.freeCapture.mode === 'bend' && state.bend && state.bend.active) {
      const b = state.bend;
      const world = canvasToWorldRawMouse(xPx, yPx);

      // Allow grab point to slide while dragging:
      // - grabT is updated from the current cursor projection onto segment A->B
      // - bulge is the signed perpendicular distance from the cursor to that moving grab point
      const abx = (b.b.xM - b.a.xM);
      const aby = (b.b.yM - b.a.yM);
      const ab2 = (abx*abx + aby*aby) || 1;

      // Update grabT (0..1) from current cursor location
      const tNow = clamp(((world.xM - b.a.xM)*abx + (world.yM - b.a.yM)*aby) / ab2, 0, 1);
      b.grabT = tNow;

      // Moving grab point on the segment
      const gx = b.a.xM + abx * b.grabT;
      const gy = b.a.yM + aby * b.grabT;

      const bulgeBase = (b.startBulgeM || 0);
      const bulge = ((world.xM - gx) * b.n.xM) + ((world.yM - gy) * b.n.yM) + bulgeBase;

      // Clamp bulge to prevent huge surfaces (cap at 2x segment length)
      const segLen = Math.hypot(b.b.xM - b.a.xM, b.b.yM - b.a.yM) || 1;
      b.bulgeM = clamp(bulge, -2*segLen, 2*segLen);

      const curvePts = buildQuadraticBezierPoints(b.a, b.b, b.bulgeM, 18, b.grabT);
      b.previewPointsFull = (b.isClosedRing ? spliceSegmentWithCurvePointsClosed(b.basePoints, b.segIndex, curvePts) : spliceSegmentWithCurvePoints(b.basePoints, b.segIndex, curvePts));

      // Overlay preview via currentPath (render system already draws currentPath)
      state.currentPath = { type: (state.features[b.featureIndex]?.type || 'road'), points: b.previewPointsFull.slice(), __bendPreview:true };
      draw();
      return;
    }
    // Shape preview update (Rect/Circle)
    if (state.freeCapture && state.freeCapture.active && state.freeCapture.mode === 'shape') {
      updateShapePreviewAt(xPx, yPx);
      return;
    }

if (!state.freeCapture || !state.freeCapture.active) return false;
    const w = canvasToWorldRaw(xPx, yPx);
    // Step 1 is raw capture: only de-dupe identical points.
    if (w.xM === state.freeCapture.lastXM && w.yM === state.freeCapture.lastYM) return true;
    state.freeCapture.points.push({ xM: w.xM, yM: w.yM });
    state.freeCapture.lastXM = w.xM;
    state.freeCapture.lastYM = w.yM;
    draw();
    return true;
  }

  function freeCaptureCommit(){
    // Bend commit/hold (reuses freeCapture mouse/touch end gate)
    if (state.freeCapture && state.freeCapture.active && state.freeCapture.mode === 'bend' && state.bend && state.bend.active) {
      // Disarm freeCapture first
      state.freeCapture.active = false;
      state.freeCapture.mode = null;

      if (state.autoCommitLine) {
        commitBendSession('auto');
        return true;
      } else {
        // Hold preview for Finish
        state.bend.pending = true;
        state.bend.active = false; // editing gesture finished; awaiting Finish
        try { statusHint.textContent = 'Bend preview ready · Press Finish to commit'; } catch(_) {}
        // Truth sync: if Bend is pending, the Auto/Finish button must display FINISH (action available).
        try { if (typeof updateToolspace === 'function') updateToolspace(); } catch(_) {}
        try { if (typeof setModeLabel === 'function') setModeLabel(); } catch(_) {}
        draw();
        return true;
      }
      return;
    }

    // Shape commit/hold (drag-generated primitives)
    if (state.freeCapture && state.freeCapture.active && state.freeCapture.mode === 'shape') {
      return finalizeShapeCapture();
    }

if (!state.freeCapture || !state.freeCapture.active) return false;
    const pts = state.freeCapture.points.slice();
    state.freeCapture.active = false;
    // Step2: tool remains 'freeDraw' until user switches tools.
    state.freeCapture.points = [];
    state.freeCapture.lastXM = null;
    state.freeCapture.lastYM = null;

    if (pts.length >= 2) {
      // Apply line defaults for FreeCapture commits (treat as road polyline)
      let _wPx = 6;
      let _col = '#e5e7eb';
      let _dash = null;
      let _ls = 'solid';
      try{
        const d = (state && state.lineDefaults) ? state.lineDefaults : null;
        if (d){
          if (Number.isFinite(Number(d.widthPx))) _wPx = Number(d.widthPx);
          if (typeof d.color === 'string' && d.color.length) _col = d.color;
          const style = String(d.style || 'auto');
          if (style && style !== 'auto'){
            _ls = style;
            if (style === 'solid') _dash = null;
            else if (style === 'dashed') _dash = [10, 8];
            else if (style === 'centerline') _dash = [18, 6, 3, 6];
          }
        }
      }catch(_){}
      const f = {
        id: state.nextId++,
        type: 'road',
        points: pts,
        lineStyle: _ls,
        strokeWidthPx: _wPx,
        strokeColor: _col,
        strokeDash: _dash
      };
      state.features.push(f);
      state.selectedId = f.id;
      updateFeatureSelect();
      refreshSelectedInspector();
    }
    try { statusHint.textContent = 'FreeCapture committed'; } catch(e){}
    draw();
    return true;
  }

  function freeCaptureAbort(){
    if (state.freeCapture && state.freeCapture.active && state.freeCapture.mode === 'bend') {
      // Abort bend preview
      state.freeCapture.active = false;
      state.freeCapture.mode = null;
      cancelBendSession('abort');
      return true;
    }
if (!state.freeCapture) return false;
    state.freeCapture.active = false;
    // Step2: tool remains 'freeDraw' until user switches tools.
    state.freeCapture.points = [];
    state.freeCapture.lastXM = null;
    state.freeCapture.lastYM = null;
    try { statusHint.textContent = 'FreeCapture aborted'; } catch(e){}
    draw();
    return true;
  }

  
  function drawFreeCapturePreview(){
    if (!state.freeCapture || !state.freeCapture.active) return;
    const pts = state.freeCapture.points || [];
    if (pts.length < 2) return;

    // Use line defaults so the tracer is guaranteed visible and matches user intent.
    let col = '#e5e7eb';
    let wPx = 2;
    let dash = null;
    try{
      const d = (state && state.lineDefaults) ? state.lineDefaults : null;
      if (d){
        if (typeof d.color === 'string' && d.color.length) col = d.color;
        if (Number.isFinite(Number(d.widthPx))) wPx = Math.max(2, Number(d.widthPx));
        const style = String(d.style || 'auto');
        if (style === 'dashed') dash = [10, 8];
        else if (style === 'centerline') dash = [18, 6, 3, 6];
      }
    }catch(_){}

    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.strokeStyle = col;
    ctx.lineWidth = wPx;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    if (ctx.setLineDash) ctx.setLineDash(dash || []);

    const a = worldToCanvas({ xM: pts[0].xM, yM: pts[0].yM });
    ctx.beginPath();
    ctx.moveTo(a.xPx, a.yPx);
    for (let i=1;i<pts.length;i++){
      const p = worldToCanvas({ xM: pts[i].xM, yM: pts[i].yM });
      ctx.lineTo(p.xPx, p.yPx);
    }
    ctx.stroke();
    if (ctx.setLineDash) ctx.setLineDash([]);

    ctx.restore();
  }

  function getMouseCanvasPos(evt){
    const rect = canvas.getBoundingClientRect();
    return { xPx: evt.clientX - rect.left, yPx: evt.clientY - rect.top };
  }

  function getTouchCanvasPos(touch){
    const rect = canvas.getBoundingClientRect();
    return { xPx: touch.clientX - rect.left, yPx: touch.clientY - rect.top };
  }

  
// SUB-CHUNK 11.B1 END — Bend pointer lifecycle hooks (safe-edit boundary)
// --- chunk end 11.2.4 ---------------------------------------------------------------

  // Raw world conversion for move-shape (NO snapping)
  function canvasToWorldRawMouse(xPx, yPx){
    // Alias for legacy call-sites: keep one raw resolver (canvasToWorldRaw).
    return canvasToWorldRaw(xPx, yPx);
  }

  // Units-aware distance override for Angle Dist (returns METERS)
  function getAngleDistOverrideMetersForMoveMouse(){
    // Alias for legacy call-sites: keep one override resolver.
    return getAngleDistOverrideMetersForMove();
  }

  // Grid snap for movement delta
  function snapDeltaGridMouse(dxM, dyM){
  // Alias for legacy call-sites: keep one grid snap resolver.
  return snapDeltaGrid(dxM, dyM);
  }

  function findNearestVertexIgnoringMouse(xM, yM, maxDistM, ignoreId){
    // Alias for legacy call-sites: keep one nearest-vertex resolver.
    return findNearestVertexIgnoring(xM, yM, maxDistM, ignoreId);
  }

  // Point snap for movement delta (snap ref point to external vertex)
  function snapDeltaPointMouse(dxM, dyM){
    // Alias for legacy call-sites: keep one point-snap resolver.
    return snapDeltaPoint(dxM, dyM);
  }

  // Angle-step snap for movement delta
  function snapDeltaAngleStepMouse(dxM, dyM){
    // Alias for legacy call-sites: keep one angle-step snap resolver.
    return snapDeltaAngleStep(dxM, dyM);
  }

  function applyMoveShapeSnapMouse(dxM, dyM){
  // Alias for legacy call-sites: keep one move-shape snap resolver.
  return applyMoveShapeSnap(dxM, dyM);
  }

    // --- Quick Verify (transient measurement; no feature created) --------------------------
  // Contract:
  // - Tap 1: set start
  // - Tap 2: set end (shows dashed segment + overlay)
  // - Tap 3: clears previous and starts a new verify at that point
  // - Leaving the tool clears verify immediately
  function clearQuickVerify(reason){
    try { state.quickVerify = null; } catch(_) {}
    // draw() hides overlay by default; just redraw to remove segment instantly
    try { draw(); } catch(_) {}
  }

  function handleQuickVerifyClick(xPx,yPx){
    const world = canvasToWorld(xPx,yPx);

    if (!state.quickVerify || !state.quickVerify.points) {
      state.quickVerify = { points: [world] };
      draw();
      return;
    }

    const pts = state.quickVerify.points;
    if (pts.length < 2) {
      pts.push(world);
      draw();
      return;
    }

    // Third contact: start a new verify (previous disappears)
    state.quickVerify = { points: [world] };
    draw();
  }

// Handle measure tool taps (build / adjust currentPath of type 'measure')
  function handleMeasureClick(xPx,yPx){
    let world = canvasToWorld(xPx,yPx);

    // Measure truth: XY lock must constrain the measurement segment when enabled.
    // Contract:
    // - Anchor to the FIRST point (measure is a single segment)
    // - Snap Angle overrides Axis Lock (matches the UI message)
    try {
      if (state.currentPath && state.currentPath.type === 'measure' &&
          Array.isArray(state.currentPath.points) && state.currentPath.points.length) {

        const anchor = state.currentPath.points[0];

        // Mirror the draw-tool angle snap behavior when available.
        if (typeof applyAngleSnapFromLast === 'function' && anchor) {
          const snapped = applyAngleSnapFromLast(anchor, world.xM, world.yM);
          world = { xM: snapped.xM, yM: snapped.yM };
        }

        // XY lock constrains H/V unless Snap Angle is active.
        if (!(state.snapEnabled && state.snapMode === 'angle') && state.axisLock && anchor) {
          const dx = world.xM - anchor.xM;
          const dy = world.yM - anchor.yM;
          if (Math.abs(dx) >= Math.abs(dy)) world.yM = anchor.yM;
          else world.xM = anchor.xM;
        }
      }
    } catch(_) {}

    if (!state.currentPath || state.currentPath.type !== 'measure') {
      state.currentPath = { type:'measure', points:[world] };
    } else {
      const pts = state.currentPath.points;
      if (pts.length < 2) {
        pts.push(world);
      } else {
        pts[pts.length - 1] = world;
      }
    }
    // Auto-commit for Measure:
    // If Auto mode is enabled and the measurement segment is complete (2+ points),
    // commit immediately (mirrors Line/Area finish behavior).
    if (state.autoCommitLine && typeof canCommitCurrentPath === 'function' && canCommitCurrentPath()) {
      commitCurrentPath('autoCommit(measure)');
      if (typeof updateToolspace === 'function') updateToolspace();
      setModeLabel();
      return;
    }

    draw();
    if (typeof updateToolspace === 'function') updateToolspace();
    setModeLabel();
  }

// --- SUB-CHUNK 11.P1 BEGIN — PointerDown / capture setup ---
  canvas.addEventListener('mousedown', (evt)=>{
    // Step2 Sketch gate (toolized)
    if (state.tool === 'freeDraw') {
      const p = getMouseCanvasPos(evt);
      if (freeCaptureBeginAt(p.xPx, p.yPx)) return;
    }
    handleCanvasDown(evt);
  });

// --- SUB-CHUNK 11.P1 END ---
// --- SUB-CHUNK 11.P2 BEGIN — PointerMove / live interaction ---
  canvas.addEventListener('mousemove', (evt)=>{
    // Step2 Sketch gate (toolized)
    if (state.freeCapture && state.freeCapture.active) {
      const p = getMouseCanvasPos(evt);
      freeCaptureAddAt(p.xPx, p.yPx);
      return;
    }
    // Rotate tap+drag (mouse)
    if (state.tool === 'inspect' && state.editMode === 'rotate' && rotateDrag) {
      const { xPx, yPx } = getCanvasPos(evt);
      if (_rotateHandleMoveAt(xPx, yPx)) return;
    }

// Move shape drag: Inspect + Move shape (mouse)
    if (state.tool === 'inspect' &&
        state.editMode === 'moveShape' &&
        moveShapeDrag &&
        moveShapeDrag.featureId != null) {

      const { xPx, yPx } = getCanvasPos(evt);
      const world = canvasToWorldRawMouse(xPx, yPx);

      let dxM = world.xM - moveShapeDrag.startWorld.xM;
      let dyM = world.yM - moveShapeDrag.startWorld.yM;

      const snapped = applyMoveShapeSnapMouse(dxM, dyM);
      dxM = snapped.dxM;
      dyM = snapped.dyM;

      moveShapeDrag.guideLine = {
        a: { xM: moveShapeDrag.startWorld.xM, yM: moveShapeDrag.startWorld.yM },
        b: { xM: moveShapeDrag.startWorld.xM + dxM, yM: moveShapeDrag.startWorld.yM + dyM }
      };

      const originals = moveShapeDrag.originalsById || {};
      const ids = Array.isArray(moveShapeDrag.memberIds) && moveShapeDrag.memberIds.length
        ? moveShapeDrag.memberIds
        : [moveShapeDrag.featureId];

      for (const id of ids) {
        const f = state.features.find(x => x.id === id);
        const original = originals[id];
        if (!f || !original) continue;

        if (Array.isArray(original.points)) {
          f.points = original.points.map(p => ({ xM: p.xM + dxM, yM: p.yM + dyM }));
        }
        if (Array.isArray(original.holes)) {
          f.holes = original.holes.map(poly =>
            poly.map(p => ({ xM: p.xM + dxM, yM: p.yM + dyM }))
          );
        }
        if (typeof original.xM === 'number') f.xM = original.xM + dxM;
        if (typeof original.yM === 'number') f.yM = original.yM + dyM;
        if (typeof original.txM === 'number') f.txM = original.txM + dxM;
        if (typeof original.tyM === 'number') f.tyM = original.tyM + dyM;

        if (f.type === 'area') {
          f.areaM2 = areaWithHoles(f);
        }
      }

      draw();
      return;
    }

    // Inspect pan
    if(state.tool==='inspect' && navDragActive){
      const {xPx,yPx}=getCanvasPos(evt);
      navLastPos = { xPx, yPx };
      const dxPx = xPx - navDragStart.xPx;
      const dyPx = yPx - navDragStart.yPx;
      const ppm = getPxPerMeter();
      state.viewOriginXM = navDragStart.viewXM - dxPx/ppm;
      state.viewOriginYM = navDragStart.viewYM - dyPx/ppm;
      draw();
      return;
    }

    handleCanvasMove(evt);
  });
// --- chunk 11.3 · Mouse up (click vs pan vs move-shape) ------------------------------ 
// --- SUB-CHUNK 11.P2 END ---
// --- SUB-CHUNK 11.P3 BEGIN — PointerUp / cancel / commit cleanup ---
  window.addEventListener('mouseup',(evt)=>{
    // Step2 Sketch gate (toolized)
    if (state.freeCapture && state.freeCapture.active) {
      freeCaptureCommit();
      return;
    }
    // Rotate tap (mouse): pointer up without drag sets pivot on selected object
    if (state.tool === 'inspect' && state.editMode === 'rotate' && rotateDrag && rotateDrag.armed && !rotateDrag.active) {
      rotateDrag.armed = false;
      const sel = _getSelectedFeature && _getSelectedFeature();
      if (sel) {
        const pivot = rotateDrag.pivotCandidate || _pivotFromTap(sel, rotateDrag.downWorld) || null;
        // Cancel any pending preview and re-base at current state, then set pivot
        try { cancelRotateSession('pivotTap'); } catch(_){}
        beginRotateSessionWithPivot(pivot);
        if (typeof updateToolspace === 'function') updateToolspace();
        setModeLabel();
        draw();
      }
      return;
    }

// Finish rotate drag (mouse)
    if (state.tool === 'inspect' && state.editMode === 'rotate' && rotateDrag && rotateDrag.active) {
      rotateDrag.active = false;
      // Rotate behaves like Move Shape: drag is continuous, and commits as a single undo step on release.
      try { commitRotateSession('dragEnd'); } catch(_){}
      if (typeof updateToolspace === 'function') updateToolspace();
      setModeLabel();
      draw();
      return;
    }

    // Finish move shape drag
    if (state.tool === 'inspect' &&
        state.editMode === 'moveShape' &&
        moveShapeDrag &&
        moveShapeDrag.featureId != null) {

      moveShapeDrag = null;
      updateFeatureSelect();
      refreshSelectedInspector();

      return;
    }

    // Inspect click vs pan
    if (state.tool === 'inspect') {
      if (navDragActive && navDragStart && navLastPos) {
        const dx = navLastPos.xPx - navDragStart.xPx;
        const dy = navLastPos.yPx - navDragStart.yPx;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < 5) {
          const rect = canvas.getBoundingClientRect();
          const xPx = evt.clientX - rect.left;
          const yPx = evt.clientY - rect.top;
          handleInspectClickAt(xPx, yPx);
        }
      }
    }
    navDragActive = false;
  });

   // --- chunk 11.4 · Touch start / move / end (pinch + pan + move-shape) ---------------

  // --- sub-chunk 11.4A · Touch helpers (raw world + overrides) --------------------------

  // Raw world conversion (NO snapping) — used for Move Shape so we can apply our own snap logic.
  function canvasToWorldRaw(xPx, yPx){
    const ppm = getPxPerMeter();
    return {
      xM: xPx/ppm + state.viewOriginXM,
      yM: yPx/ppm + state.viewOriginYM
    };
  }

  // Units-aware distance override for Angle Dist (returns METERS)
  function getAngleDistOverrideMetersForMove(){
    return getAngleDistOverrideMeters();
  }

  // --- sub-chunk 11.4B · Touch move-shape snapping helpers ------------------------------

  // Grid snap for movement delta
  function snapDeltaGrid(dxM, dyM){
    const step = (state.snapStepM || state.metersPerGrid || 1);
    if (!Number.isFinite(step) || step <= 0) return { dxM, dyM };

    // When moving a shape, snap the *reference point position* to the grid so off-grid
    // objects can "attach" to grid intersections (delta-rounding alone cannot do that).
    if (moveShapeDrag && moveShapeDrag.refPoint) {
      const refNow = {
        xM: moveShapeDrag.refPoint.xM + dxM,
        yM: moveShapeDrag.refPoint.yM + dyM
      };

      const snapped = {
        xM: Math.round(refNow.xM / step) * step,
        yM: Math.round(refNow.yM / step) * step
      };

      return {
        dxM: dxM + (snapped.xM - refNow.xM),
        dyM: dyM + (snapped.yM - refNow.yM)
      };
    }

    // Fallback: snap the delta itself
    return {
      dxM: Math.round(dxM/step) * step,
      dyM: Math.round(dyM/step) * step
    };
  }

  // Nearest-vertex search that ignores the feature being moved
  function findNearestVertexIgnoring(xM, yM, maxDistM, ignoreIdOrIds){
    // ignoreIdOrIds can be:
    //   - a single feature id (legacy)
    //   - an array of feature ids (multi-move / group-move)
    //   - a Set of feature ids
    let ignoreSet = null;
    try{
      if (ignoreIdOrIds instanceof Set) {
        ignoreSet = ignoreIdOrIds;
      } else if (Array.isArray(ignoreIdOrIds)) {
        ignoreSet = new Set(ignoreIdOrIds.filter(v=>v!=null));
      } else if (ignoreIdOrIds != null) {
        ignoreSet = new Set([ignoreIdOrIds]);
      }
    }catch(_){ ignoreSet = null; }

    const maxD2 = maxDistM * maxDistM;
    let best = null;
    let bestD2 = Infinity;

    const feats = state.features || [];
    for (const f of feats) {
      if (!f) continue;
      if (ignoreSet && ignoreSet.has(f.id)) continue;

      if (Array.isArray(f.points)) {
        for (const p of f.points) {
          if (!p) continue;
          const dx = (p.xM - xM);
          const dy = (p.yM - yM);
          const d2 = dx*dx + dy*dy;
          if (d2 <= maxD2 && d2 < bestD2) { bestD2 = d2; best = { xM: p.xM, yM: p.yM }; }
        }
      }

      if (Array.isArray(f.holes)) {
        for (const ring of f.holes) {
          if (!Array.isArray(ring)) continue;
          for (const p of ring) {
            if (!p) continue;
            const dx = (p.xM - xM);
            const dy = (p.yM - yM);
            const d2 = dx*dx + dy*dy;
            if (d2 <= maxD2 && d2 < bestD2) { bestD2 = d2; best = { xM: p.xM, yM: p.yM }; }
          }
        }
      }

      // symbols/labels use xM/yM
      if (typeof f.xM === 'number' && typeof f.yM === 'number') {
        const dx = (f.xM - xM);
        const dy = (f.yM - yM);
        const d2 = dx*dx + dy*dy;
        if (d2 <= maxD2 && d2 < bestD2) { bestD2 = d2; best = { xM: f.xM, yM: f.yM }; }
      }
    }

    return best;
  }

  // Point snap for movement delta (snap ref point to external vertex)
  function snapDeltaPoint(dxM, dyM){
    if (!moveShapeDrag || !moveShapeDrag.refPoint) return { dxM, dyM };

    const step = (state.snapStepM || state.metersPerGrid || 1);
    const tol  = Math.max(step * 0.75, 0.05);

    const refNow = {
      xM: moveShapeDrag.refPoint.xM + dxM,
      yM: moveShapeDrag.refPoint.yM + dyM
    };

    const near = findNearestVertexIgnoring(refNow.xM, refNow.yM, tol, (Array.isArray(moveShapeDrag.memberIds) && moveShapeDrag.memberIds.length) ? moveShapeDrag.memberIds : moveShapeDrag.featureId);
    if (!near) return { dxM, dyM };

    return {
      dxM: dxM + (near.xM - refNow.xM),
      dyM: dyM + (near.yM - refNow.yM)
    };
  }

  // Angle-step snap for movement delta
  function snapDeltaAngleStep(dxM, dyM){
    if (!state.snapEnabled) return { dxM, dyM };
    if (state.snapMode !== 'angle') return { dxM, dyM };

    let stepDeg = parseFloat(angleSnapDegInput ? angleSnapDegInput.value : '45');
    if (!Number.isFinite(stepDeg) || stepDeg <= 0) stepDeg = 45;

    const dist = Math.hypot(dxM, dyM);
    if (!Number.isFinite(dist) || dist === 0) return { dxM, dyM };

    const rawAng = Math.atan2(dyM, dxM);
    const stepRad = stepDeg * Math.PI / 180;
    const snappedAng = Math.round(rawAng / stepRad) * stepRad;

    const distOverrideM = getAngleDistOverrideMetersForMove();
    const finalDist = (distOverrideM != null) ? distOverrideM : dist;

    return {
      dxM: Math.cos(snappedAng) * finalDist,
      dyM: Math.sin(snappedAng) * finalDist
    };
  }

  function applyMoveShapeSnap(dxM, dyM){
    // Axis Lock for Move Shape: constrain movement to the dominant axis.
    // (Snap Angle intentionally overrides Axis Lock, matching the UI message.)
    if (state.axisLock && state.snapMode !== 'angle') {
      if (Math.abs(dxM) >= Math.abs(dyM)) dyM = 0;
      else dxM = 0;
    }

    if (!state.snapEnabled) return { dxM, dyM };
    if (state.snapMode === 'angle') return snapDeltaAngleStep(dxM, dyM);
    if (state.snapMode === 'point') return snapDeltaPoint(dxM, dyM);
    return snapDeltaGrid(dxM, dyM); // 'free' = grid snap
  }

  // --- sub-chunk 11.4C · Touchstart (pinch init, nav init, move-shape init) -------------

    // --- SUB-CHUNK 11.T1 BEGIN — Touch handler (touchstart) ---
  canvas.addEventListener('touchstart', (e)=>{
    // Step2 Sketch gate (toolized)
    if (state.tool === 'freeDraw' && e.touches && e.touches.length === 1) {
      const p = getTouchCanvasPos(e.touches[0]);
      if (freeCaptureBeginAt(p.xPx, p.yPx)) {
        e.preventDefault();
        return;
      }
    }
    e.preventDefault();
    // Find Area (touch): tap inside a closed loop (lines) to generate an Area object
    if (state.tool === 'findArea' && e.touches && e.touches.length === 1) {
      const p = getTouchCanvasPos(e.touches[0]);
      const world = (typeof canvasToWorldRawMouse === 'function')
        ? canvasToWorldRawMouse(p.xPx, p.yPx)
        : (typeof canvasToWorldRaw === 'function')
          ? canvasToWorldRaw(p.xPx, p.yPx)
          : { xM: p.xPx/getPxPerMeter() + state.viewOriginXM, yM: p.yPx/getPxPerMeter() + state.viewOriginYM };

      if (!tryFindAreaAtWorldPoint(world.xM, world.yM)) {
        try { toast('Find Area: no closed loop found at that point'); } catch(_){}
      }
      return;
    }
    // BG image calibration capture gate must override Inspect/Nav on touch devices
    if (state._bgCal && state._bgCal.active) {
      handleCanvasDown(e);
      return;
    }
    const touches = e.touches;

    if(touches.length >= 2){
      // Stability-first pinch zoom:
      // - Only adjusts DISPLAY zoom (state.gridPx)
      // - Uses RAF throttling (touchmove may exceed refresh rate)
      // - Anchors world under the pinch midpoint to the pinch midpoint on screen (prevents jumping)

      // Initialize pinch snapshot
      const t0 = getTouchCanvasPos(touches[0]);
      const t1 = getTouchCanvasPos(touches[1]);
      const dx = (t1.xPx - t0.xPx);
      const dy = (t1.yPx - t0.yPx);
      const dist = Math.hypot(dx, dy) || 1;

      const midX = (t0.xPx + t1.xPx) / 2;
      const midY = (t0.yPx + t1.yPx) / 2;

      navGesture.active = true;
      navGesture.startDist = dist;
      navGesture.startGridPx = state.gridPx;
      navGesture.startViewOriginXM = state.viewOriginXM;
      navGesture.startViewOriginYM = state.viewOriginYM;
      navGesture.startMidWorld = canvasToWorldRaw(midX, midY);

      navGesture.latestDist = dist;
      navGesture.latestMidPx = { xPx: midX, yPx: midY };
      navGesture.pendingGridPx = state.gridPx;

      // Cancel any drag/nav state that would fight pinch
      navDragActive = false;
      navLastPos = null;

      return;

    } else if(touches.length === 1){
      if(state.tool==='inspect'){
        const {xPx,yPx}=getCanvasPos(e);

        // Rotate begins here on touch devices (inspect + rotate)
        if (state.editMode === 'rotate' && state.selectedId != null) {
          const sel = _getSelectedFeature && _getSelectedFeature();
          if (sel) {
            const world = canvasToWorldRaw(xPx, yPx);

            // If a preview exists and user begins a new gesture, re-base on current live geometry
            if (rotateSession && rotateSession.featureId === sel.id && rotateSession.pending) {
              const liveNow = _findFeatureById(sel.id);
              if (liveNow) rotateSession.base = deepClone(liveNow);
              rotateSession.pending = false;
              rotateSession.pendingDeltaDeg = 0;
            }

            rotateDrag.armed = true;
            rotateDrag.active = false;
            rotateDrag.downXPx = xPx;
            rotateDrag.downYPx = yPx;
            rotateDrag.downWorld = world;
            rotateDrag.pivotCandidate = _pivotFromTap(sel, world) || null;
            return;
          }
        }

        // Move shape begins here on touch devices
        if (state.editMode === 'moveShape' && state.selectedId != null) {
          const f = state.features.find(x=>x.id===state.selectedId);
          if (f) {
            pushHistory('moveShape');

            const startWorld = canvasToWorldRaw(xPx, yPx);

            // Reference point for point-snap
            let refPoint = { xM: startWorld.xM, yM: startWorld.yM };

            // Prefer the point the user actually grabbed (best for 2‑point lines).
            // If the feature has explicit vertices, use the nearest vertex as the move reference.
            if (Array.isArray(f.points) && f.points.length) {
              let best = f.points[0];
              let bestD2 = Infinity;
              for (const p of f.points) {
                const dx = (p.xM - startWorld.xM);
                const dy = (p.yM - startWorld.yM);
                const d2 = dx*dx + dy*dy;
                if (d2 < bestD2) { bestD2 = d2; best = p; }
              }
              refPoint = { xM: best.xM, yM: best.yM };
            } else if (f.shapeMeta && f.shapeMeta.kind === 'circle' &&
                       Number.isFinite(f.shapeMeta.cxM) && Number.isFinite(f.shapeMeta.cyM) && Number.isFinite(f.shapeMeta.rM)) {
              // Circle: snap ref point to center or nearest perimeter point (CAD feel).
              const cx = f.shapeMeta.cxM, cy = f.shapeMeta.cyM, r = Math.max(0, f.shapeMeta.rM);
              const dx = startWorld.xM - cx;
              const dy = startWorld.yM - cy;
              const d  = Math.hypot(dx, dy) || 0;
              // If the grab is inside the circle, treat the center as the natural ref; otherwise perimeter.
              if (d <= r) {
                refPoint = { xM: cx, yM: cy };
              } else if (r > 0) {
                refPoint = { xM: cx + (dx/d)*r, yM: cy + (dy/d)*r };
              } else {
                refPoint = { xM: cx, yM: cy };
              }
            } else if (Number.isFinite(f.xM) && Number.isFinite(f.yM)) {
              // Anchored objects (labels/symbols)
              refPoint = { xM: f.xM, yM: f.yM };
            }

            // Group-aware move: if the selected feature has a groupId, drag moves the whole group.
            // Multi-select override: if Multi is ON and multiple ids are selected, drag moves that explicit set.
            let _gid = (f && f.groupId != null && String(f.groupId).trim() !== '') ? String(f.groupId).trim() : null;
            let _members = (_gid == null) ? [f] : state.features.filter(ff => ff && ff.groupId === _gid);

            if (state.multiSelectEnabled && Array.isArray(state.selectedIds) && state.selectedIds.length > 1) {
              _gid = null;
              _members = state.selectedIds
                .map(id => state.features.find(ff => ff && ff.id === id))
                .filter(Boolean);
            }
const _originalsById = {};
            for (const mf of _members) { _originalsById[mf.id] = deepClone(mf); }

            moveShapeDrag = {
              featureId: f.id,
              groupId: _gid,
              memberIds: _members.map(mf => mf.id),
              startWorld,
              originalsById: _originalsById,
              guideLine: null,
              refPoint
            };
          }
          return;
        }

        if (state.editMode === 'movePoint' ||
            state.editMode === 'addVertex' ||
            state.editMode === 'removeVertex' ||
            state.editMode === 'cutout') {
          handleInspectClickAt(xPx, yPx);
          return;
        }

        navDragActive = true;
        navDragStart = {
          xPx, yPx,
          viewXM: state.viewOriginXM,
          viewYM: state.viewOriginYM
        };
        navLastPos = { xPx, yPx };

      } else {
        handleCanvasDown(e);
      }
    }
  }, {passive:false});

  // --- sub-chunk 11.4D · Touchmove (pinch zoom, move-shape drag, nav pan) ---------------

    // --- SUB-CHUNK 11.T1 END — Touch handler (touchstart) ---

  // --- SUB-CHUNK 11.T2 BEGIN — Touch handler (touchmove) ---
  canvas.addEventListener('touchmove', (e)=>{
    // Step2 Sketch gate (toolized)
    if (state.freeCapture && state.freeCapture.active && e.touches && e.touches.length === 1) {
      const p = getTouchCanvasPos(e.touches[0]);
      freeCaptureAddAt(p.xPx, p.yPx);
      e.preventDefault();
      return;
    }
    e.preventDefault();
    const touches = e.touches;

    if(touches.length >= 2){
      // Pinch zoom (RAF-throttled)
      if (!navGesture.active) {
        // If we somehow missed the touchstart (e.g., finger added mid-gesture), re-init.
        const t0 = getTouchCanvasPos(touches[0]);
        const t1 = getTouchCanvasPos(touches[1]);
        const dx = (t1.xPx - t0.xPx);
        const dy = (t1.yPx - t0.yPx);
        const dist = Math.hypot(dx, dy) || 1;
        const midX = (t0.xPx + t1.xPx) / 2;
        const midY = (t0.yPx + t1.yPx) / 2;

        navGesture.active = true;
        navGesture.startDist = dist;
        navGesture.startGridPx = state.gridPx;
        navGesture.startViewOriginXM = state.viewOriginXM;
        navGesture.startViewOriginYM = state.viewOriginYM;
        navGesture.startMidWorld = canvasToWorldRaw(midX, midY);

        navGesture.latestDist = dist;
        navGesture.latestMidPx = { xPx: midX, yPx: midY };
        navGesture.pendingGridPx = state.gridPx;
      } else {
        const t0 = getTouchCanvasPos(touches[0]);
        const t1 = getTouchCanvasPos(touches[1]);
        const dx = (t1.xPx - t0.xPx);
        const dy = (t1.yPx - t0.yPx);
        const dist = Math.hypot(dx, dy) || 1;
        const midX = (t0.xPx + t1.xPx) / 2;
        const midY = (t0.yPx + t1.yPx) / 2;

        navGesture.latestDist = dist;
        navGesture.latestMidPx = { xPx: midX, yPx: midY };
      }

      // Convert pinch distance ratio into DISPLAY zoom (gridPx)
      const ratio = (navGesture.latestDist / (navGesture.startDist || 1));
      // Deadzone to suppress micro-jitter from touch noise
      if (Math.abs(ratio - 1) < 0.002) {
        return;
      }

      let targetGridPx = navGesture.startGridPx * ratio;
      targetGridPx = clamp(targetGridPx, 5, 80);

      navGesture.pendingGridPx = targetGridPx;

      // RAF throttle: apply at most once per visual frame
      if (!navGesture.rafId) {
        navGesture.rafId = requestAnimationFrame(()=>{
          navGesture.rafId = 0;
          if (!navGesture.active || navGesture.pendingGridPx == null || !navGesture.startMidWorld || !navGesture.latestMidPx) return;

          // Apply zoom
          state.gridPx = navGesture.pendingGridPx;

          // Keep manual zoom UI (px/grid) in sync to prevent "jump" on next button tap
          if (gridPxInput) gridPxInput.value = String(Math.round(state.gridPx));
          updateStatusScale();

          // Keep the world point under pinch midpoint stable at the pinch midpoint
          const ppm = getPxPerMeter();
          state.viewOriginXM = navGesture.startMidWorld.xM - (navGesture.latestMidPx.xPx / ppm);
          state.viewOriginYM = navGesture.startMidWorld.yM - (navGesture.latestMidPx.yPx / ppm);

          requestDraw();
        });
      }
      return;

    } else if(state.tool==='inspect' &&
              state.editMode === 'rotate' &&
              rotateDrag &&
              touches.length === 1){

      const {xPx,yPx} = getCanvasPos(e);
      if (_rotateHandleMoveAt(xPx, yPx)) { return; }

    } else if(state.tool==='inspect' &&
              state.editMode==='moveShape' &&
              moveShapeDrag &&
              touches.length === 1){

      const {xPx,yPx} = getCanvasPos(e);
      const world = canvasToWorldRaw(xPx, yPx);

      let dxM = world.xM - moveShapeDrag.startWorld.xM;
      let dyM = world.yM - moveShapeDrag.startWorld.yM;

      const snapped = applyMoveShapeSnap(dxM, dyM);
      dxM = snapped.dxM;
      dyM = snapped.dyM;

      moveShapeDrag.guideLine = {
        a: { xM: moveShapeDrag.startWorld.xM, yM: moveShapeDrag.startWorld.yM },
        b: { xM: moveShapeDrag.startWorld.xM + dxM, yM: moveShapeDrag.startWorld.yM + dyM }
      };

      const originals = moveShapeDrag.originalsById || {};
      const ids = Array.isArray(moveShapeDrag.memberIds) && moveShapeDrag.memberIds.length
        ? moveShapeDrag.memberIds
        : [moveShapeDrag.featureId];

      for (const id of ids) {
        const f = state.features.find(x=>x.id===id);
        const original = originals[id];
        if (!f || !original) continue;

        if (Array.isArray(original.points)) {
          f.points = original.points.map(p=>({xM:p.xM+dxM, yM:p.yM+dyM}));
        }
        if (Array.isArray(original.holes)) {
          f.holes = original.holes.map(poly =>
            poly.map(p=>({xM:p.xM+dxM, yM:p.yM+dyM}))
          );
        }
        if (typeof original.xM==='number')  f.xM  = original.xM  + dxM;
        if (typeof original.yM==='number')  f.yM  = original.yM  + dyM;
        if (typeof original.txM==='number') f.txM = original.txM + dxM;
        if (typeof original.tyM==='number') f.tyM = original.tyM + dyM;

        if (f.type === 'area') f.areaM2 = areaWithHoles(f);
      }

      draw();} else if(navDragActive && touches.length === 1 && state.tool==='inspect'){
      const {xPx,yPx}=getCanvasPos(e);
      navLastPos = { xPx, yPx };
      const dxPx = xPx - navDragStart.xPx;
      const dyPx = yPx - navDragStart.yPx;
      const ppm = getPxPerMeter();
      state.viewOriginXM = navDragStart.viewXM - dxPx/ppm;
      state.viewOriginYM = navDragStart.viewYM - dyPx/ppm;
      draw();

    } else if(!navGesture.active && !navDragActive && touches.length === 1){
      handleCanvasMove(e);
    }
  }, {passive:false});

  // --- sub-chunk 11.4E · Touchend (gesture end, click-vs-pan, drag end) ----------------

    // --- SUB-CHUNK 11.T2 END — Touch handler (touchmove) ---

  // --- SUB-CHUNK 11.T3 BEGIN — Touch handler (touchend) ---
  canvas.addEventListener('touchend', (e)=>{
    // Step2 Sketch gate (toolized)
    if (state.freeCapture && state.freeCapture.active) {
      freeCaptureCommit();
      e.preventDefault();
      return;
    }
    if(e.touches.length < 2){
      // Finalize pinch: snap to integer step and sync UI to avoid next-step discontinuities
      state.gridPx = Math.max(5, Math.min(80, Math.round(state.gridPx)));
      if (gridPxInput) gridPxInput.value = String(state.gridPx);
      updateStatusScale();
      requestDraw();

      navGesture.active = false;
      navGesture.pendingGridPx = null;
      navGesture.latestMidPx = null;
      navGesture.latestDist = 0;
      if (navGesture.rafId) {
        cancelAnimationFrame(navGesture.rafId);
        navGesture.rafId = 0;
      }
    }

    if(e.touches.length === 0){
      if (state.tool === 'inspect') {
        if (state.editMode === 'moveShape' &&
            moveShapeDrag &&
            moveShapeDrag.featureId != null) {

          moveShapeDrag = null;
          updateFeatureSelect();
          refreshSelectedInspector();

          draw();

        } else if (state.editMode === 'rotate' && rotateDrag) {
          // Tap pivot: touchend with no drag sets pivot on selected object
          if (rotateDrag.armed && !rotateDrag.active) {
            rotateDrag.armed = false;
            const sel = _getSelectedFeature && _getSelectedFeature();
            if (sel) {
              const pivot = rotateDrag.pivotCandidate || _pivotFromTap(sel, rotateDrag.downWorld) || null;
              try { cancelRotateSession('pivotTap'); } catch(_){}
              beginRotateSessionWithPivot(pivot);
            }
            if (typeof updateToolspace === 'function') updateToolspace();
            setModeLabel();
            draw();
            e.preventDefault();
            return;
          }
          // End rotate drag
          if (rotateDrag.active) {
            rotateDrag.active = false;
            // Rotate behaves like Move Shape: drag is continuous, and commits as a single undo step on release.
            try { commitRotateSession('dragEnd'); } catch(_){}
            if (typeof updateToolspace === 'function') updateToolspace();
            setModeLabel();
            draw();
            e.preventDefault();
            return;
          }

        } else if (navDragActive && navDragStart && navLastPos) {
          const dx = navLastPos.xPx - navDragStart.xPx;
          const dy = navLastPos.yPx - navDragStart.yPx;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist < 5 && e.changedTouches && e.changedTouches[0]) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.changedTouches[0];
            const xPx = touch.clientX - rect.left;
            const yPx = touch.clientY - rect.top;
            handleInspectClickAt(xPx, yPx);
          }
        }
      }
      navDragActive = false;
    }
  }, {passive:false});
// --- SUB-CHUNK 11.P3 END ---
  
// --- SUB-CHUNK 11.T4 BEGIN — Touch handler (touchcancel) ---
  canvas.addEventListener('touchcancel', (e)=>{
    // Treat cancel like end: stop pinch + free capture safely
    if (state.freeCapture && state.freeCapture.active) {
      freeCaptureCommit();
    }
    navGesture.active = false;
    navGesture.pendingGridPx = null;
    navGesture.latestMidPx = null;
    navGesture.latestDist = 0;
    if (navGesture.rafId) {
      cancelAnimationFrame(navGesture.rafId);
      navGesture.rafId = 0;
    }
    // Also stop any nav drag state
    navDragActive = false;
    navLastPos = null;

    requestDraw();
  });
// --- SUB-CHUNK 11.T4 END — Touch handler (touchcancel) ---

// --- SUB-CHUNK 11.T3 END — Touch handler (touchend) ---

// --- chunk end 11 ---------------------------------------------------------------
  // --- Finish path, delete, clear, undo/redo chunk 13 ---------------------------------

  // SCRIPT PART 2.1 END (LLM ANCHOR)
</script>

<script>

  // SCRIPT PART 2.2 BEGIN (LLM ANCHOR)
// SUB-CHUNK 13.B1 BEGIN — Bend Finish/Commit integration points (safe-edit boundary)
    // SUB-CHUNK 13.0A BEGIN — Canonical path commit function (Finish Path refactor)
  // PROTECT: This is the single source of truth for committing state.currentPath into state.features.
  // UI triggers (Finish button, future Auto button, etc.) must call commitCurrentPath() instead of duplicating logic.
  function canCommitCurrentPath(){
    const path = state.currentPath;
    if(!path || !path.points || path.points.length < 2) return false;

    if(path.type === 'area')    return path.points.length >= 3;
    if(path.type === 'road')    return true;
    if(path.type === 'lane')    return true;
    if(path.type === 'measure') return true;

    return false;
  }

  function commitCurrentPath(reason){
    const path = state.currentPath;

    // Mirror legacy Finish Path behavior:
    // - If path is missing/too short, clear currentPath and redraw (no-op).
    if(!canCommitCurrentPath()){
      state.currentPath = null;
      draw();
      return false;
    }

    // Commit logic is intentionally identical to the legacy finishPathBtn click handler.
    if(path.type==='area' && path.points.length>=3){
      pushHistory('addArea');
      const feature={
        id:state.nextId++,
        // Optional shape metadata (e.g., circles built as shapes)
        shapeType: (path && path.__shapeType) ? path.__shapeType : null,
        shapeMeta: (path && path.__shapeMeta) ? path.__shapeMeta : null,
        type:'area',
        fillColor: (state.areaDefaults && state.areaDefaults.color) ? String(state.areaDefaults.color) : '#38bdf8',
        fillOpacity: (state.areaDefaults && typeof state.areaDefaults.opacity==='number') ? state.areaDefaults.opacity : 0.12,
        points:path.points.slice(),
        holes: [],
        name:'',
        areaM2: polygonAreaMeters2(path.points)
      };
      state.features.push(feature);
      selectFeatureById(feature.id);

    } else if(path.type==='road' || path.type==='lane'){
      pushHistory('addLine');

      // --- sub-chunk 13.1a · Persist line style per feature (backward-safe) ------------
      let ls = 'solid';
      if (path.type === 'lane') {
        ls = (state.lineStyle === 'centerline') ? 'centerline' : 'dashed';
      }
      // road remains solid
      // --- end sub-chunk 13.1a --------------------------------------------------------

      // --- sub-chunk 13.1b · Style fields (schema-safe defaults; no visual change yet) -
      // NOTE:
      // - These are optional per-feature overrides.
      // - Renderer will start honoring them in a later step.
      // - Defaults preserve today's look.
      let defaultWidthPx = (path.type === 'road') ? 6 : 2;
      let defaultColor   = (path.type === 'road') ? '#e5e7eb' : '#facc15';

      // Dash preset is tied to lineStyle (solid = none)
      let defaultDash = null;
      if (path.type === 'lane') {
        defaultDash = (ls === 'centerline') ? [18, 6, 3, 6] : [10, 8];
      }
      // Apply user defaults from Properties → Line panel (persistent)
      try{
        const d = (state && state.lineDefaults) ? state.lineDefaults : null;
        if (d){
          if (Number.isFinite(Number(d.widthPx))) defaultWidthPx = Number(d.widthPx);
          if (typeof d.color === 'string' && d.color.length) defaultColor = d.color;

          const style = String(d.style || 'auto');
          if (style && style !== 'auto'){
            ls = style;
            if (style === 'solid') {
                  defaultDash = null;
                } else if (style === 'dashed') {
                  defaultDash = [10, 8];
                } else if (style === 'centerline') {
                  defaultDash = [18, 6, 3, 6];
                } else if (style === 'custom') {
                  const parsed = (typeof parseDashList === 'function') ? parseDashList(state.lineDefaults && state.lineDefaults.customDash) : null;
                  defaultDash = (parsed && parsed.length >= 2) ? parsed : [10, 8];
                }
          }
        }
      }catch(_){}

      // --- end sub-chunk 13.1b --------------------------------------------------------

      const feature = {
        id: state.nextId++,
        // Optional shape metadata (e.g., circles built as line-shapes)
        shapeType: (path && path.__shapeType) ? path.__shapeType : null,
        shapeMeta: (path && path.__shapeMeta) ? path.__shapeMeta : null,
        type: path.type,
        points: path.points.slice(),
        lineStyle: ls,

        // Optional style overrides (safe if absent in older drafts)
        strokeWidthPx: defaultWidthPx,
        strokeColor: defaultColor,
        strokeDash: defaultDash
      };

      state.features.push(feature);
      selectFeatureById(feature.id);

    } else if(path.type==='measure' && path.points.length>=2){
      pushHistory('addMeasure');
      const pts = path.points.slice(0,2);
      const len = lineLengthMeters(pts);
      const dx  = pts[1].xM - pts[0].xM;
      const dy  = pts[1].yM - pts[0].yM;
      const ang = Math.atan2(dy,dx)*180/Math.PI;

      // Pull persistent defaults from Measure panel (schema-safe; preserves current look if unset)
      let defaultWidthPx = 1.5;
      let defaultColor   = '#a855f7';
      let defaultDash    = [10, 8];
      let defaultMode    = 'distance';
      let defaultDecimals= 2;

      try{
        const d = (state && state.measureDefaults) ? state.measureDefaults : null;
        if (d){
          if (Number.isFinite(Number(d.widthPx))) defaultWidthPx = Number(d.widthPx);
          if (typeof d.color === 'string' && d.color.length) defaultColor = d.color;

          const style = String(d.style || 'auto');
          if (style && style !== 'auto'){
            if (style === 'solid') defaultDash = null;
            else if (style === 'dashed') defaultDash = [10, 8];
            else if (style === 'custom'){
              const parsed = (typeof parseDashList === 'function') ? parseDashList(d.customDash) : null;
              defaultDash = (parsed && parsed.length >= 2) ? parsed : [10, 8];
            }
          }

          const mm = String(d.mode || '').toLowerCase();
          if (mm) defaultMode = mm;

          if (Number.isFinite(Number(d.decimals))) defaultDecimals = Math.max(0, Math.min(6, Math.round(Number(d.decimals))));
        }
      }catch(_){}

      const _lbl = _defaultMeasureLabelPos(pts);
      const feature = {
        id: state.nextId++,
        type: 'measure',
        points: pts,

        // Derived (kept truthful from geometry; drawMeasureFeature will keep synced)
        length: len,
        angleDeg: ang,

        // Optional style overrides (so defaults actually apply)
        strokeWidthPx: defaultWidthPx,
        strokeColor: defaultColor,
        strokeDash: defaultDash,

        // Label preferences (per-measure, seeded from defaults)
        measureMode: defaultMode,
        measureDecimals: defaultDecimals,

        // Persisted label position (adjustable via Move Point)
        txM: _lbl.xM,
        tyM: _lbl.yM
      };
      state.features.push(feature);
      selectFeatureById(feature.id);
    }

    state.currentPath = null;
    draw();

    // Keep context rail labels in sync (Auto button may switch between FINISH and ON/OFF).
    if (typeof updateToolspace === 'function') updateToolspace();

    return true;
  }
  // SUB-CHUNK 13.0A END — Canonical path commit function (Finish Path refactor)

    // SUB-CHUNK 13.0B BEGIN — Finish Path UI triggers (sidebar optional)
  // PROTECT: Sidebar Finish button may be removed later. Missing element must never crash bindings.
  if (finishPathBtn){
    finishPathBtn.addEventListener('click', ()=>{
      // Bend Finish: if a Bend preview is pending, commit it instead of creating a new feature
      try {
        if (state && state.bend && state.bend.pending && state.bend.previewPointsFull) {
          state.bend.pending = false;
          commitBendSession('finishBtn');
          return;
        }
      } catch(_) {}
      commitCurrentPath('finishPathBtn');
    });
  }
  // SUB-CHUNK 13.0B END — Finish Path UI triggers (sidebar optional)

  deleteSelectedBtn.addEventListener('click',()=>{
    const hasSet = Array.isArray(state.selectedIds) && state.selectedIds.length > 0;
    const multi = !!state.multiSelectEnabled && hasSet;
    const targets = multi ? state.selectedIds.slice() : (state.selectedId!=null ? [state.selectedId] : []);
    if (targets.length === 0) return;

    // Lock gate: deny if ANY target is locked (atomic)
    for (const id of targets){
      const f = state.features.find(x=>x && x.id===id);
      if (f && _isFeatureLocked && _isFeatureLocked(f)) { _denyLockedEdit('delete', f); return; }
    }

    pushHistory('deleteSelected');
    state.features = state.features.filter(f=>!targets.includes(f.id));

    // Clear selection after delete (truth)
    state.selectedIds = [];
    state.selectedId = null;

    // Restore background image (persisted as Data URL) — safe on all platforms
    try{
      const bi = (snap.bgImage && typeof snap.bgImage === 'object') ? snap.bgImage : null;

      // Always restore placement/controls if present, even if no dataUrl
      if (bi){
        if (typeof bi.opacity === 'number' && isFinite(bi.opacity)) state.bgImageOpacity = clamp(bi.opacity, 0, 1);
        if (typeof bi.mpp === 'number' && isFinite(bi.mpp)) state.bgImageMpp = bi.mpp;
        if (typeof bi.originXM === 'number' && isFinite(bi.originXM)) state.bgImageOriginXM = bi.originXM;
        if (typeof bi.originYM === 'number' && isFinite(bi.originYM)) state.bgImageOriginYM = bi.originYM;
        if (typeof bi.name === 'string') state.bgImageName = bi.name;
        if (typeof bi.dataUrl === 'string') state.bgImageDataUrl = bi.dataUrl;
      }

      // Rebuild runtime image object if we have a dataUrl
      if (state.bgImageDataUrl && typeof state.bgImageDataUrl === 'string'){
        const img = new Image();
        img.onload = ()=>{
          state._bgImageObj = img;
          state.bgImageEnabled = !!(bi ? bi.enabled : true);
          // Keep UI in sync if helper exists
          if (typeof setBgImageEnabled === 'function') setBgImageEnabled(!!state.bgImageEnabled);
          if (typeof syncBgImageControls === 'function') syncBgImageControls();
          draw();
        };
        img.onerror = ()=>{
          state._bgImageObj = null;
          state.bgImageEnabled = false;
          if (typeof setBgImageEnabled === 'function') setBgImageEnabled(false);
          try{ toast('BG image failed to load from draft'); }catch(_){}
          draw();
        };
        img.src = state.bgImageDataUrl;
      } else {
        state._bgImageObj = null;
        state.bgImageEnabled = !!(bi && bi.enabled);
        if (typeof setBgImageEnabled === 'function') setBgImageEnabled(!!state.bgImageEnabled);
      }
    }catch(_){}

    setEditMode('none');
    updateFeatureSelect(); refreshSelectedInspector(); draw();
  });

  clearAllBtn.addEventListener('click',()=>{
    if(!confirm('Clear all lines, areas, labels and symbols?')) return;
    pushHistory('clearAll');
    state.features=[]; state.currentPath=null; state.selectedId=null;

    // Also clear the draft name to prevent accidental overwrite after a wipe.
    if (draftNameInput) draftNameInput.value = '';
    if (typeof draftJobIdInput !== 'undefined' && draftJobIdInput) draftJobIdInput.value = '';
    if (typeof loadDraftSelect !== 'undefined' && loadDraftSelect) loadDraftSelect.value = '';

    setEditMode('none');
    updateFeatureSelect(); refreshSelectedInspector(); draw();

	    // Session recovery: a deliberate wipe becomes the new baseline.
	    // Do not prompt to "recover" an intentionally cleared canvas.
	    try{ if(typeof clearSessionRecoverySnapshot === 'function') clearSessionRecoverySnapshot(); }catch(_){ }
	    _fdDirtySinceSave = false;
	    _fdLastBaselineAt = Date.now();
	    try{ localStorage.setItem(FD_SESSION_META_KEY, JSON.stringify({ lastSaveAt: (_fdLastManualSaveAt||0), lastBaselineAt: (_fdLastBaselineAt||0) })); }catch(_){ }
  });

  undoBtn.addEventListener('click', undo);
  redoBtn.addEventListener('click', redo);
  
// SUB-CHUNK 13.B1 END — Bend Finish/Commit integration points (safe-edit boundary)
// --- chunk end 13 ---------------------------------------------------------------
  // --- Inspector field events chunk 14 -------------------------------------------------
  // --- chunk 14.1 · Generic fields (group, length, shared) ----------------------------- 

  propGroupInput.addEventListener('input',()=>{
    const f=state.features.find(x=>x.id===state.selectedId);
    if(!f) return;
    const v = String(propGroupInput.value || '').trim();
    if(v===''){
      // Normalize: blank means “no group” (avoid ghost-group with groupId === '')
      delete f.groupId;
    }else{
      f.groupId = v;
    }
  });
// Convert user-entered distance to meters (internal storage)
  function inputDistToMeters(v){
    const n = parseFloat(v);
    if(!Number.isFinite(n) || n <= 0) return null;
    return inputDistToMetersAny(n);
  }

  selLengthInput.addEventListener('change',()=>{
    const f = state.features.find(x=>x.id===state.selectedId);
    if(!f || (f.type!=='road' && f.type!=='lane' && f.type!=='measure')) return;
    if(f.points.length !== 2) return;

    const desiredM = inputDistToMeters(selLengthInput.value);
    if(desiredM == null) return;

    const _sel = _getSelectedFeature ? _getSelectedFeature() : null;

    if (_sel && _isFeatureLocked(_sel)) { _denyLockedEdit('length', _sel); return; }

    pushHistory('lengthEdit');

    const p1=f.points[0], p2=f.points[1];
    const cur=lineLengthMeters([p1,p2]);
    if(cur===0) return;

    const dirX=(p2.xM-p1.xM)/cur;
    const dirY=(p2.yM-p1.yM)/cur;

    f.points[1] = { xM: p1.xM + dirX * desiredM, yM: p1.yM + dirY * desiredM };

    // Keep measure derived fields truthful (export/snapshot + label)
    if (f.type === 'measure') {
      try{
        f.length = lineLengthMeters(f.points);
        const dx = f.points[1].xM - f.points[0].xM;
        const dy = f.points[1].yM - f.points[0].yM;
        f.angleDeg = Math.atan2(dy,dx)*180/Math.PI;
      }catch(_){ }
    }

    draw();
    updateFeatureSelect();
    refreshSelectedInspector();
  });

  // --- sub-chunk 14.1B · Line style fields (width / color / dash) ----------------------

  function parseDashList(str){
    if (!str) return null;
    const parts = String(str).split(',').map(s=>s.trim()).filter(Boolean);
    if (!parts.length) return null;
    const nums = parts.map(Number).filter(n=>Number.isFinite(n) && n > 0);
    return nums.length ? nums : null;
  }

  function isLineLikeSelected(){
    const f = state.features.find(x=>x.id===state.selectedId);
    if (!f) return null;
    if (f.type !== 'road' && f.type !== 'lane' && f.type !== 'measure') return null;
    return f;
  }

  if (selStrokeWidthInput){
    selStrokeWidthInput.addEventListener('change', ()=>{
      const f = isLineLikeSelected();
      if (!f) return;

      const w = Number(selStrokeWidthInput.value);
      if (!Number.isFinite(w) || w <= 0) return;

      pushHistory('strokeWidth');
      f.strokeWidthPx = w;

      draw();
      refreshSelectedInspector();
    });
  }

  if (selStrokeColorInput){
    selStrokeColorInput.addEventListener('input', ()=>{
      // Multi-select aware stroke color editing:
      // - If multi-select is ON, apply to all selected line-like features (road/lane).
      // - Else apply to the single selected line-like feature.
      const c = String(selStrokeColorInput.value || '').trim();
      if (!c) return;

      // Measure: apply only to the selected measure (no multi-broadcast)
      const _sf = state.features.find(x=>x.id===state.selectedId);
      if (_sf && _sf.type === 'measure') {
        const _sel = _getSelectedFeature ? _getSelectedFeature() : null;
        if (_sel && _isFeatureLocked(_sel)) { _denyLockedEdit('stroke', _sel); return; }
        pushHistory('strokeColor');
        _sf.strokeColor = c;
        if (selStrokeColorText) selStrokeColorText.textContent = c.toLowerCase();
        draw();
        refreshSelectedInspector();
        return;
      }

      const ids = (state && state.multiSelectEnabled && Array.isArray(state.selectedIds) && state.selectedIds.length)
        ? state.selectedIds.slice()
        : [state.selectedId];

      const targets = (Array.isArray(state.features) ? ids.map(id=>state.features.find(x=>x && x.id===id)) : [])
        .filter(f=>f && (f.type === 'road' || f.type === 'lane'));

      if (!targets.length) return;

      // Deny locked edits if any target is locked.
      for (const t of targets){
        if (typeof _isFeatureLocked === 'function' && _isFeatureLocked(t)){
          if (typeof _denyLockedEdit === 'function') _denyLockedEdit('stroke', t);
          return;
        }
      }

      pushHistory('strokeColor');
      for (const t of targets){
        t.strokeColor = c;
      }

      if (selStrokeColorText) selStrokeColorText.textContent = c.toLowerCase();

      draw();
      refreshSelectedInspector();
    });
  }

  if (selStrokePatternSelect){
    selStrokePatternSelect.addEventListener('change', ()=>{
      const f = isLineLikeSelected();
      if (!f) return;

      const mode = String(selStrokePatternSelect.value || 'auto');

      pushHistory('strokePattern');

      // Auto: remove explicit overrides and let defaults / lineStyle drive it
      if (mode === 'auto') {
        delete f.strokeDash;
        draw();
        refreshSelectedInspector();
        return;
      }

      if (mode === 'solid') {
        // Explicitly cancel any dash (even if lane defaults are dashed)
        f.strokeDash = null;
        draw();
        refreshSelectedInspector();
        return;
      }

      if (mode === 'dashed') {
        if (f.type === 'lane') {
          f.lineStyle = 'dashed';
          delete f.strokeDash; // allow preset
        } else {
          f.strokeDash = [10, 8];
        }
        draw();
        refreshSelectedInspector();
        return;
      }

      if (mode === 'centerline') {
        if (f.type === 'lane') {
          f.lineStyle = 'centerline';
          delete f.strokeDash; // allow preset
        } else {
          f.strokeDash = [18, 6, 3, 6];
        }
        draw();
        refreshSelectedInspector();
        return;
      }

      if (mode === 'custom') {
        // ✅ Fix: DO NOT refreshSelectedInspector() here (it can snap the selector back).
        // Show the dash row and wait for the user to enter a valid dash list.
        if (selStrokeDashRow) selStrokeDashRow.style.display = '';
        // Leave existing strokeDash unchanged until user commits a valid list.
        return;
      }
    });
  }

  if (selStrokeDashInput){
    selStrokeDashInput.addEventListener('change', ()=>{
      const f = isLineLikeSelected();
      if (!f) return;

      // Only apply if pattern is custom
      if (!selStrokePatternSelect || selStrokePatternSelect.value !== 'custom') return;

      const parsed = parseDashList(selStrokeDashInput.value);
      if (!parsed) return;

      const _sel = _getSelectedFeature ? _getSelectedFeature() : null;

      if (_sel && _isFeatureLocked(_sel)) { _denyLockedEdit('stroke', _sel); return; }

      pushHistory('strokeDash');
      f.strokeDash = parsed;

      draw();
      refreshSelectedInspector();
    });
  }
// --- end sub-chunk 14.1B ------------------------------------------------------------

  // --- chunk 14.2 · Symbol fields (angle, size, etc.) --------------------------------- 

  selAngleInput.addEventListener('change',()=>{
    const f=state.features.find(x=>x.id===state.selectedId);
    if(!f || f.type!=='symbol') return;
    pushHistory('symbolAngle');
    let a=parseFloat(selAngleInput.value);
    if(!Number.isFinite(a)) a=0;
    f.angleDeg=a;
    draw();
  });

  selSizeInput.addEventListener('change',()=>{
    const f=state.features.find(x=>x.id===state.selectedId);
    if(!f || f.type!=='symbol') return;

    const desiredM = inputDistToMeters(selSizeInput.value);
    if(desiredM == null) return;

    pushHistory('symbolSize');

    const minM = Math.max(0.05, state.metersPerGrid * 0.1);
    f.sizeM = Math.max(minM, desiredM);

    draw();
    refreshSelectedInspector();
  });

  // --- chunk 14.3 · Area fields (name, surface, job, area value) ----------------------- 
  selAreaNameInput.addEventListener('input',()=>{
    const f=state.features.find(x=>x.id===state.selectedId);
    if(!f || f.type!=='area') return;
    f.name = selAreaNameInput.value;
    updateFeatureSelect();
  });

  selAreaSurfaceInput.addEventListener('input',()=>{
    const f=state.features.find(x=>x.id===state.selectedId);
    if(!f || f.type!=='area') return;
    f.surface = selAreaSurfaceInput.value;
  });

  selAreaJobInput.addEventListener('input',()=>{
    const f=state.features.find(x=>x.id===state.selectedId);
    if(!f || f.type!=='area') return;
    f.jobRef = selAreaJobInput.value;
  });

  // --- sub-chunk 14.3S · Shape dimension edits (rect/circle areas) --------------------
  function _regenRectAreaFromMeta(f){
    if(!f || f.type!=='area' || f.shapeType!=='rect' || !f.shapeMeta || f.shapeMeta.kind!=='rect') return false;
    const m = f.shapeMeta;
    const minX = Math.min(m.minX, m.maxX), maxX = Math.max(m.minX, m.maxX);
    const minY = Math.min(m.minY, m.maxY), maxY = Math.max(m.minY, m.maxY);
    f.shapeMeta = { kind:'rect', minX, minY, maxX, maxY };
    f.points = [
      {xM:minX, yM:minY},
      {xM:maxX, yM:minY},
      {xM:maxX, yM:maxY},
      {xM:minX, yM:maxY}
    ];
    f.areaM2 = polygonAreaMeters2(f.points);
    return true;
  }

  function _regenCircleAreaFromMeta(f){
    if(!f || f.type!=='area' || f.shapeType!=='circle' || !f.shapeMeta || f.shapeMeta.kind!=='circle') return false;
    const m = f.shapeMeta;
    const cx = m.cxM, cy = m.cyM;
    const r  = Math.max(0, Math.abs(m.rM || 0));
    const N = 48;
    const pts = [];
    for (let i=0;i<N;i++){
      const t = (i / N) * Math.PI * 2;
      pts.push({ xM: cx + Math.cos(t)*r, yM: cy + Math.sin(t)*r });
    }
    f.points = pts;
    f.areaM2 = polygonAreaMeters2(f.points);
    return true;
  }

  if (selShapeWidthInput){
    selShapeWidthInput.addEventListener('change', ()=>{
      const f = state.features.find(x=>x.id===state.selectedId);
      if(!f || f.type!=='area' || f.shapeType!=='rect' || !f.shapeMeta || f.shapeMeta.kind!=='rect') return;

      const desiredM = inputDistToMeters(selShapeWidthInput.value);
      if(desiredM == null) return;

      const _sel = _getSelectedFeature ? _getSelectedFeature() : null;
      if (_sel && _isFeatureLocked(_sel)) { _denyLockedEdit('shape', _sel); return; }

      const m = f.shapeMeta;
      const cx = (m.minX + m.maxX) / 2;
      const half = desiredM / 2;

      pushHistory('shapeWidth');
      f.shapeMeta.minX = cx - half;
      f.shapeMeta.maxX = cx + half;

      _regenRectAreaFromMeta(f);
      draw();
      updateFeatureSelect();
      refreshSelectedInspector();
    });
  }

  if (selShapeHeightInput){
    selShapeHeightInput.addEventListener('change', ()=>{
      const f = state.features.find(x=>x.id===state.selectedId);
      if(!f || f.type!=='area' || f.shapeType!=='rect' || !f.shapeMeta || f.shapeMeta.kind!=='rect') return;

      const desiredM = inputDistToMeters(selShapeHeightInput.value);
      if(desiredM == null) return;

      const _sel = _getSelectedFeature ? _getSelectedFeature() : null;
      if (_sel && _isFeatureLocked(_sel)) { _denyLockedEdit('shape', _sel); return; }

      const m = f.shapeMeta;
      const cy = (m.minY + m.maxY) / 2;
      const half = desiredM / 2;

      pushHistory('shapeHeight');
      f.shapeMeta.minY = cy - half;
      f.shapeMeta.maxY = cy + half;

      _regenRectAreaFromMeta(f);
      draw();
      updateFeatureSelect();
      refreshSelectedInspector();
    });
  }

  if (selShapeDiameterInput){
    selShapeDiameterInput.addEventListener('change', ()=>{
      const f = state.features.find(x=>x.id===state.selectedId);
      if(!f || f.type!=='area' || f.shapeType!=='circle' || !f.shapeMeta || f.shapeMeta.kind!=='circle') return;

      const desiredM = inputDistToMeters(selShapeDiameterInput.value);
      if(desiredM == null) return;

      const _sel = _getSelectedFeature ? _getSelectedFeature() : null;
      if (_sel && _isFeatureLocked(_sel)) { _denyLockedEdit('shape', _sel); return; }

      pushHistory('shapeDiameter');
      f.shapeMeta.rM = desiredM / 2;

      _regenCircleAreaFromMeta(f);
      draw();
      updateFeatureSelect();
      refreshSelectedInspector();
    });
  }
  // --- end sub-chunk 14.3S -----------------------------------------------------------

  // --- chunk 14.4 · Label fields (text, size) ----------------------------------------- 

  selLabelTextInput.addEventListener('input',()=>{
    const f=state.features.find(x=>x.id===state.selectedId);
    if(!f || f.type!=='label') return;
    f.text = selLabelTextInput.value;
    draw();
    updateFeatureSelect();
  });

  selLabelSizeInput.addEventListener('change',()=>{
    const f=state.features.find(x=>x.id===state.selectedId);
    if(!f || f.type!=='label') return;

    const desiredM = inputDistToMeters(selLabelSizeInput.value);
    if(desiredM == null) return;

    const minM = Math.max(0.05, state.metersPerGrid * 0.1);
    f.sizeM = Math.max(minM, desiredM);

    draw();
    refreshSelectedInspector();
  });

  // --- chunk end 14 ---------------------------------------------------------------
  // --- Feature select change chunk 15 --------------------------------------------------

  featureSelect.addEventListener('change',()=>{
    const v = featureSelect.value;
    const id = v ? Number(v) : null;
    state.selectedId = id;
    refreshSelectedInspector();
    draw();
  });
// --- chunk end 15 ---------------------------------------------------------------
  // --- Tool & edit button events chunk 16 ---------------------------------------------
  // GPT_SAFE_ZONE BEGIN: TOOL_SELECTION_DISPATCH (SUB-CHUNK 16.D1) — edit only if explicitly authorized
// SUB-CHUNK 16.D1 BEGIN — Tool selection dispatch wiring (Line/Draw/Sidebar)
// GPT_SAFE_ZONE BEGIN: BEND_TOOL_WIRING (SUB-CHUNK 16.B1) — edit only if explicitly authorized
// SUB-CHUNK 16.B1 BEGIN — Bend tool wiring + UI binding (markers-only; no runtime changes)

  // --- chunk 16.1a · Line Tool dropdown wiring (deterministic) -------------------------

  // Helpers: keep all Line Style label surfaces in sync (sidebar + topbar)
  
  // --- chunk 10.R2 · Rotate helpers (Phase 2: typed delta + Finish/Auto commit) ---------
  function _getSelectedFeature(){
    if (state.selectedId == null) return null;
    return state.features.find(f => f.id === state.selectedId) || null;
  }

  function _findFeatureById(id){
    if (id == null) return null;
    return state.features.find(f => f.id === id) || null;
  }

  // --- Layer lock helpers (edit guards) -----------------------------------------------
  function _layerKeyForFeature(f){
    if (!f || !f.type) return null;
    const t = String(f.type);
    if (t === 'road') return 'roads';
    if (t === 'lane') return 'lanes';
    if (t === 'label') return 'labels';
    if (t === 'symbol') return 'symbols';
    if (t === 'measure') return 'measure';
    if (t === 'freeDraw') return 'areas';
    if (t.indexOf('area') !== -1) return 'areas';
    return null;
  }

  function _isFeatureLocked(f){
    const k = _layerKeyForFeature(f);
    return !!(k && state.layerLocks && state.layerLocks[k]);
  }

  function _denyLockedEdit(action, f){
    const k = _layerKeyForFeature(f) || 'layer';
    const msg = `Locked: ${k} (unlock in Properties → Layers)`;
    try {
      if (typeof setStatus === 'function') setStatus(msg);
      else if (typeof statusLeft !== 'undefined' && statusLeft) statusLeft.textContent = msg;
      else console.warn(msg);
    } catch(_){ console.warn(msg); }
  }

  function _centroidOfPoints(points){
    if (!Array.isArray(points) || points.length === 0) return null;
    let sx = 0, sy = 0, n = 0;
    for (const p of points){
      if (!p) continue;
      const x = (typeof p.xM === 'number') ? p.xM : null;
      const y = (typeof p.yM === 'number') ? p.yM : null;
      if (x == null || y == null) continue;
      sx += x; sy += y; n++;
    }
    if (!n) return null;
    return { xM: sx / n, yM: sy / n };
  }

  function _rotatePointAbout(p, pivot, rad){
    const dx = p.xM - pivot.xM;
    const dy = p.yM - pivot.yM;
    const c = Math.cos(rad), s = Math.sin(rad);
    return { xM: pivot.xM + dx * c - dy * s, yM: pivot.yM + dx * s + dy * c };
  }

  function _rotatePointsArray(points, pivot, rad){
    return points.map(pt => _rotatePointAbout(pt, pivot, rad));
  }

  function beginRotateSession(){
    const sel = _getSelectedFeature();
    if (!sel) return false;

    // If selection changed, cancel any previous preview first
    if (rotateSession && rotateSession.featureId != null && rotateSession.featureId !== sel.id) {
      try { cancelRotateSession('selectionChanged'); } catch(_){}
    }

    if (!rotateSession || rotateSession.featureId !== sel.id) {
      const pivot = (sel.type === 'symbol' || sel.type === 'label')
        ? { xM: sel.xM, yM: sel.yM }
        : _centroidOfPoints(sel.points);

      // Group-aware rotate: if the selected feature has a groupId, rotate previews/commits apply to the whole group.
      // Multi-select-aware rotate: if multi-select is enabled and multiple IDs are selected (and we're NOT in a group),
      // rotate previews/commits apply to the whole multi-selection set.
      const _gid = getEffectiveGroupId(sel);

      let _members = null;
      if (_gid != null){
        _members = getEffectiveGroupMembers(_gid);
      } else if (state.multiSelectEnabled && Array.isArray(state.selectedIds) && state.selectedIds.length > 1){
        const ids = state.selectedIds.filter(Boolean);
        const feats = ids.map(id => (_findFeatureById ? _findFeatureById(id) : state.features.find(x => x && x.id === id))).filter(Boolean);
        _members = feats.length ? feats : [sel];
      } else {
        _members = [sel];
      }

      // Locked-layer safety: deny rotate if any member is locked.
      for (const mf of _members){
        if (mf && _isFeatureLocked && _isFeatureLocked(mf)) { _denyLockedEdit('rotate', mf); return false; }
      }
      const _basesById = {};
      for (const mf of _members) {
        const liveMf = _findFeatureById ? _findFeatureById(mf.id) : (state.features.find(x=>x.id===mf.id));
        _basesById[mf.id] = deepClone(liveMf || mf);
      }

      rotateSession = {
        featureId: sel.id,
        type: sel.type,
        groupId: _gid,
        memberIds: _members.map(mf => mf.id),
        basesById: _basesById,
        pivot: pivot,
        pendingDeltaDeg: 0,
        pending: false,
        lastSign: 1
      };
    }
    return true;
  }

  function _pivotFromTap(sel, world){
    if (!sel || !world) return null;
    // Symbols/labels: accept the tapped world point as pivot
    if (sel.type === 'symbol' || sel.type === 'label') {
      return { xM: world.xM, yM: world.yM };
    }
    if (!Array.isArray(sel.points) || sel.points.length < 1) return { xM: world.xM, yM: world.yM };

    // Convert a pixel snap threshold to meters
    const pxThresh = 14;
    const ppm = getPxPerMeter();
    const mThresh = pxThresh / ppm;

    // Helper: nearest point on polyline/polygon edges
    function nearestPointOnSegments(points){
      let best = { xM: points[0].xM, yM: points[0].yM, d2: Infinity, idx:0, t:0 };
      const n = points.length;
      const closed = (n > 2 && (points[0].xM === points[n-1].xM) && (points[0].yM === points[n-1].yM));
      const last = closed ? n-1 : n-1;
      for (let i=0; i<last; i++){
        const a = points[i];
        const b = points[(i+1) % n];
        const abx = b.xM - a.xM;
        const aby = b.yM - a.yM;
        const apx = world.xM - a.xM;
        const apy = world.yM - a.yM;
        const denom = (abx*abx + aby*aby) || 1e-9;
        let t = (apx*abx + apy*aby) / denom;
        if (t < 0) t = 0;
        if (t > 1) t = 1;
        const x = a.xM + t*abx;
        const y = a.yM + t*aby;
        const dx = world.xM - x;
        const dy = world.yM - y;
        const d2 = dx*dx + dy*dy;
        if (d2 < best.d2) best = { xM:x, yM:y, d2, idx:i, t };
      }
      return best;
    }

    const near = nearestPointOnSegments(sel.points);
    // Snap to nearest vertex if close enough
    let bestV = null;
    for (let i=0; i<sel.points.length; i++){
      const v = sel.points[i];
      const dx = world.xM - v.xM;
      const dy = world.yM - v.yM;
      const d2 = dx*dx + dy*dy;
      if (!bestV || d2 < bestV.d2) bestV = { xM:v.xM, yM:v.yM, d2 };
    }
    if (bestV && Math.sqrt(bestV.d2) <= mThresh) return { xM: bestV.xM, yM: bestV.yM };
    return { xM: near.xM, yM: near.yM };
  }

  function beginRotateSessionWithPivot(pivotOverride){
    const sel = _getSelectedFeature();
    if (!sel) return false;
    // Cancel previous preview if selection changed
    if (rotateSession && rotateSession.featureId != null && rotateSession.featureId !== sel.id) {
      try { cancelRotateSession('selectionChanged'); } catch(_){}
    }
    // Always (re)base from current live geometry when pivot changes or new drag begins
    const live = _findFeatureById(sel.id);
    const base = deepClone(live || sel);
    const pivot = pivotOverride || ((sel.type === 'symbol' || sel.type === 'label') ? { xM: sel.xM, yM: sel.yM } : _centroidOfPoints(sel.points));
    // Group-aware rotate: if the selected feature has a groupId, rotate previews/commits apply to the whole group.
    const _gid = getEffectiveGroupId(sel);

    let _members = null;
    if (_gid != null){
      _members = getEffectiveGroupMembers(_gid);
    } else if (state.multiSelectEnabled && Array.isArray(state.selectedIds) && state.selectedIds.length > 1){
      const ids = state.selectedIds.filter(Boolean);
      const feats = ids.map(id => (_findFeatureById ? _findFeatureById(id) : state.features.find(x => x && x.id === id))).filter(Boolean);
      _members = feats.length ? feats : [sel];
    } else {
      _members = [sel];
    }

    // Locked-layer safety: deny rotate if any member is locked.
    for (const mf of _members){
      if (mf && _isFeatureLocked && _isFeatureLocked(mf)) { _denyLockedEdit('rotate', mf); return; }
    }
    const _basesById = {};
    for (const mf of _members) {
      const liveMf = _findFeatureById ? _findFeatureById(mf.id) : (state.features.find(x=>x.id===mf.id));
      _basesById[mf.id] = deepClone(liveMf || mf);
    }

    rotateSession = {
      featureId: sel.id,
      type: sel.type,
      groupId: _gid,
      memberIds: _members.map(mf => mf.id),
      basesById: _basesById,
      pivot: pivot || { xM: (pivotOverride && pivotOverride.xM) || 0, yM: (pivotOverride && pivotOverride.yM) || 0 },
      pendingDeltaDeg: 0,
      pending: false,
      lastSign: (rotateSession && rotateSession.lastSign) ? rotateSession.lastSign : 1
    };
    return true;
  }

  function cancelRotateSession(_why){
    if (!rotateSession) return;
    const live = _findFeatureById(rotateSession.featureId);
    if (live && rotateSession.base) {
      // Restore base snapshot (no silent commits)
      if (rotateSession.type === 'symbol') {
        live.angleDeg = rotateSession.base.angleDeg || 0;
      } else if (rotateSession.type === 'label') {
        live.xM = rotateSession.base.xM; live.yM = rotateSession.base.yM;
        live.txM = rotateSession.base.txM; live.tyM = rotateSession.base.tyM;
        live.angleDeg = rotateSession.base.angleDeg || 0;
      } else if (Array.isArray(rotateSession.base.points)) {
        live.points = deepClone(rotateSession.base.points);
      }
    }
    rotateSession = null;
    if (typeof updateToolspace === 'function') updateToolspace();
    setModeLabel();
    draw();
  }

  function applyRotatePreview(deltaDeg){
    if (!beginRotateSession()) return false;

    // Track direction for "latest change wins"
    if (deltaDeg > 0) rotateSession.lastSign = 1;
    else if (deltaDeg < 0) rotateSession.lastSign = -1;

    // Restore bases first, then apply delta (preview always reflects current truth)
    const pivot = rotateSession.pivot;
    const rad = (deltaDeg || 0) * Math.PI / 180;

    const bases = rotateSession.basesById || {};
    const ids = Array.isArray(rotateSession.memberIds) && rotateSession.memberIds.length
      ? rotateSession.memberIds
      : [rotateSession.featureId];

    for (const id of ids) {
      const live = _findFeatureById(id);
      const base = bases[id];
      if (!live || !base) continue;

      // Anchored objects (symbols/labels)
      if (live.type === 'symbol' || live.type === 'label') {
        if (!pivot || typeof base.xM !== 'number' || typeof base.yM !== 'number') continue;
        const rotated = _rotatePointAbout({ xM: base.xM, yM: base.yM }, pivot, rad);
        live.xM = rotated.xM;
        live.yM = rotated.yM;

        // Optional text anchor (labels) — rotate position too
        if (typeof base.txM === 'number' && typeof base.tyM === 'number') {
          const tRot = _rotatePointAbout({ xM: base.txM, yM: base.tyM }, pivot, rad);
          live.txM = tRot.xM;
          live.tyM = tRot.yM;
        }

        // Orientation
        const baseA = base.angleDeg || 0;
        if ('angleDeg' in live) live.angleDeg = baseA + (deltaDeg || 0);
        continue;
      }

      // Circle meta (if present)
      if (base.shapeMeta && base.shapeMeta.kind === 'circle' &&
          Number.isFinite(base.shapeMeta.cxM) && Number.isFinite(base.shapeMeta.cyM)) {
        if (pivot) {
          const cRot = _rotatePointAbout({ xM: base.shapeMeta.cxM, yM: base.shapeMeta.cyM }, pivot, rad);
          live.shapeMeta = live.shapeMeta || {};
          live.shapeMeta.kind = 'circle';
          live.shapeMeta.cxM = cRot.xM;
          live.shapeMeta.cyM = cRot.yM;
          live.shapeMeta.rM = base.shapeMeta.rM;
        }
      }

      // Poly objects (lines/areas)
      if (!pivot || !Array.isArray(base.points)) continue;
      live.points = _rotatePointsArray(base.points, pivot, rad);

      // Holes rotate too (areas)
      if (Array.isArray(base.holes)) {
        live.holes = base.holes.map(poly => _rotatePointsArray(poly, pivot, rad));
      }

      if (live.type === 'area') live.areaM2 = areaWithHoles(live);
    }

    rotateSession.pendingDeltaDeg = deltaDeg || 0;
    rotateSession.pending = !!(deltaDeg && Math.abs(deltaDeg) > 1e-9);

    if (typeof updateToolspace === 'function') updateToolspace();
    setModeLabel();
    draw();
    return true;
  }

function commitRotateSession(_src){
    if (!rotateSession || !rotateSession.pending) return false;
    const sel = _getSelectedFeature ? _getSelectedFeature() : null;

    // If rotating a group, deny if any member is locked.
    const ids = (rotateSession && Array.isArray(rotateSession.memberIds) && rotateSession.memberIds.length)
      ? rotateSession.memberIds
      : (sel ? [sel.id] : []);

    for (const id of ids) {
      const f = _findFeatureById ? _findFeatureById(id) : null;
      if (f && _isFeatureLocked && _isFeatureLocked(f)) {
        _denyLockedEdit('rotate', f);
        rotateSession = null;
        draw();
        return false;
      }
    }
    // Commit: snapshot current state for undo, then clear session (stay in rotate mode)
    pushHistory('rotate');
    rotateSession = null;
    if (typeof updateToolspace === 'function') updateToolspace();
    setModeLabel();
    draw();
    return true;
  }

  function getRotateStepDeg(){
    if (!angleSnapDegInput) return 0;
    let d = parseFloat(angleSnapDegInput.value);
    if (!Number.isFinite(d) || d < 0) d = 0;
    return d;
  }

  function handleRotateDegreesInput(){
    if (!(state && state.editMode === 'rotate')) return;
    const d = getRotateStepDeg();

    // unless a rotate preview is already pending. This avoids interfering with the user's intent to drag in
    // those intervals.
    if (!rotateSession) return;

    // If we're actively dragging, the move handler will pick up the new step on the next move tick.
    if (rotateSession.active) return;

    // If a preview is pending (manual mode), re-quantize it to the new step so the latest edit is truthful.
    if (rotateSession.pending) {
      const raw = (rotateSession.pendingDeltaDeg || 0);
      let next = raw;
      if (d > 0) next = Math.round(raw / d) * d;
      // If d==0, keep the raw preview delta (free mode).
      try { applyRotatePreview(next); } catch(_){ }
    }
  }
function setLineStyleLabels(style){
    const s = String(style || 'solid').toLowerCase();
    const label =
      (s === 'dashed') ? 'Dashed' :
      (s === 'centerline') ? 'Centerline' :
      (s === 'custom') ? 'Custom' : 'Solid';

    if (lineStyleLabel) lineStyleLabel.textContent = label;

    // Unified dropdown: keep the <select> in sync
    if (lineStyleSelect) lineStyleSelect.value = s;
  }

  // Select the active line tool (road/lane) based on current state.lineStyle
  function selectLineToolFromCurrentStyle(){
    // Source of truth: Properties → Line Defaults
    const s = String((state && state.lineDefaults && state.lineDefaults.style) || state.lineStyle || 'solid').toLowerCase();
    if (s === 'dashed' || s === 'centerline' || s === 'custom') setTool('lane');
    else setTool('road');
  }

  // Set line style (updates labels). Only forces tool switch if we're already in a line tool.
  function setLineStyleOnly(style){
    const s = String(style || '').toLowerCase();
    if (s !== 'solid' && s !== 'dashed' && s !== 'centerline' && s !== 'custom') return;

    state.lineStyle = s;
    // Keep defaults truthful: topbar style becomes the active default style (no auto-collapse)
    if (state && state.lineDefaults) state.lineDefaults.style = s;
    setLineStyleLabels(s);

    // If currently drawing a line, keep tool type consistent with the new style
    if (state.tool === 'road' || state.tool === 'lane') {
      selectLineToolFromCurrentStyle();
    } else {
      // Just refresh labels/toolspace for consistency
      try { setModeLabel(); } catch(_) {}
    }
  }

  // Apply style AND route tool explicitly (used by sidebar Line Tool dropdown)
  function applyLineStyle(style){
    const s = String(style || '').toLowerCase();
    if (s !== 'solid' && s !== 'dashed' && s !== 'centerline' && s !== 'custom') return;

    state.lineStyle = s;
    // Keep defaults truthful: topbar style becomes the active default style (no auto-collapse)
    if (state && state.lineDefaults) state.lineDefaults.style = s;
    setLineStyleLabels(s);

    // Route tool explicitly (NO guessing)
    selectLineToolFromCurrentStyle();
  }

  // Clicking the Line Tool summary uses the current style mapping
  if (lineToolBtn) {
    lineToolBtn.addEventListener('click', (e)=>{
      // Let <details> toggle normally; also ensure tool selection is set deterministically.
      selectLineToolFromCurrentStyle();
    });
  }

  // Style button clicks inside the dropdown
  if (lineToolMenu) {
    lineToolMenu.addEventListener('click', (e)=>{
      const btn = e.target && e.target.closest ? e.target.closest('[data-line-style]') : null;
      if (!btn) return;
      const style = btn.getAttribute('data-line-style');
      applyLineStyle(style);

      // Close the dropdown after selection
      try { lineToolMenu.open = false; } catch(_) {}
    });
  }

  if (lineToolCloseBtn) {
    lineToolCloseBtn.addEventListener('click', ()=>{
      if (lineToolMenu) lineToolMenu.open = false;
    });
  }

  // SUB-CHUNK 16.TB BEGIN — Branding toolbar visibility toggle (chrome stays fixed)
  (function bindToolbarHideToggle(){
    const btn = document.getElementById('toggleTopbarBtn');
    if (!btn) { try{ console.warn('[TB_TOGGLE] missing #toggleTopbarBtn'); }catch(_){}; return; }

    const chrome = document.getElementById('chrome') || null;

    // Persist preference (optional but safe)
    const KEY = 'FO_UI_TOOLS_HIDDEN_V1';

    let lastEventType = '';
    let lastEventAt = 0;

    const isHidden = ()=> document.body.classList.contains('tools-hidden');

    const sync = ()=>{
      const hidden = isHidden();
      btn.textContent = hidden ? 'Show tools' : 'Hide tools';
      btn.setAttribute('aria-pressed', hidden ? 'true' : 'false');
      try{ document.documentElement.dataset.toolsHidden = hidden ? '1' : '0'; }catch(_){}
    };

    // Restore persisted state (do this before first resize so canvas claims space correctly)
    try{
      const v = localStorage.getItem(KEY);
      if (v === '1') document.body.classList.add('tools-hidden');
    }catch(_){}

    // Apply toggle while keeping the *world* visually anchored.
    // Principle:
    // - Hiding/showing the toolbar changes chrome height → canvas container height changes.
    // - Compensate by shifting viewOriginYM by the same world distance so the drawing does not jump.
    const applyToggleWorldAnchored = ()=>{
      // Overlay-safe toggle: tools are HUD overlays now, so hiding/showing them
      // must NOT modify world origin or trigger canvas resize/redraw.
      document.body.classList.toggle('tools-hidden');

      // Persist preference (best-effort)
      try{
        localStorage.setItem(KEY, isHidden() ? '1' : '0');
      }catch(_){ }

      // Update button state/labels
      sync();
    
      // Recalibrate overlay dock offsets (chrome height may have changed)
      try{ calibrateRightDock(); }catch(_){ }
};

    const onToggle = (e)=>{
      // Prevent double-toggle: some environments fire pointerup + click for a single tap.
      const now = Date.now();
      const type = (e && e.type) ? String(e.type) : 'unknown';

      // If click follows pointerup quickly, ignore click.
      if (type === 'click' && lastEventType === 'pointerup' && (now - lastEventAt) < 650) return;
      // If any second event arrives too soon, ignore it.
      if (lastEventAt && (now - lastEventAt) < 250) return;

      lastEventType = type;
      lastEventAt = now;

      try{ e && e.preventDefault && e.preventDefault(); }catch(_){}
      try{ e && e.stopPropagation && e.stopPropagation(); }catch(_){}
      applyToggleWorldAnchored();
    };

    // Bind both so the button works even when one event is suppressed,
    // but the guard above prevents double-toggles.
    btn.addEventListener('pointerup', onToggle);
    btn.addEventListener('click', onToggle);

    sync();
    try{ console.info('[TB_TOGGLE] bound'); }catch(_){}
  })();

  // Bottom status bar visibility toggle (chrome stays fixed)
  (function bindStatusbarHideToggle(){
    const btn = document.getElementById('toggleStatusbarBtn');
    if (!btn) { try{ console.warn('[SB_TOGGLE] missing #toggleStatusbarBtn'); }catch(_){}; return; }

    const bar = document.querySelector('.status-bar') || null;

    // Persist preference
    const KEY = 'FO_UI_STATUS_HIDDEN_V1';

    const isHidden = ()=> document.body.classList.contains('status-hidden');

    const sync = ()=>{
      const hidden = isHidden();
      btn.textContent = hidden ? 'Show status' : 'Hide status';
      btn.setAttribute('aria-pressed', hidden ? 'true' : 'false');
      try{ document.documentElement.dataset.statusHidden = hidden ? '1' : '0'; }catch(_){}
    };

    // Restore persisted state
    try{
      const v = localStorage.getItem(KEY);
      if (v === '1') document.body.classList.add('status-hidden');
    }catch(_){}

    btn.addEventListener('click', ()=>{
      // Optional world-anchor compensation:
      // Status bar overlays the canvas (fixed). Toggling visibility should not shift layout,
      // but we still sync and persist deterministically.
      document.body.classList.toggle('status-hidden');
      try{ localStorage.setItem(KEY, isHidden() ? '1' : '0'); }catch(_){}
      sync();
    });

    // If status bar is missing, still allow toggle (future-proof), but warn.
    if (!bar) { try{ console.warn('[SB_TOGGLE] .status-bar not found'); }catch(_){}; }

    sync();
  })();

  // SUB-CHUNK 16.TB END — Branding toolbar visibility toggle (chrome stays fixed)

  // SUB-CHUNK 16.B1 END
// GPT_SAFE_ZONE END: BEND_TOOL_WIRING (SUB-CHUNK 16.B1)
// --- chunk end 16.1a ---------------------------------------------------------------

  // --- sub-chunk 16.1aa · Line style <select> (topbar Button 1; uniform dropdown) ----------------------

  // Uses the same style logic as Line Options did:
  // - Updates state.lineStyle + labels
  // --- end sub-chunk 16.1aa -----------------------------------------------------------

  // --- chunk 16.1b · Draw dropdown wiring (topbar hub; deterministic) -------------------

  // Draw dropdown: line styles reuse applyLineStyle(); area uses setTool('area')
  
  // Draw dropdown click routing (supports nested submenus)
  // - main panel: [data-line-style], [data-draw-tool], [data-open-submenu], #drawToolCloseBtn
  // - submenu panel: [data-draw-tool], [data-submenu-back]
  if (drawToolMenu) {
    const drawMainPanel    = document.getElementById('drawMainPanel');
    const drawSubmenuPanel = document.getElementById('drawSubmenuPanel');

    const _drawSubmenuState = {
      openName: null,
      openerEl: null
    };

    const closeDrawSubmenu = ()=>{
      try{
        _drawSubmenuState.openName = null;
        _drawSubmenuState.openerEl = null;

        if (drawSubmenuPanel){
          drawSubmenuPanel.classList.remove('open','overlay');
          drawSubmenuPanel.removeAttribute('data-open');
          drawSubmenuPanel.setAttribute('aria-hidden','true');
        }
        if (drawMainPanel){
          drawMainPanel.classList.remove('overlay-hidden');
        }
        // collapse aria-expanded on openers
        try{
          drawToolMenu.querySelectorAll('[data-open-submenu]').forEach(btn=>{
            btn.setAttribute('aria-expanded','false');
          });
        }catch(_){}
      }catch(_){}
    };

    const _canCascadeRight = (submenuWidth)=>{
      try{
        const viewportW = Math.max(0, window.innerWidth || document.documentElement.clientWidth || 0);
        const menuRect = drawToolMenu.getBoundingClientRect();
        const margin = 12;
        return (menuRect.right + submenuWidth + margin) <= viewportW;
      }catch(_){
        return false;
      }
    };

    const openDrawSubmenu = (name, openerEl)=>{
      try{
        if (!drawSubmenuPanel || !drawMainPanel) return;

        // If switching submenus, close first (keeps state simple)
        if (_drawSubmenuState.openName && _drawSubmenuState.openName !== name){
          closeDrawSubmenu();
        }

        // Toggle off if same submenu is already open
        if (_drawSubmenuState.openName === name){
          closeDrawSubmenu();
          return;
        }

        // Show only the requested submenu body
        try{
          drawSubmenuPanel.querySelectorAll('[data-submenu]').forEach(box=>{
            box.style.display = (box.getAttribute('data-submenu') === name) ? '' : 'none';
          });
        }catch(_){}

        // Decide layout: overlay replacement everywhere (prevents viewport overflow / device variability)
        _drawSubmenuState.openName = name;
        _drawSubmenuState.openerEl = openerEl || null;

        // aria
        try{
          drawToolMenu.querySelectorAll('[data-open-submenu]').forEach(btn=>{
            btn.setAttribute('aria-expanded', (btn === openerEl) ? 'true' : 'false');
          });
        }catch(_){}

        // Overlay replacement (all devices)
        drawSubmenuPanel.classList.add('open');
        drawSubmenuPanel.setAttribute('aria-hidden','false');
        drawSubmenuPanel.style.left = '0px';
        drawSubmenuPanel.style.top  = '0px';
        drawMainPanel.classList.add('overlay-hidden');

try{ syncTopbarEditUI(); }catch(_){}

      }catch(_){}
    };

    // Close submenu if the main details closes
    drawToolMenu.addEventListener('toggle', ()=>{
      try{
        if (!drawToolMenu.open){
          closeDrawSubmenu();
        }
      }catch(_){}
    });

    drawToolMenu.addEventListener('click', (e)=>{
      const t = e.target && e.target.closest ? e.target.closest('[data-line-style],[data-draw-tool],[data-open-submenu],[data-submenu-back],#drawToolCloseBtn') : null;
      if (!t) return;

      // Close button (closes everything)
      if (t && t.id === 'drawToolCloseBtn') {
        closeDrawSubmenu();
        try { drawToolMenu.open = false; } catch(_) {}
        return;
      }

      // Back (overlay / cascade) — returns to main panel but keeps Draw dropdown open
      if (t && t.getAttribute && t.getAttribute('data-submenu-back') === 'true'){
        closeDrawSubmenu();
        try{ syncTopbarEditUI(); }catch(_){}
        return;
      }

      // Submenu opener (keeps Draw dropdown open)
      const sm = t.getAttribute && t.getAttribute('data-open-submenu');
      if (sm){
        openDrawSubmenu(sm, t);
        return;
      }

      // Line style selection (closes everything)
      const ls = t.getAttribute && t.getAttribute('data-line-style');
      if (ls) {
        applyLineStyle(ls);
        closeDrawSubmenu();
        try { drawToolMenu.open = false; } catch(_) {}
        return;
      }

      // Tool selection (closes both submenu + dropdown)
      const tool = t.getAttribute && t.getAttribute('data-draw-tool');
      if (tool) {
        if (tool === 'line') { selectLineToolFromCurrentStyle(); } else { setTool(tool); }
        closeDrawSubmenu();
        try { drawToolMenu.open = false; } catch(_) {}
        return;
      }
    });
  }
// --- chunk end 16.1b ---------------------------------------------------------------

  // SUB-CHUNK 16.1c BEGIN — Sidebar tool button bindings (optional)
  // PROTECT: Sidebar tools will be removed incrementally. Missing elements must never crash bindings.
  if (toolInspectBtn) toolInspectBtn.addEventListener('click', ()=>setTool('inspect'));
  if (toolMeasureBtn) toolMeasureBtn.addEventListener('click', ()=>setTool('measure'));
  if (toolAreaBtn)    toolAreaBtn   .addEventListener('click', ()=>setTool('area'));
  if (toolSymbolBtn)  toolSymbolBtn .addEventListener('click', ()=>setTool('symbol'));
  if (toolLabelBtn)   toolLabelBtn  .addEventListener('click', ()=>setTool('label'));
  if (toolEraseBtn)   toolEraseBtn  .addEventListener('click', ()=>setTool('erase'));

  // SCRIPT PART 2.2 END (LLM ANCHOR)
</script>

<script>

  // SCRIPT PART 2.3 BEGIN (LLM ANCHOR)
  // SUB-CHUNK 16.1c END — Sidebar tool button bindings (optional)

  // --- Topbar Stack Y quick actions (Button 7/8) -------------------------------
  // Button 8: Inspect / Nav (mirrors sidebar Inspect/Nav)
  if (stackYBtn4) {
    stackYBtn4.addEventListener('click', ()=>{
      try { setTool('inspect'); } catch(_) {}
    });
  }

  // Button 5: Properties (Right panel toggle) — stays in current tool/edit mode
  // NOTE: This is a UI relocation only; uses the existing Properties toggle button handler as source of truth.
  if (stackYBtn2) {
    stackYBtn2.addEventListener('click', ()=>{
      try {
        const legacyPropsBtn = document.getElementById('toggleRightPanelBtn');
        if (legacyPropsBtn) legacyPropsBtn.click();
      } catch(_) {}
    });
  }

  

  // Preset Geometry button (replaces redundant toolbar line-style control)
  // --- chunk 14.U BEGIN — User Symbol Presets (save + stamp) -------------------------
// Contract:
// - User preset symbols behave exactly like built-in symbols: they insert as ONE feature (type:'symbol').
// - They do NOT insert as exploded pieces and do NOT create groups.
// - Presets live outside draft JSON (localStorage library).
const USER_SYMBOLS_STORAGE_KEY = 'fielddraft_user_symbols_v1';

function _loadUserSymbols(){
  try{
    const raw = localStorage.getItem(USER_SYMBOLS_STORAGE_KEY);
    if (!raw) return [];
    const data = JSON.parse(raw);
    return Array.isArray(data) ? data : [];
  }catch(_){ return []; }
}
function _saveUserSymbols(list){
  try{ localStorage.setItem(USER_SYMBOLS_STORAGE_KEY, JSON.stringify(Array.isArray(list)?list:[])); }catch(_){}
}

function _getUserSymbols(){
  if (!state._userSymbols) state._userSymbols = _loadUserSymbols();
  if (!Array.isArray(state._userSymbols)) state._userSymbols = [];
  return state._userSymbols;
}

// --- FieldDraft portable symbol registry + codec (FDSP v1) -------------------------
// Goal: allow drafts to carry only the custom symbols they use, so any device can reconstruct.
// NOTE: LocalStorage remains the user's library; runtime registry supports imported draft symbol packs.
let _runtimeUserSymbolRegistry = new Map();
function _clearRuntimeUserSymbolRegistry(){ try{ _runtimeUserSymbolRegistry.clear(); }catch(_){} }
function _registerRuntimeUserSymbol(entry){
  try{
    if (!entry || entry.id == null) return;
    _runtimeUserSymbolRegistry.set(String(entry.id), entry);
  }catch(_){}
}
function _getRuntimeUserSymbolById(id){
  try{ return _runtimeUserSymbolRegistry.get(String(id)) || null; }catch(_){ return null; }
}

// Minimal, FieldDraft-native codec wrapper.
// v1 uses base64url(JSON) to establish the contract boundary safely.
// Later: replace internals with quantized varint stream without touching app logic.
function _fdspUtf8ToB64Url(str){
  try{
    const bytes = new TextEncoder().encode(String(str||''));
    let bin = '';
    for (let i=0;i<bytes.length;i++) bin += String.fromCharCode(bytes[i]);
    const b64 = btoa(bin);
    return b64.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  }catch(_){ return ''; }
}
function _fdspB64UrlToUtf8(b64url){
  try{
    let b64 = String(b64url||'').replace(/-/g,'+').replace(/_/g,'/');
    while (b64.length % 4) b64 += '=';
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i) & 255;
    return new TextDecoder().decode(bytes);
  }catch(_){ return ''; }
}
function FDSP_ENCODE_TEMPLATE(templateObj){
  try{
    const json = JSON.stringify(templateObj||{});
    const payload = _fdspUtf8ToB64Url(json);
    return payload || '';
  }catch(_){ return ''; }
}
function FDSP_DECODE_TEMPLATE(payload){
  try{
    const json = _fdspB64UrlToUtf8(payload);
    const obj = JSON.parse(json);
    return (obj && typeof obj==='object') ? obj : null;
  }catch(_){ return null; }
}
// --- end FDSP v1 ------------------------------------------------------------------

// --- chunk 19.SG · SymbolsPack safeguards (Phase A+B) -----------------------------
// Play Store hardening: per-symbol decode isolation, size caps, numeric sanity checks,
// and a one-line import report (runtime-only; does not auto-save to library).
const SYMPACK_MAX_SYMBOLS = 200;
const SYMPACK_MAX_PAYLOAD_CHARS = 250000; // base64url chars
const SYMPACK_MAX_ITEMS_PER_SYMBOL = 2000;
const SYMPACK_MAX_VERTS_PER_PATH = 20000;
const SYMPACK_COORD_ABS_MAX = 10000000;
let _lastSymbolsPackReport = null;

function _sympackNewReport(){
  return { total:0, loaded:0, skipped:0, reasons:{}, tooMany:false, unsupported:false, savedToLibrary:false };
}
function _sympackAddReason(r, reason){
  try{
    const k = String(reason||'unknown');
    r.reasons[k] = (r.reasons[k]||0) + 1;
  }catch(_){ }
}

function _sympackValidateNumber(n){
  return (typeof n === 'number' && Number.isFinite(n) && Math.abs(n) <= SYMPACK_COORD_ABS_MAX);
}

function _sympackValidateTemplate(tmpl){
  try{
    if (!tmpl || typeof tmpl !== 'object') return { ok:false, reason:'invalid template' };
    if (!Array.isArray(tmpl.items)) return { ok:false, reason:'invalid template' };
    if (tmpl.items.length > SYMPACK_MAX_ITEMS_PER_SYMBOL) return { ok:false, reason:'too many items' };

    const allowed = new Set(['road','lane','area','label','measure','symbol']);
    for (const it of tmpl.items){
      if (!it || typeof it !== 'object') return { ok:false, reason:'invalid item' };
      const ty = String(it.type||'');
      if (!allowed.has(ty)) return { ok:false, reason:'unsupported type' };

      if (ty === 'road' || ty === 'lane' || ty === 'measure'){
        if (!Array.isArray(it.points)) return { ok:false, reason:'invalid points' };
        if (it.points.length > SYMPACK_MAX_VERTS_PER_PATH) return { ok:false, reason:'too many vertices' };
        for (const p of it.points){
          if (!p || !_sympackValidateNumber(p.xM) || !_sympackValidateNumber(p.yM)) return { ok:false, reason:'bad numbers' };
        }
      } else if (ty === 'area'){
        if (!Array.isArray(it.points)) return { ok:false, reason:'invalid points' };
        if (it.points.length > SYMPACK_MAX_VERTS_PER_PATH) return { ok:false, reason:'too many vertices' };
        for (const p of it.points){
          if (!p || !_sympackValidateNumber(p.xM) || !_sympackValidateNumber(p.yM)) return { ok:false, reason:'bad numbers' };
        }
        if (Array.isArray(it.holes)){
          for (const h of it.holes){
            if (!Array.isArray(h)) return { ok:false, reason:'invalid holes' };
            if (h.length > SYMPACK_MAX_VERTS_PER_PATH) return { ok:false, reason:'too many vertices' };
            for (const p of h){
              if (!p || !_sympackValidateNumber(p.xM) || !_sympackValidateNumber(p.yM)) return { ok:false, reason:'bad numbers' };
            }
          }
        }
      } else if (ty === 'label'){
        if (!_sympackValidateNumber(it.xM) || !_sympackValidateNumber(it.yM)) return { ok:false, reason:'bad numbers' };
        if (typeof it.text === 'string' && it.text.length > 2000) return { ok:false, reason:'label too long' };
        if (typeof it.txM === 'number' && !_sympackValidateNumber(it.txM)) return { ok:false, reason:'bad numbers' };
        if (typeof it.tyM === 'number' && !_sympackValidateNumber(it.tyM)) return { ok:false, reason:'bad numbers' };
      } else if (ty === 'symbol'){
        if (typeof it.xM === 'number' && !_sympackValidateNumber(it.xM)) return { ok:false, reason:'bad numbers' };
        if (typeof it.yM === 'number' && !_sympackValidateNumber(it.yM)) return { ok:false, reason:'bad numbers' };
        // nested symbolType can be anything; it will resolve at stamp time.
      }
    }

    return { ok:true };
  }catch(_){
    return { ok:false, reason:'invalid template' };
  }
}

function _safeDecodeSymbolPackRecord(rec){
  try{
    if (!rec || rec.id == null) return { ok:false, reason:'invalid record' };
    const payload = rec.payload;
    if (typeof payload !== 'string' || !payload) return { ok:false, reason:'missing payload' };
    if (payload.length > SYMPACK_MAX_PAYLOAD_CHARS) return { ok:false, reason:'payload too large' };
    const tmpl = FDSP_DECODE_TEMPLATE(payload);
    const v = _sympackValidateTemplate(tmpl);
    if (!v.ok) return { ok:false, reason:v.reason };
    return { ok:true, template: tmpl };
  }catch(_){
    return { ok:false, reason:'corrupt payload' };
  }
}
// --- chunk end 19.SG --------------------------------------------------------------


function _refreshUserSymbolOptions(){
  try{
    const sel = document.getElementById('symbolSelect');
    if (!sel) return;

    const __prevValue = String(sel.value||'');
    const __prevLast  = String((typeof state!=='undefined' && state && state.lastSymbolType) ? state.lastSymbolType : '');

    // Remove existing user options + dividers (deterministic rebuild)
    [...sel.querySelectorAll('option[data-user-symbol="1"], option[data-user-divider="1"], option[data-generic-divider="1"]')]
      .forEach(o=>o.remove());

    const list = _getUserSymbols();
    if (!list.length) return;

    // Insert user symbols at the TOP (no label needed)
    const firstBuiltIn = sel.firstChild;

    for (const s of list){
      if (!s || !s.id || !s.name) continue;
      const o = document.createElement('option');
      o.value = 'user:' + String(s.id);
      o.textContent = String(s.name);
      o.setAttribute('data-user-symbol','1');
      sel.insertBefore(o, firstBuiltIn);
    }

    // Insert divider for generic symbols
    const genDiv = document.createElement('option');
    genDiv.disabled = true;
    genDiv.textContent = '──────── Generic symbols ────────';
    genDiv.setAttribute('data-generic-divider','1');
    sel.insertBefore(genDiv, firstBuiltIn);

    // Preserve prior selection if it still exists (prevents falling back to Arrow)
    try{
      const want = __prevValue || __prevLast;
      if (want){
        for (const o of sel.options){ if (o && String(o.value)===String(want)){ sel.value = want; break; } }
      }
    }catch(_){ }

  }catch(_){ }
}

function _getSelectedFeaturesMulti(){
  const ids = (state.selectedIds && state.selectedIds.length) ? state.selectedIds.slice()
            : (state.selectedId != null ? [state.selectedId] : []);
  const out = [];
  for (const id of ids){
    const f = _findFeatureById ? _findFeatureById(id) : null;
    if (f) out.push(f);
  }
  return out;
}

function _collectPointsForAnchor(features){
  const pts = [];
  for (const f of features){
    if (!f) continue;
    if (f.type === 'road' || f.type === 'lane' || f.type === 'measure'){
      if (Array.isArray(f.points)) for (const p of f.points) if (p && typeof p.xM==='number' && typeof p.yM==='number') pts.push({xM:p.xM,yM:p.yM});
    } else if (f.type === 'area'){
      if (Array.isArray(f.points)) for (const p of f.points) if (p && typeof p.xM==='number' && typeof p.yM==='number') pts.push({xM:p.xM,yM:p.yM});
      if (Array.isArray(f.holes)) for (const h of f.holes) if (Array.isArray(h)) for (const p of h) if (p && typeof p.xM==='number' && typeof p.yM==='number') pts.push({xM:p.xM,yM:p.yM});
    } else if (f.type === 'label'){
      if (typeof f.xM==='number' && typeof f.yM==='number') pts.push({xM:f.xM,yM:f.yM});
      if (typeof f.txM==='number' && typeof f.tyM==='number') pts.push({xM:f.txM,yM:f.tyM});
    } else if (f.type === 'symbol'){
      // allow capturing built-in symbol as a preset symbol (as a symbol instance inside template)
      if (typeof f.xM==='number' && typeof f.yM==='number') pts.push({xM:f.xM,yM:f.yM});
    }
  }
  return pts;
}

function _computeAnchor(features){
  const pts = _collectPointsForAnchor(features);
  if (!pts.length) return {xM:0,yM:0};
  let sx=0, sy=0;
  for (const p of pts){ sx += p.xM; sy += p.yM; }
  return {xM: sx/pts.length, yM: sy/pts.length};
}

function _deepClone(obj){
  try{ return JSON.parse(JSON.stringify(obj)); }catch(_){ return null; }
}


// --- User symbol adoption helper: flatten runtime-only user symbols when saving a new preset ---
// If a selection contains a symbol feature whose symbolType is user:<id>, we expand it into concrete template items
// so the newly-saved preset is self-contained and survives refresh even if the imported runtime pack is gone.
function _expandUserSymbolInstanceToTemplateItems(userId, instanceSizeM, dx, dy, _visited){
  const visited = _visited || new Set();
  const idStr = String(userId||'');
  if (!idStr) return [];
  if (visited.has(idStr)) return []; // prevent cycles
  visited.add(idStr);

  const def = _getUserSymbolById(idStr);
  if (!def || !def.template || !Array.isArray(def.template.items)) return [];
  const base = (typeof def.baseSizeM==='number' && def.baseSizeM>0) ? def.baseSizeM : (typeof state.metersPerGrid==='number'?state.metersPerGrid:1);
  const scaleFactor = (typeof instanceSizeM==='number' && instanceSizeM>0) ? (instanceSizeM / base) : 1;

  const out = [];
  for (const it of def.template.items){
    const t = _transformTemplateItemForPreset(it, scaleFactor, dx, dy, visited);
    if (!t) continue;
    if (t && t.__EXPAND_USER_SYMBOL__){
      const more = _expandUserSymbolInstanceToTemplateItems(t.nestedId, t.nestedSizeM, t.nx, t.ny, visited);
      for (const m of more) out.push(m);
      continue;
    }
    out.push(t);
  }
  return out;
}

function _transformTemplateItemForPreset(it, scaleFactor, dx, dy, visited){
  if (!it || !it.type) return null;
  const t = _deepClone(it);
  if (!t) return null;
  delete t.id;

  const sf = (typeof scaleFactor==='number' && isFinite(scaleFactor)) ? scaleFactor : 1;
  const ox = (typeof dx==='number' && isFinite(dx)) ? dx : 0;
  const oy = (typeof dy==='number' && isFinite(dy)) ? dy : 0;

  const _mapPt = (p)=>({ xM: (p.xM*sf + ox), yM: (p.yM*sf + oy) });

  if (t.type === 'road' || t.type === 'lane' || t.type === 'measure'){
    if (Array.isArray(t.points)) t.points = t.points.map(_mapPt);
    return t;
  }

  if (t.type === 'area'){
    if (Array.isArray(t.points)) t.points = t.points.map(_mapPt);
    if (Array.isArray(t.holes)){
      t.holes = t.holes.map(h=>Array.isArray(h) ? h.map(_mapPt) : []);
    }
    return t;
  }

  if (t.type === 'label'){
    if (typeof t.xM==='number') t.xM = t.xM*sf + ox;
    if (typeof t.yM==='number') t.yM = t.yM*sf + oy;
    if (typeof t.txM==='number') t.txM = t.txM*sf + ox;
    if (typeof t.tyM==='number') t.tyM = t.tyM*sf + oy;
    return t;
  }

  if (t.type === 'symbol'){
    // Preserve built-in symbols as nested references, but expand nested user:<id> symbols
    const st = t.symbolType;
    const nx = (typeof t.xM==='number') ? (t.xM*sf + ox) : ox;
    const ny = (typeof t.yM==='number') ? (t.yM*sf + oy) : oy;

    if (typeof st==='string' && st.startsWith('user:')){
      const nestedId = st.slice(5);
      const nestedSizeM = (typeof t.sizeM==='number' && t.sizeM>0) ? (t.sizeM * sf) : (typeof state.metersPerGrid==='number'?state.metersPerGrid:1)*sf;
      // Return a placeholder null; caller should splice expanded items instead.
      // We signal expansion by attaching a private field.
      return { __EXPAND_USER_SYMBOL__: true, nestedId, nestedSizeM, nx, ny };
    }

    // Built-in or unknown nested symbol: keep as symbol item but transform position/size.
    t.xM = nx;
    t.yM = ny;
    if (typeof t.sizeM==='number' && t.sizeM>0) t.sizeM = t.sizeM * sf;
    return t;
  }

  return null;
}
function _toLocalTemplate(features, anchor){
  const items = [];
  for (const f of features){
    if (!f || !f.type) continue;
    const c = _deepClone(f);
    if (!c) continue;
    delete c.id;

    if (c.type === 'road' || c.type === 'lane' || c.type === 'measure'){
      if (Array.isArray(c.points)){
        c.points = c.points.map(p=>({xM: (p.xM - anchor.xM), yM:(p.yM - anchor.yM)}));
      }
    } else if (c.type === 'area'){
      if (Array.isArray(c.points)){
        c.points = c.points.map(p=>({xM:(p.xM-anchor.xM), yM:(p.yM-anchor.yM)}));
      }
      if (Array.isArray(c.holes)){
        c.holes = c.holes.map(h=>{
          if (!Array.isArray(h)) return [];
          return h.map(p=>({xM:(p.xM-anchor.xM), yM:(p.yM-anchor.yM)}));
        });
      }
    } else if (c.type === 'label'){
      if (typeof c.xM==='number') c.xM -= anchor.xM;
      if (typeof c.yM==='number') c.yM -= anchor.yM;
      if (typeof c.txM==='number') c.txM -= anchor.xM;
      if (typeof c.tyM==='number') c.tyM -= anchor.yM;
    } else if (c.type === 'symbol'){
      // Symbol inside selection. If it references a user preset (user:<id>), flatten it into concrete items
      // so the new preset is self-contained (does not depend on runtime-imported symbolsPack).
      const st = c.symbolType;
      const relX = (typeof c.xM==='number') ? (c.xM - anchor.xM) : 0;
      const relY = (typeof c.yM==='number') ? (c.yM - anchor.yM) : 0;

      if (typeof st==='string' && st.startsWith('user:')){
        const uid = st.slice(5);
        const sizeM = (typeof c.sizeM==='number' && c.sizeM>0) ? c.sizeM : (typeof state.metersPerGrid==='number'?state.metersPerGrid:1);
        // Expand the referenced user symbol into raw template items at this offset
        const expanded = _expandUserSymbolInstanceToTemplateItems(uid, sizeM, relX, relY);
        for (const ex of expanded){
          // Handle nested user symbols signaled by the transformer
          if (ex && ex.__EXPAND_USER_SYMBOL__){
            const more = _expandUserSymbolInstanceToTemplateItems(ex.nestedId, ex.nestedSizeM, ex.nx, ex.ny);
            for (const m of more) items.push(m);
          } else if (ex) {
            items.push(ex);
          }
        }
        continue;
      }

      // Built-in symbol: store as nested reference with relative position
      c.xM = relX;
      c.yM = relY;
      items.push(c);
      continue;
    } else {
      // Unsupported types: skip (truthful)
      continue;
    }

    items.push(c);
  }
  return items;
}

function _saveSelectionAsUserSymbol(){
  const selected = _getSelectedFeaturesMulti();
  if (!selected.length){
    setStatus && setStatus('Save preset: select geometry first.');
    return;
  }

  // Only allow a known-safe subset for v1
  const supported = new Set(['road','lane','area','label','measure','symbol']);
  const bad = selected.filter(f=>!supported.has(f.type));
  if (bad.length){
    setStatus && setStatus('Save preset: selection contains unsupported types.');
    return;
  }

  const name = prompt('Save as preset symbol — name:', 'My Symbol');
  if (!name) return;

  const anchor = _computeAnchor(selected);
  const items = _toLocalTemplate(selected, anchor);

  if (!items.length){
    setStatus && setStatus('Save preset: nothing savable in selection.');
    return;
  }

  const id = (Date.now().toString(36) + Math.random().toString(36).slice(2,8)).toLowerCase();
  const entry = {
    id,
    name: String(name).trim() || 'My Symbol',
    baseSizeM: (typeof state.metersPerGrid==='number' ? state.metersPerGrid : 1),
    template: { items }
  };

  const list = _getUserSymbols();
  list.push(entry);
  _saveUserSymbols(list);
  _refreshUserSymbolOptions();
  setStatus && setStatus('Preset symbol saved: ' + entry.name);
}

function _startStampUserSymbol(userId){
  const sel = document.getElementById('symbolSelect');
  if (!sel) return;
  const val = 'user:' + String(userId);
  // Ensure option exists (refresh will add)
  _refreshUserSymbolOptions();
  sel.value = val;

  // Enter symbol tool mode (persistent stamping)
  if (typeof setTool === 'function') setTool('symbol');
  else state.tool = 'symbol';

  setStatus && setStatus('Symbol · ' + (sel.options[sel.selectedIndex]?.textContent || 'Preset'));
}

function _deleteUserSymbolByIndex(idx){
  const list = _getUserSymbols();
  if (idx < 0 || idx >= list.length) return;
  const name = list[idx]?.name || 'this symbol';
  const ok = confirm('Delete preset symbol "' + name + '"?');
  if (!ok) return;
  list.splice(idx,1);
  _saveUserSymbols(list);
  _refreshUserSymbolOptions();
  setStatus && setStatus('Preset deleted.');
}

function _renameUserSymbolByIndex(idx){
  const list = _getUserSymbols();
  if (idx < 0 || idx >= list.length) return;
  const cur = list[idx]?.name || '';
  const name = prompt('Rename preset symbol:', cur);
  if (!name) return;
  list[idx].name = String(name).trim() || cur;
  _saveUserSymbols(list);
  _refreshUserSymbolOptions();
  setStatus && setStatus('Preset renamed.');
}

function _openUserSymbolPrompt(){
  const list = _getUserSymbols();
  const lines = [];
  lines.push('User Preset Symbols');
  lines.push('------------------');
  if (!list.length) lines.push('(none yet)');
  else {
    for (let i=0;i<list.length;i++){
      lines.push((i+1) + ') ' + (list[i].name||('Preset '+(i+1))));
    }
  }
  lines.push('');
  lines.push('Type a number to stamp that symbol.');
  lines.push('Type S to save current selection as a symbol.');
  lines.push('Type D# to delete (example: D2).');
  lines.push('Type R# to rename (example: R2).');

  const resp = prompt(lines.join('\n'), '');
  if (!resp) return;

  const s = String(resp).trim();
  if (!s) return;

  if (s.toLowerCase() === 's'){
    _saveSelectionAsUserSymbol();
    return;
  }
  const mDel = s.match(/^d\s*(\d+)$/i);
  if (mDel){
    _deleteUserSymbolByIndex(parseInt(mDel[1],10)-1);
    return;
  }
  const mRen = s.match(/^r\s*(\d+)$/i);
  if (mRen){
    _renameUserSymbolByIndex(parseInt(mRen[1],10)-1);
    return;
  }
  const n = parseInt(s,10);
  if (!isNaN(n) && n>=1 && n<=list.length){
    _startStampUserSymbol(list[n-1].id);
    return;
  }
}

const presetGeomBtn = document.getElementById('presetGeomBtn');
if (presetGeomBtn) {
  presetGeomBtn.addEventListener('click', ()=>{
    try{
      // Prefer panel UI when present; fall back to known-good prompt if anything is missing.
      if (typeof _toggleUserPresetPanel === 'function' && document.getElementById('userPresetPanel')) {
        _toggleUserPresetPanel();
      } else {
        _openUserSymbolPrompt();
      }
    }catch(_){
      try{ _openUserSymbolPrompt(); }catch(__){}
    }
  });
}

// --- PATCH BEGIN :: User Preset Symbols panel controller :: 20260115a -------------
function _refreshUserPresetPanelList(){
  const sel = document.getElementById('userPresetSelect');
  if (!sel) return;
  const list = _getUserSymbols();
  sel.innerHTML = '';
  if (!list.length){
    const o = document.createElement('option');
    o.value = '';
    o.textContent = '(none saved)';
    o.disabled = true;
    o.selected = true;
    sel.appendChild(o);
    return;
  }
  list.forEach((s, i)=>{
    const o = document.createElement('option');
    o.value = String(s.id);
    o.textContent = `${i+1}. ${String(s.name || ('Preset '+(i+1)))}`;
    sel.appendChild(o);
  });
  // Keep prior selection if possible
  if (sel.options.length) sel.selectedIndex = 0;
}

function _openUserPresetPanel(){
  const panel = document.getElementById('userPresetPanel');
  if (!panel) return;
  panel.classList.add('open');
  panel.setAttribute('aria-hidden','false');
  try{ _refreshUserPresetPanelList(); }catch(_){/* no-op */}
}

function _closeUserPresetPanel(){
  const panel = document.getElementById('userPresetPanel');
  if (!panel) return;
  panel.classList.remove('open');
  panel.setAttribute('aria-hidden','true');
}

function _toggleUserPresetPanel(forceOpen){
  const panel = document.getElementById('userPresetPanel');
  if (!panel) return;
  const isOpen = panel.classList.contains('open');
  if (forceOpen === true || !isOpen) _openUserPresetPanel();
  else _closeUserPresetPanel();
}

function _wireUserPresetPanelUI(){
  const panel  = document.getElementById('userPresetPanel');
  const sel    = document.getElementById('userPresetSelect');
  const btnX   = document.getElementById('userPresetCloseBtn');
  const btnStamp  = document.getElementById('userPresetStampBtn');
  const btnSave   = document.getElementById('userPresetSaveBtn');
  const btnRen    = document.getElementById('userPresetRenameBtn');
  const btnDel    = document.getElementById('userPresetDeleteBtn');
  if (!panel || !sel) return;

  const getSelectedIndex = ()=>{
    const id = String(sel.value || '');
    if (!id) return -1;
    const list = _getUserSymbols();
    return list.findIndex(s => s && String(s.id) === id);
  };

  btnX && btnX.addEventListener('click', ()=>{ try{ _closeUserPresetPanel(); }catch(_){} });

  btnStamp && btnStamp.addEventListener('click', ()=>{
    try{
      const id = String(sel.value || '');
      if (!id) return;
      _startStampUserSymbol(id);
      _closeUserPresetPanel();
    }catch(_){/* no-op */}
  });

  btnSave && btnSave.addEventListener('click', ()=>{
    try{
      _saveSelectionAsUserSymbol();
      _refreshUserPresetPanelList();
      _refreshUserSymbolOptions();
    }catch(_){/* no-op */}
  });

  btnRen && btnRen.addEventListener('click', ()=>{
    try{
      const idx = getSelectedIndex();
      if (idx < 0) return;
      _renameUserSymbolByIndex(idx);
      _refreshUserPresetPanelList();
      _refreshUserSymbolOptions();
    }catch(_){/* no-op */}
  });

  btnDel && btnDel.addEventListener('click', ()=>{
    try{
      const idx = getSelectedIndex();
      if (idx < 0) return;
      _deleteUserSymbolByIndex(idx);
      _refreshUserPresetPanelList();
      _refreshUserSymbolOptions();
    }catch(_){/* no-op */}
  });
}

try{
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ()=>{ try{ _wireUserPresetPanelUI(); }catch(_){} });
  } else {
    _wireUserPresetPanelUI();
  }
}catch(_){/* no-op */}
// --- PATCH END :: User Preset Symbols panel controller :: 20260115a ---------------

// Build user symbol options once at boot.
try{ _refreshUserSymbolOptions(); }catch(_){}
function _getUserSymbolById(id){
  // Resolution order:
  // 1) Runtime registry (imported draft symbol packs)
  // 2) Local user library (localStorage)
  const rt = _getRuntimeUserSymbolById(id);
  if (rt) return rt;
  const list = _getUserSymbols();
  return list.find(s=>s && String(s.id)===String(id)) || null;
}

function _drawPolylineLocalPx(points, ppm, scaleFactor){
  if (!points || points.length<2) return;
  ctx.beginPath();
  ctx.moveTo(points[0].xM * ppm * scaleFactor, points[0].yM * ppm * scaleFactor);
  for (let i=1;i<points.length;i++){
    ctx.lineTo(points[i].xM * ppm * scaleFactor, points[i].yM * ppm * scaleFactor);
  }
  ctx.stroke();
}

function _drawAreaLocalPx(area, ppm, scaleFactor){
  if (!area || !Array.isArray(area.points) || area.points.length<3) return;

  // Outer ring
  ctx.beginPath();
  ctx.moveTo(area.points[0].xM * ppm * scaleFactor, area.points[0].yM * ppm * scaleFactor);
  for (let i=1;i<area.points.length;i++){
    ctx.lineTo(area.points[i].xM * ppm * scaleFactor, area.points[i].yM * ppm * scaleFactor);
  }
  ctx.closePath();

  // Holes (evenodd)
  if (Array.isArray(area.holes)){
    for (const h of area.holes){
      if (!Array.isArray(h) || h.length<3) continue;
      ctx.moveTo(h[0].xM * ppm * scaleFactor, h[0].yM * ppm * scaleFactor);
      for (let i=1;i<h.length;i++){
        ctx.lineTo(h[i].xM * ppm * scaleFactor, h[i].yM * ppm * scaleFactor);
      }
      ctx.closePath();
    }
  }

  const prevAlpha = ctx.globalAlpha;
  ctx.globalAlpha = (typeof area.fillOpacity==='number') ? area.fillOpacity : 0.12;
  ctx.fillStyle   = area.fillColor || '#38bdf8';
  try{ ctx.fill('evenodd'); }catch(_){ ctx.fill(); }
  ctx.globalAlpha = prevAlpha;
}

function _drawLabelLocalPx(lbl, ppm, scaleFactor){
  if (!lbl) return;
  const xPx = (typeof lbl.xM==='number' ? lbl.xM : 0) * ppm * scaleFactor;
  const yPx = (typeof lbl.yM==='number' ? lbl.yM : 0) * ppm * scaleFactor;
  const sizeM = (typeof lbl.sizeM==='number' ? lbl.sizeM : 1);
  const fontPx = Math.max(10, sizeM * ppm * scaleFactor);
  ctx.save();
  ctx.fillStyle = '#e5e7eb';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = `${fontPx}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
  ctx.fillText(String(lbl.text || ''), xPx, yPx);
  ctx.restore();
}

function _drawUserPresetSymbol(userId, f, ppm, sizeM){
  const def = _getUserSymbolById(userId);
  if (!def || !def.template || !Array.isArray(def.template.items)){
    // Truthful fail: draw a small X marker to show missing preset
    ctx.save();
    ctx.strokeStyle = '#ef4444';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-6,-6); ctx.lineTo(6,6);
    ctx.moveTo(-6,6); ctx.lineTo(6,-6);
    ctx.stroke();
    ctx.restore();
    return;
  }
  const base = (typeof def.baseSizeM==='number' && def.baseSizeM>0) ? def.baseSizeM : (typeof state.metersPerGrid==='number'?state.metersPerGrid:1);
  const scaleFactor = (typeof sizeM==='number' && sizeM>0) ? (sizeM / base) : 1;

  // Drafting look (match built-in symbol vibe)
  const strokeColor = '#e5e7eb';
  for (const it of def.template.items){
    if (!it || !it.type) continue;

    if (it.type === 'road' || it.type === 'lane' || it.type === 'measure'){
      ctx.save();
      ctx.strokeStyle = it.strokeColor || strokeColor;
      ctx.lineWidth   = (typeof it.strokeWidthPx==='number') ? it.strokeWidthPx : 2;
      try{ ctx.setLineDash(Array.isArray(it.strokeDash)?it.strokeDash:[]); }catch(_){}
      ctx.lineJoin='round'; ctx.lineCap='round';
      _drawPolylineLocalPx(it.points, ppm, scaleFactor);
      ctx.restore();
    } else if (it.type === 'area'){
      ctx.save();
      _drawAreaLocalPx(it, ppm, scaleFactor);
      // Optional outline for visibility
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = 1.5;
      try{ ctx.setLineDash([]); }catch(_){}
      _drawPolylineLocalPx(it.points.concat([it.points[0]]), ppm, scaleFactor);
      ctx.restore();
    } else if (it.type === 'label'){
      _drawLabelLocalPx(it, ppm, scaleFactor);
    } else if (it.type === 'symbol'){
      // Nested built-in symbol inside a user template (kept simple):
      const nested = Object.assign({}, it);
      nested.xM = (typeof it.xM==='number') ? it.xM * scaleFactor : 0;
      nested.yM = (typeof it.yM==='number') ? it.yM * scaleFactor : 0;
      // Render nested symbol at local offset by temporarily shifting
      ctx.save();
      ctx.translate(nested.xM * ppm, nested.yM * ppm);
      const prevType = nested.symbolType;
      if (typeof prevType==='string' && prevType.startsWith('user:')){
        _drawUserPresetSymbol(prevType.slice(5), nested, ppm, (nested.sizeM||sizeM));
      } else {
        // Reuse built-in draw by calling existing dispatch body using a small shim:
        // We can't call drawSymbolFeature here (it would re-translate), so we do minimal:
        // For v1, nested symbols inside presets are not guaranteed. Keep a small circle marker.
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0,0, 6, 0, Math.PI*2);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
}

  // --- chunk 14.U END — User Symbol Presets (save + stamp) ---------------------------

// --- Topbar EDIT dropdown (Edit ▾) --------------------------------------------
  // NOTE: Topbar edit menu buttons are UI-only triggers; actual edit logic remains unchanged.
  const editMenu = document.getElementById('editMenu');

  // EDIT dropdown: supports nested submenus (Group objects) similar to Draw ▸ Shapes
  // - main panel: [data-open-edit-submenu], normal edit buttons, #topEditMenuCloseBtn
  // - submenu panel: [data-edit-submenu-back]
  const editMainPanel    = document.getElementById('editMainPanel');
  const editSubmenuPanel = document.getElementById('editSubmenuPanel');
  const _editSubmenuState = { openName: null, openerEl: null };

  const closeEditSubmenu = ()=>{
    try{
      if (editSubmenuPanel){
        // Accessibility: avoid hiding a panel while a descendant still has focus (prevents Chrome "Blocked aria-hidden" warnings)
        const _ae = document.activeElement;
        if (_ae && editSubmenuPanel.contains(_ae)){
          try{ _ae.blur(); }catch(_){}
        }
        editSubmenuPanel.classList.remove('open');
        editSubmenuPanel.setAttribute('aria-hidden','true');
      }
      if (editMainPanel){
        editMainPanel.classList.remove('overlay-hidden');
      }
      try{
        editMenu && editMenu.querySelectorAll('[data-open-edit-submenu]').forEach(btn=>{
          btn.setAttribute('aria-expanded','false');
        });
      }catch(_){}
      _editSubmenuState.openName = null;
      _editSubmenuState.openerEl = null;
    }catch(_){}
  };

  const openEditSubmenu = (name, openerEl)=>{
    try{
      if (!editSubmenuPanel || !editMainPanel) return;

      // Close any open submenu first
      if (_editSubmenuState.openName && _editSubmenuState.openName !== name){
        closeEditSubmenu();
      }

      // Show only the requested submenu body
      try{
        editSubmenuPanel.querySelectorAll('[data-edit-submenu]').forEach(body=>{
          body.style.display = (body.getAttribute('data-edit-submenu') === name) ? 'flex' : 'none';
        });
      }catch(_){}

      _editSubmenuState.openName = name;
      _editSubmenuState.openerEl = openerEl || null;

      // aria
      try{
        editMenu && editMenu.querySelectorAll('[data-open-edit-submenu]').forEach(btn=>{
          btn.setAttribute('aria-expanded', (btn === openerEl) ? 'true' : 'false');
        });
      }catch(_){}

      // Overlay replacement (match Draw ▸ Shapes behavior; avoids scroll / viewport overflow)
      editMainPanel.classList.add('overlay-hidden');
      editSubmenuPanel.classList.add('open');
      editSubmenuPanel.setAttribute('aria-hidden','false');
    }catch(_){}
  };

  if (editMenu){
    editMenu.addEventListener('click', (e)=>{
      try{
        const t = e.target && e.target.closest ? e.target.closest('[data-open-edit-submenu],[data-edit-submenu-back]') : null;
        if (!t) return;
        if (t.hasAttribute('data-open-edit-submenu')){
          e.preventDefault();
          e.stopPropagation();
          const name = t.getAttribute('data-open-edit-submenu');
          openEditSubmenu(name, t);
          return;
        }
        if (t.hasAttribute('data-edit-submenu-back')){
          e.preventDefault();
          e.stopPropagation();
          closeEditSubmenu();
          return;
        }
      }catch(_){}
    });
  }

  const topEditBendBtn        = document.getElementById('topEditBendBtn');
  const topEditRotateBtn      = document.getElementById('topEditRotateBtn');
  const topEditScaleBtn       = document.getElementById('topEditScaleBtn');
  const topEditMultiSelectBtn =
    document.getElementById('topMultiSelectBtn5') ||
    document.getElementById('topEditMultiSelectBtn');
  const topEditMoveShapeBtn   = document.getElementById('topEditMoveShapeBtn');
  const topEditMovePointBtn   = document.getElementById('topEditMovePointBtn');
  const topEditAddVertexBtn   = document.getElementById('topEditAddVertexBtn');
  const topEditRemoveVertexBtn= document.getElementById('topEditRemoveVertexBtn');
  const topEditSplitLineBtn   = document.getElementById('topEditSplitLineBtn');

  // Copy/Paste (Edit ▾ → Duplicate submenu)
  const topEditCopyBtn        = document.getElementById('topEditCopyBtn');
  const topEditCopyBtnMain = document.getElementById("topEditCopyBtnMain");
const topEditPasteBtnMain = document.getElementById("topEditPasteBtnMain");
const topEditRadialArrayBtnMain = document.getElementById("topEditRadialArrayBtnMain");
const topEditPasteBtn       = document.getElementById('topEditPasteBtn');
const topEditRadialArrayBtn     = document.getElementById('topEditRadialArrayBtn');

  const topEditDuplicateBtn   = document.getElementById('topEditDuplicateBtn');
  const topEditDuplicateMirrorBtn = document.getElementById('topEditDuplicateMirrorBtn');
  const topEditArrayRepeatBtn     = document.getElementById('topEditArrayRepeatBtn');
  const topEditOffsetParallelBtn  = document.getElementById('topEditOffsetParallelBtn');
  const topEditCutoutBtn      = document.getElementById('topEditCutoutBtn');
  const topEditMenuCloseBtn   = document.getElementById('topEditMenuCloseBtn');
  // Group submenu buttons (Phase 2: behavior)
  const topGroupCreateBtn  = document.getElementById('topGroupCreateBtn');
  const topGroupAddBtn     = document.getElementById('topGroupAddBtn');
  const topGroupRemoveBtn  = document.getElementById('topGroupRemoveBtn');
  const topGroupCombineBtn = document.getElementById('topGroupCombineBtn');
  const topGroupDisbandBtn = document.getElementById('topGroupDisbandBtn');
  const topGroupTotalAreaBtn = document.getElementById('topGroupTotalAreaBtn');

  function _focusGroupProp(){
    try{
      if (propGroupInput){
        propGroupInput.scrollIntoView({block:'center', inline:'nearest', behavior:'smooth'});
        propGroupInput.focus();
        if (propGroupInput.select) propGroupInput.select();
      }
    }catch(_){}
  }

  function _ensureSelected(){
    const f = state.features.find(x=>x.id===state.selectedId);
    if(!f){ setStatusHint('Select an object first.'); return null; }
    return f;
  }

  function _promptCreateIfNoBase(sel, actionLabel){
    const base = getBaseGroupId(sel);
    if (base) return base;
    const ok = confirm('Selected object is not in a group. Create one?');
    if (!ok){
      setStatusHint(actionLabel+': cancelled.');
      return null;
    }
    _focusGroupProp();
    setStatusHint(actionLabel+': set a Group name in Properties, then tap objects.');
    return null;
  }

  function _armGroupMode(mode){
    setTool('inspect');
    setEditMode(mode);
    try{ syncTopbarEditUI(); }catch(_){ }
    draw();
  }

  if(topGroupCreateBtn) topGroupCreateBtn.addEventListener('click',()=>{
    closeEditMenu();
    const sel = _ensureSelected();
    if(!sel) return;
    _focusGroupProp();
    setStatusHint('Group: set base Group name in Properties.');
  });

  if(topGroupAddBtn) topGroupAddBtn.addEventListener('click',()=>{
    closeEditMenu();
    const sel = _ensureSelected();
    if(!sel) return;
    const base = _promptCreateIfNoBase(sel, 'Add to group');
    _armGroupMode('groupAdd');
    if (base){
      setStatusHint('Add to group '+base+': tap objects to add (stays armed).');
    }
  });

  if(topGroupRemoveBtn) topGroupRemoveBtn.addEventListener('click',()=>{
    closeEditMenu();
    const sel = _ensureSelected();
    if(!sel) return;
    const eff = getEffectiveGroupId(sel);
    if(!eff){
      setStatusHint('Remove from group: selected object is not in a group.');
      return;
    }
    _armGroupMode('groupRemove');
    setStatusHint('Remove from group '+eff+': tap objects in this group to remove (stays armed).');
  });

  if(topGroupCombineBtn) topGroupCombineBtn.addEventListener('click',()=>{
    closeEditMenu();
    const sel = _ensureSelected();
    if(!sel) return;
    const base = _promptCreateIfNoBase(sel, 'Combine groups');
    _armGroupMode('groupCombine');
    if (base){
      setStatusHint('Combine groups under authority '+base+': tap an object in another group.');
    }
  });

  if(topGroupDisbandBtn) topGroupDisbandBtn.addEventListener('click',()=>{
    closeEditMenu();
    const sel = _ensureSelected();
    if(!sel) return;
    const eff = getEffectiveGroupId(sel);
    if(!eff){
      setStatusHint('Disband authority: selected object is not in a group.');
      return;
    }
    const anyOverlay = state.features.some(ff => ff && getAuthorityGroupId(ff) === eff);
    if(!anyOverlay){
      setStatusHint('Disband authority: no authority overlay active for '+eff+'.');
      return;
    }
    pushHistory('disbandAuthority');
    const changed = clearAuthorityOverlay(eff);
    setStatusHint('Authority '+eff+' disbanded ('+changed+' objects reverted).');
    draw();
  });

  // Total area in group (areas only)
  if (topGroupTotalAreaBtn) topGroupTotalAreaBtn.addEventListener('click', ()=>{
    closeEditMenu();
    try{
      const ids = (state.multiSelectEnabled && Array.isArray(state.selectedIds) && state.selectedIds.length)
        ? state.selectedIds.slice()
        : (state.selectedId != null ? [state.selectedId] : []);

      if (!ids.length){
        setStatusHint('Total area: select area(s) or a grouped object first.');
        return;
      }

      const selectedFeats = ids.map(id => state.features.find(x=>x && x.id===id)).filter(Boolean);
      const selectedAreas = selectedFeats.filter(f => f && f.type === 'area');

      let scopeLabel = '';
      let areasToSum = [];

      if (selectedAreas.length >= 2){
        // Multi-select of areas: sum selection directly
        scopeLabel = 'selected areas';
        areasToSum = selectedAreas.slice();
      } else if (selectedAreas.length === 1){
        // Single selected area: if it belongs to a group, sum all areas in that group; else just itself
        const a0 = selectedAreas[0];
        const gid = getEffectiveGroupId(a0);
        if (gid){
          scopeLabel = 'group ' + gid;
          areasToSum = getEffectiveGroupMembers(gid).filter(f => f && f.type === 'area');
          if (!areasToSum.length){
            // Fallback: at least include the selected area
            areasToSum = [a0];
          }
        } else {
          scopeLabel = 'selected area';
          areasToSum = [a0];
        }
      } else {
        // No selected areas: if selected object is in a group, sum that group's areas
        const sel = selectedFeats[0];
        const gid = getEffectiveGroupId(sel);
        if (!gid){
          setStatusHint('Total area: select area(s) or a grouped object first.');
          return;
        }
        scopeLabel = 'group ' + gid;
        areasToSum = getEffectiveGroupMembers(gid).filter(f => f && f.type === 'area');
        if (!areasToSum.length){
          setStatusHint('Total area: group ' + gid + ' contains no areas.');
          return;
        }
      }

      let totalM2 = 0;
      areasToSum.forEach(a=>{
        try{
          // Always compute from geometry so stale areaM2 never lies
          totalM2 += areaWithHoles(a);
        }catch(_){
          if (Number.isFinite(a.areaM2)) totalM2 += a.areaM2;
        }
      });

      const unitEl = document.getElementById('selAreaUnit');
      const unit = unitEl ? String(unitEl.textContent || '').trim() : 'm²';
      const disp = areaDisplayValue(totalM2);
      const msg = 'Total area (' + scopeLabel + '): ' + (Math.round(disp*100)/100).toFixed(2) + ' ' + unit;

      try{ setStatusHint(msg); } catch(_){}
      try{ alert(msg); } catch(_){}
    }catch(e){
      console.warn('Total area handler failed', e);
      try{ setStatusHint('Total area failed (see console).'); } catch(_){}
    }
  });

  const closeEditMenu = ()=>{
    try { closeEditSubmenu(); } catch(_) {}
    try { if (editMenu && editMenu.open) editMenu.open = false; } catch(_) {}
  };

  if (topEditMenuCloseBtn){
    topEditMenuCloseBtn.addEventListener('click', ()=>{ closeEditMenu(); });

  // Close the edit menu when tapped (no behavioral side-effects yet).
  [topGroupCreateBtn, topGroupAddBtn, topGroupRemoveBtn, topGroupCombineBtn, topGroupDisbandBtn].forEach(btn=>{
    if (!btn) return;
    btn.addEventListener('click', ()=>{ try{ closeEditMenu(); }catch(_){} });
  });

  }

  // Bend (tool mode, not editMode)
  if (topEditBendBtn){
    topEditBendBtn.addEventListener('click', ()=>{
      try { setTool('bend'); } catch(_) {}
      closeEditMenu();
    });
  }

  if (topEditRotateBtn){
    topEditRotateBtn.addEventListener('click', ()=>{
      try {
        if (state.tool!=='inspect') setTool('inspect');
        setEditMode(state.editMode==='rotate'?'none':'rotate');
      } catch(_) {}
      closeEditMenu();
    });
  }


  // Multi-select toggle (selection mode, not an editMode)
  if (topEditMultiSelectBtn){
    topEditMultiSelectBtn.addEventListener('click', ()=>{
      try{
        // Multi-select is an Inspect semantic; ensure tool is Inspect and no edit mode is armed.
        if (state.tool!=='inspect') setTool('inspect');
        if (state.editMode && state.editMode !== 'none') setEditMode('none');

        state.multiSelectEnabled = !state.multiSelectEnabled;
        if (!state.multiSelectEnabled){
          // Collapse back to single selection (keep primary)
          _setSelectionSingle(state.selectedId);
        } else {
          // Ensure selectedIds mirrors current primary selection
          _setSelectionMulti(state.selectedIds && state.selectedIds.length ? state.selectedIds : (state.selectedId!=null ? [state.selectedId] : []), state.selectedId);
        }

        setStatusHint(state.multiSelectEnabled
          ? 'Multi-select ON · Tap objects to add/remove. Use Move/Duplicate to act on the set.'
          : 'Multi-select OFF');
        try{ syncTopbarEditUI(); }catch(_){}
        draw();
      }catch(_){}
    });
  }

  // Scale (uniform) — geometry transform, NOT view scale.
  if (topEditScaleBtn){
    topEditScaleBtn.addEventListener('click', ()=>{
      try {
        // Ensure we're in inspect so selection semantics are consistent.
        if (state.tool!=='inspect') setTool('inspect');

        const sel = _ensureSelected();
        if (!sel){ closeEditMenu(); return; }

        const factorStr = prompt('Scale factor (uniform). Example: 2 doubles, 0.5 halves', '1');
        if (factorStr == null){ setStatusHint('Scale: cancelled.'); closeEditMenu(); return; }
        const factor = parseFloat(String(factorStr).trim());
        if (!isFinite(factor) || factor <= 0){
          setStatusHint('Scale: invalid factor.');
          closeEditMenu();
          return;
        }

        if (factor === 1){
          setStatusHint('Scale: factor is 1 (no visible change). Try 2 or 0.5.');
        }

        // Resolve membership (single feature, group, or multi-select set)
        // NOTE: getEffectiveGroupMembers expects a GROUP ID, not a feature object.
        const _gid = getEffectiveGroupId(sel);

        let members = null;
        if (_gid){
          members = getEffectiveGroupMembers(_gid);
        } else if (state.multiSelectEnabled && Array.isArray(state.selectedIds) && state.selectedIds.length > 1){
          const ids = state.selectedIds.filter(Boolean);
          const feats = ids.map(id => (_findFeatureById ? _findFeatureById(id) : state.features.find(x => x && x.id === id))).filter(Boolean);
          members = feats.length ? feats : [sel];
        } else {
          members = [sel];
        }

        // Locked-layer safety: deny scale if any member is locked.
        for (const mf of members){
          if (mf && _isFeatureLocked && _isFeatureLocked(mf)) { _denyLockedEdit('scale', mf); closeEditMenu(); return; }
        }

        // Compute pivot as bbox center over all member geometry
        let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;

        function _accumXY(xM,yM){
          if (xM<minX) minX=xM;
          if (yM<minY) minY=yM;
          if (xM>maxX) maxX=xM;
          if (yM>maxY) maxY=yM;
        }

        members.forEach(f=>{
          if (!f) return;
          if (Array.isArray(f.points)){
            f.points.forEach(p=>{ if (!p) return;
      if (p.xM!=null && p.yM!=null) _accumXY(p.xM, p.yM); else if (p.x!=null && p.y!=null) _accumXY(p.x, p.y); });
          } else {
            if (f.xM!=null && f.yM!=null) _accumXY(f.xM, f.yM);
          }
          // Labels may carry explicit text point
          if (f.type==='label'){
            if (f.txM!=null && f.tyM!=null) _accumXY(f.txM, f.tyM);
          }
        });

        if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)){
          setStatusHint('Scale: nothing to scale.');
          closeEditMenu();
          return;
        }

        const pivot = { xM: (minX+maxX)/2, yM: (minY+maxY)/2 };

        // Commit: push history once for the whole transform
        pushHistory('Scale x' + factor.toFixed(3));

        function _scaleXY(xM,yM){
          return {
            xM: pivot.xM + (xM - pivot.xM) * factor,
            yM: pivot.yM + (yM - pivot.yM) * factor
          };
        }

        members.forEach(f=>{
          if (!f) return;
          if (Array.isArray(f.points)){
            f.points.forEach(p=>{
              if (!p) return;
              if (p.xM!=null && p.yM!=null){
                const s = _scaleXY(p.xM, p.yM);
                p.xM = s.xM;
                p.yM = s.yM;
              } else if (p.x!=null && p.y!=null){
                const s = _scaleXY(p.x, p.y);
                p.x = s.xM;
                p.y = s.yM;
              }
            });
          }
          // Anchored objects
          if (f.xM!=null && f.yM!=null){
            const s = _scaleXY(f.xM, f.yM);
            f.xM = s.xM;
            f.yM = s.yM;
          }
          // Label secondary point
          if (f.type==='label' && f.txM!=null && f.tyM!=null){
            const s = _scaleXY(f.txM, f.tyM);
            f.txM = s.xM;
            f.tyM = s.yM;
          }

          // Scale size for symbol/label if present or implied
          if (f.type==='symbol'){
            const base = (f.sizeM!=null) ? f.sizeM : state.metersPerGrid;
            f.sizeM = base * factor;
          }
          if (f.type==='label'){
            const base = (f.sizeM!=null) ? f.sizeM : (state.metersPerGrid * 0.5);
            f.sizeM = base * factor;
          }
        });

        setStatusHint('Scaled x' + factor.toFixed(3));
        try{ syncTopbarEditUI(); }catch(_){ }
        draw();
      } catch(e){
        console.warn('Scale failed', e);
      }
      closeEditMenu();
    });
  }
  // Edit modes (inspect + editMode)
  if (topEditMoveShapeBtn){
    topEditMoveShapeBtn.addEventListener('click', ()=>{
      try {
        if (state.tool!=='inspect') setTool('inspect');
        setEditMode(state.editMode==='moveShape'?'none':'moveShape');
      } catch(_) {}
      closeEditMenu();
    });
  }

  if (topEditMovePointBtn){
    topEditMovePointBtn.addEventListener('click', ()=>{
      try {
        if (state.tool!=='inspect') setTool('inspect');
        setEditMode(state.editMode==='movePoint'?'none':'movePoint');
      } catch(_) {}
      closeEditMenu();
    });
  }

  if (topEditAddVertexBtn){
    topEditAddVertexBtn.addEventListener('click', ()=>{
      try {
        if (state.tool!=='inspect') setTool('inspect');
        setEditMode(state.editMode==='addVertex'?'none':'addVertex');
      } catch(_) {}
      closeEditMenu();
    });
  }

  if (topEditRemoveVertexBtn){
    topEditRemoveVertexBtn.addEventListener('click', ()=>{
      try {
        if (state.tool!=='inspect') setTool('inspect');
        setEditMode(state.editMode==='removeVertex'?'none':'removeVertex');
      } catch(_) {}
      closeEditMenu();
    });
  }

  if (topEditSplitLineBtn){
    topEditSplitLineBtn.addEventListener('click', ()=>{
      try {
        if (state.tool!=='inspect') setTool('inspect');
        setEditMode(state.editMode==='splitLine'?'none':'splitLine');
      } catch(_) {}
      closeEditMenu();
    });
  }
  // --- Copy/Paste buffer (module-local; not serialized) ---
  let _fdClipboard = { feats: [], at: 0 };
  let _fdPasteNudge = 0;

  // --- Paste placement mode (Copy/Paste becomes place-at-tap; avoids redundancy with Duplicate) ---
  let _fdPastePlace = { anchor: { xM: 0, yM: 0 } };

  const _fdBoundsForFeats = (feats)=>{
    try{
      feats = Array.isArray(feats) ? feats : [];
      if (!feats.length) return null;
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      const bump = (xM,yM)=>{
        if (!isFinite(xM) || !isFinite(yM)) return;
        if (xM < minX) minX = xM;
        if (yM < minY) minY = yM;
        if (xM > maxX) maxX = xM;
        if (yM > maxY) maxY = yM;
      };
      feats.forEach(f=>{
        if (!f) return;
        if (Array.isArray(f.points) && f.points.length){
          f.points.forEach(p=>bump(p && p.xM, p && p.yM));
        }
        if (f.type === 'area' && Array.isArray(f.holes) && f.holes.length){
          // Include hole verts so anchor reflects full geometry footprint
          f.holes.forEach(h=>{
            if (!h || !Array.isArray(h.points)) return;
            h.points.forEach(p=>bump(p && p.xM, p && p.yM));
          });
        }
        if (f.type === 'symbol' && isFinite(f.xM) && isFinite(f.yM)) {
          const s = (f.sizeM || state.metersPerGrid || 1) * 0.75;
          bump(f.xM - s, f.yM - s);
          bump(f.xM + s, f.yM + s);
        }
        if (f.type === 'label'){
          if (isFinite(f.xM) && isFinite(f.yM)) bump(f.xM, f.yM);
          if (isFinite(f.txM) && isFinite(f.tyM)) bump(f.txM, f.tyM);
        }
      });
      if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) return null;
      if (maxX - minX < 1e-6) maxX = minX + 1;
      if (maxY - minY < 1e-6) maxY = minY + 1;
      return { minX, minY, maxX, maxY };
    }catch(_){ return null; }
  };

  const _fdCenterOfBounds = (b)=>{
    if (!b) return { xM: 0, yM: 0 };
    return { xM: (b.minX + b.maxX)/2, yM: (b.minY + b.maxY)/2 };
  };

  // Copy (Edit ▾ → Duplicate submenu)
  if (topEditCopyBtn){
    topEditCopyBtn.addEventListener('click', ()=>{
      try {
        const ids = (state.multiSelectEnabled && Array.isArray(state.selectedIds) && state.selectedIds.length)
          ? state.selectedIds.slice()
          : (state.selectedId != null ? [state.selectedId] : []);

        if (!ids.length) { alert('Select something to copy first.'); return; }

        const feats = ids.map(id => state.features.find(x=>x.id===id)).filter(Boolean);
        if (!feats.length) { setStatusHint('Copy: nothing found.'); closeEditMenu(); return; }

        // Copy is read-only; we do not push history.
        _fdClipboard = { feats: feats.map(f => deepClone(f)), at: Date.now() };
        setStatusHint(`Copied ${_fdClipboard.feats.length} item${_fdClipboard.feats.length===1?'':'s'}. Navigate to paste location, then press Paste.`);
        try { if (state.tool!=='inspect') setTool('inspect'); } catch(_) {}
        try { setEditMode('none'); } catch(_) {}
      } catch(e) { try { console.error(e); } catch(_) {} setStatusHint('Copy failed: ' + (e && e.message ? e.message : 'unknown error')); }closeEditMenu();
    });
  }

  // Paste (Edit ▾ → Duplicate submenu)
  if (topEditPasteBtn){
    topEditPasteBtn.addEventListener('click', ()=>{
      try {
        if (!_fdClipboard || !_fdClipboard.feats || !_fdClipboard.feats.length){
          setStatusHint('Paste: clipboard empty.');
          closeEditMenu();
          return;
        }

        // Deny if any clipboard feature is on a locked layer (predictable rule)
        const locked = _fdClipboard.feats.find(f => _isFeatureLocked(f));
        if (locked) { _denyLockedEdit('paste', locked); setStatusHint('Paste blocked: layer is locked.'); closeEditMenu(); return; }

        // Paste is a two-step placement: arm placement now, then user taps target location.
        // Pressing Paste again cancels.
        if (state.editMode === 'pastePlace'){
          try { setEditMode('none'); } catch(_) {}
          setStatusHint('Paste cancelled.');
          closeEditMenu();
          return;
        }

        // Compute anchor (center of clipboard bounds) so multi-item paste stays coherent.
        const b = _fdBoundsForFeats(_fdClipboard.feats);
        _fdPastePlace.anchor = _fdCenterOfBounds(b);

        try { if (state.tool!=='inspect') setTool('inspect'); } catch(_) {}
        try { setEditMode('pastePlace'); } catch(_) {}
        setStatusHint('Paste: tap a location to place.');
      } catch(e) { try { console.error(e); } catch(_) {} setStatusHint('Paste failed: ' + (e && e.message ? e.message : 'unknown error')); }closeEditMenu();
    });
  }  // Copy/Paste (Edit ▾ main panel shortcuts)
  if (topEditCopyBtnMain && topEditCopyBtn){
    topEditCopyBtnMain.addEventListener("click", ()=> topEditCopyBtn.click());
  }
  if (topEditPasteBtnMain && topEditPasteBtn){
    topEditPasteBtnMain.addEventListener("click", ()=> topEditPasteBtn.click());
  }
  if (topEditRadialArrayBtnMain && topEditRadialArrayBtn){
    topEditRadialArrayBtnMain.addEventListener("click", ()=> topEditRadialArrayBtn.click());
  }


  // Duplicate (direct; same logic as prior stackYBtn3)
  if (topEditDuplicateBtn){
    topEditDuplicateBtn.addEventListener('click', ()=>{
      try {
        const ids = (state.multiSelectEnabled && Array.isArray(state.selectedIds) && state.selectedIds.length)
          ? state.selectedIds.slice()
          : (state.selectedId != null ? [state.selectedId] : []);

        if (!ids.length) { alert('Select something to duplicate first.'); return; }

        // Resolve features; deny if any locked (all-or-nothing for predictability)
        const feats = ids.map(id => state.features.find(x=>x.id===id)).filter(Boolean);
        if (!feats.length) { setStatusHint('Duplicate: nothing found.'); closeEditMenu(); return; }
        const locked = feats.find(f => _isFeatureLocked(f));
        if (locked) { _denyLockedEdit('duplicate', locked); closeEditMenu(); return; }

        pushHistory('duplicate');
        const offset = state.metersPerGrid || 1;

        const newIds = [];
        for (const f of feats){
          const clone = deepClone(f);
          clone.id = state.nextId++;
          // Duplicates should not inherit grouping (prevents "haunted" group behavior)
          if (clone.groupId != null) clone.groupId = null;
          if (clone.groupAuthorityId != null) clone.groupAuthorityId = null;

          if (Array.isArray(clone.points)) {
            clone.points = clone.points.map(p=>({xM:p.xM+offset,yM:p.yM+offset}));
          }
          if (Array.isArray(clone.holes)) {
            clone.holes = clone.holes.map(poly=>poly.map(p=>({xM:p.xM+offset, yM:p.yM+offset})));
          }
          if (typeof clone.xM==='number') clone.xM += offset;
          if (typeof clone.yM==='number') clone.yM += offset;
          if (typeof clone.txM==='number') clone.txM += offset;
          if (typeof clone.tyM==='number') clone.tyM += offset;
          if (clone.type==='area') clone.areaM2 = areaWithHoles(clone);

          state.features.push(clone);
          newIds.push(clone.id);
        }

        if (state.multiSelectEnabled){
          _setSelectionMulti(newIds, newIds.length ? newIds[newIds.length-1] : null);
          updateFeatureSelect();
          refreshSelectedInspector();
          draw();
        } else {
          selectFeatureById(newIds[newIds.length-1]);
        }
      } catch(_) {}
      closeEditMenu();
    });
  }

  // Cut-out (direct; mirrors prior stackXBtn2 behavior)
  
  // SUB-CHUNK 16.DUPX BEGIN — Duplicate Mirror / Array Repeat / Offset Parallel (v1)
  function _getFeaturesWorldBounds(feats){
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    const bump = (xM, yM) => {
      if (!isFinite(xM) || !isFinite(yM)) return;
      if (xM < minX) minX = xM;
      if (xM > maxX) maxX = xM;
      if (yM < minY) minY = yM;
      if (yM > maxY) maxY = yM;
    };
    (feats||[]).forEach(f=>{
      if (!f) return;
      if (Array.isArray(f.points) && f.points.length){
        f.points.forEach(p=>bump(p.xM, p.yM));
      }
      if (Array.isArray(f.holes) && f.holes.length){
        f.holes.forEach(poly=>Array.isArray(poly) && poly.forEach(p=>bump(p.xM, p.yM)));
      }
      if (typeof f.xM==='number' && typeof f.yM==='number') bump(f.xM, f.yM);
      if (typeof f.txM==='number' && typeof f.tyM==='number') bump(f.txM, f.tyM);
    });
    if (!isFinite(minX)) return null;
    return {minX, minY, maxX, maxY, cx:(minX+maxX)/2, cy:(minY+maxY)/2};
  }

  function _applyPointTransformToFeature(feat, fnPt){
    if (!feat || typeof fnPt!=='function') return;
    if (Array.isArray(feat.points)) {
      feat.points = feat.points.map(p=>{
        const q = fnPt(p.xM, p.yM);
        return {xM:q.xM, yM:q.yM};
      });
    }
    if (Array.isArray(feat.holes)) {
      feat.holes = feat.holes.map(poly=>{
        if (!Array.isArray(poly)) return poly;
        return poly.map(p=>{
          const q = fnPt(p.xM, p.yM);
          return {xM:q.xM, yM:q.yM};
        });
      });
    }
    if (typeof feat.xM==='number' && typeof feat.yM==='number') {
      const q = fnPt(feat.xM, feat.yM); feat.xM=q.xM; feat.yM=q.yM;
    }
    if (typeof feat.txM==='number' && typeof feat.tyM==='number') {
      const q = fnPt(feat.txM, feat.tyM); feat.txM=q.xM; feat.tyM=q.yM;
    }
  }

  function _lineLineIntersection(a1, a2, b1, b2){
    const x1=a1.x, y1=a1.y, x2=a2.x, y2=a2.y, x3=b1.x, y3=b1.y, x4=b2.x, y4=b2.y;
    const den = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4);
    if (Math.abs(den) < 1e-9) return null;
    const px = ((x1*y2 - y1*x2)*(x3-x4) - (x1-x2)*(x3*y4 - y3*x4)) / den;
    const py = ((x1*y2 - y1*x2)*(y3-y4) - (y1-y2)*(x3*y4 - y3*x4)) / den;
    return {x:px, y:py};
  }

  function _offsetPolyline(points, distM){
    if (!Array.isArray(points) || points.length < 2) return null;

    // Remove adjacent duplicates (stability)
    const pts = [];
    for (let i=0;i<points.length;i++){
      const p=points[i];
      if (!p || !isFinite(p.xM) || !isFinite(p.yM)) continue;
      const last = pts[pts.length-1];
      if (last && Math.abs(last.xM-p.xM)<1e-9 && Math.abs(last.yM-p.yM)<1e-9) continue;
      pts.push({xM:p.xM, yM:p.yM});
    }
    if (pts.length < 2) return null;

    const seg = [];
    for (let i=0;i<pts.length-1;i++){
      const p0=pts[i], p1=pts[i+1];
      const dx=p1.xM-p0.xM, dy=p1.yM-p0.yM;
      const L=Math.hypot(dx,dy);
      if (L < 1e-9) { seg.push(null); continue; }
      const ux=dx/L, uy=dy/L;
      const nx=-uy, ny=ux; // left normal
      seg.push({p0, p1, ux, uy, nx, ny});
    }

    const out = [];
    // start cap
    {
      const s0 = seg.find(s=>s);
      if (!s0) return null;
      out.push({xM: pts[0].xM + s0.nx*distM, yM: pts[0].yM + s0.ny*distM});
    }

    for (let i=1;i<pts.length-1;i++){
      const sA = seg[i-1];
      const sB = seg[i];
      if (!sA && !sB) { out.push({xM:pts[i].xM, yM:pts[i].yM}); continue; }
      if (!sA) { out.push({xM: pts[i].xM + sB.nx*distM, yM: pts[i].yM + sB.ny*distM}); continue; }
      if (!sB) { out.push({xM: pts[i].xM + sA.nx*distM, yM: pts[i].yM + sA.ny*distM}); continue; }

      // Offset lines for segments A and B
      const A0 = {x: sA.p0.xM + sA.nx*distM, y: sA.p0.yM + sA.ny*distM};
      const A1 = {x: sA.p1.xM + sA.nx*distM, y: sA.p1.yM + sA.ny*distM};
      const B0 = {x: sB.p0.xM + sB.nx*distM, y: sB.p0.yM + sB.ny*distM};
      const B1 = {x: sB.p1.xM + sB.nx*distM, y: sB.p1.yM + sB.ny*distM};

      const I = _lineLineIntersection(A0, A1, B0, B1);
      if (I && isFinite(I.x) && isFinite(I.y)) {
        out.push({xM:I.x, yM:I.y});
      } else {
        // near-parallel: average normals
        const nx = (sA.nx + sB.nx)/2;
        const ny = (sA.ny + sB.ny)/2;
        const L = Math.hypot(nx, ny) || 1;
        out.push({xM: pts[i].xM + (nx/L)*distM, yM: pts[i].yM + (ny/L)*distM});
      }
    }

    // end cap (use last valid segment)
    {
      let sLast = null;
      for (let i=seg.length-1;i>=0;i--){ if (seg[i]) { sLast=seg[i]; break; } }
      if (!sLast) return null;
      const last = pts[pts.length-1];
      out.push({xM: last.xM + sLast.nx*distM, yM: last.yM + sLast.ny*distM});
    }
    return out;
  }

  // Duplicate Mirror
  if (topEditDuplicateMirrorBtn){
    topEditDuplicateMirrorBtn.addEventListener('click', ()=>{
      try {
        const ids = (state.multiSelectEnabled && Array.isArray(state.selectedIds) && state.selectedIds.length)
          ? state.selectedIds.slice()
          : (state.selectedId != null ? [state.selectedId] : []);

        if (!ids.length) { alert('Select something to mirror-duplicate first.'); return; }

        const feats = ids.map(id => state.features.find(x=>x.id===id)).filter(Boolean);
        if (!feats.length) { setStatusHint('Duplicate Mirror: nothing found.'); closeEditMenu(); return; }
        const locked = feats.find(f => _isFeatureLocked(f));
        if (locked) { _denyLockedEdit('duplicate mirror', locked); closeEditMenu(); return; }

        const b = _getFeaturesWorldBounds(feats);
        if (!b) { setStatusHint('Duplicate Mirror: no bounds.'); closeEditMenu(); return; }

        const axis = (prompt('Duplicate Mirror axis: X (left-right) or Y (up-down)?', 'X') || 'X').trim().toUpperCase();
        if (axis !== 'X' && axis !== 'Y') { setStatusHint('Duplicate Mirror cancelled.'); closeEditMenu(); return; }

        pushHistory('duplicateMirror');

        // Nudge mirrored duplicates slightly so perfectly symmetric cases don’t land exactly on top.
        const nudgeM = Math.max(0.02, 0.15 * (state.metersPerGrid || 1));

        const newIds = [];
        for (const f of feats){
          const clone = deepClone(f);
          clone.id = state.nextId++;
          // Duplicates should not inherit grouping (prevents "haunted" group behavior)
          if (clone.groupId != null) clone.groupId = null;
          if (clone.groupAuthorityId != null) clone.groupAuthorityId = null;
          _applyPointTransformToFeature(clone, (xM,yM)=>{
            let xx = xM, yy = yM;
            if (axis === 'X') { xx = (2*b.cx - xM); }
            else { yy = (2*b.cy - yM); }
            return {xM: xx + nudgeM, yM: yy + nudgeM};
          });
          if (clone.type === 'area') {
            try { clone.areaM2 = areaWithHoles(clone); } catch(e) { console.warn('Duplicate Mirror: area calc failed for clone', clone && clone.id, e); }
          }
          state.features.push(clone);
          newIds.push(clone.id);
        }

        if (newIds.length) {
          state.selectedIds = newIds.slice();
          state.selectedId = newIds[newIds.length-1];
          state.multiSelectEnabled = true;
          try{ syncTopbarEditUI(); } catch(e) { console.warn('Duplicate Mirror failed', e); }
          draw();
          setStatusHint(`Duplicate Mirror: ${newIds.length} created.`);
        }
      } catch(e) { console.warn('Duplicate Mirror handler failed', e); }
      closeEditMenu();
    });
  }

  // Array Repeat
  if (topEditArrayRepeatBtn){
    topEditArrayRepeatBtn.addEventListener('click', ()=>{
      try {
        const ids = (state.multiSelectEnabled && Array.isArray(state.selectedIds) && state.selectedIds.length)
          ? state.selectedIds.slice()
          : (state.selectedId != null ? [state.selectedId] : []);

        if (!ids.length) { alert('Select something to array-repeat first.'); return; }

        const feats = ids.map(id => state.features.find(x=>x.id===id)).filter(Boolean);
        if (!feats.length) { setStatusHint('Array Repeat: nothing found.'); closeEditMenu(); return; }
        const locked = feats.find(f => _isFeatureLocked(f));
        if (locked) { _denyLockedEdit('array repeat', locked); closeEditMenu(); return; }

        const count = Math.max(1, parseInt(prompt('Array Repeat: how many copies?', '3') || '0', 10) || 0);
        if (count < 1) { setStatusHint('Array Repeat cancelled.'); closeEditMenu(); return; }

        const step = state.metersPerGrid || 1;
        const dx = parseFloat(prompt('Array Repeat: step X (meters)', String(step)) || '0');
        const dy = parseFloat(prompt('Array Repeat: step Y (meters)', '0') || '0');

        if (!isFinite(dx) || !isFinite(dy) || (Math.abs(dx)<1e-12 && Math.abs(dy)<1e-12)) {
          setStatusHint('Array Repeat cancelled (zero step).');
          closeEditMenu(); return;
        }

        pushHistory('arrayRepeat');

        const newIds = [];
        for (let i=1;i<=count;i++){
          for (const f of feats){
            const clone = deepClone(f);
            clone.id = state.nextId++;
            // Duplicates should not inherit grouping (prevents "haunted" group behavior)
            if (clone.groupId != null) clone.groupId = null;
            if (clone.groupAuthorityId != null) clone.groupAuthorityId = null;
            const offX = dx*i, offY = dy*i;

            _applyPointTransformToFeature(clone, (xM,yM)=>({xM:xM+offX, yM:yM+offY}));

            if (clone.type === 'area') {
              try { clone.areaM2 = areaWithHoles(clone); } catch(e) { console.warn('Array Repeat: area calc failed for clone', clone && clone.id, e); }
            }
            state.features.push(clone);
            newIds.push(clone.id);
          }
        }

        if (newIds.length) {
          state.selectedIds = newIds.slice();
          state.selectedId = newIds[newIds.length-1];
          state.multiSelectEnabled = true;
          try{ syncTopbarEditUI(); } catch(e) { console.warn('Array Repeat failed', e); }
          draw();
          setStatusHint(`Array Repeat: ${newIds.length} created.`);
        }
      } catch(e) { console.warn('Array Repeat handler failed', e); }
      closeEditMenu();
    });
  }

  
  // Radial Array
  if (topEditRadialArrayBtn){
    topEditRadialArrayBtn.addEventListener('click', ()=>{
      try {
        const ids = (state.multiSelectEnabled && Array.isArray(state.selectedIds) && state.selectedIds.length)
          ? state.selectedIds.slice()
          : (state.selectedId != null ? [state.selectedId] : []);

        if (!ids.length) { alert('Select something to radial-array first.'); closeEditMenu(); return; }

        const featsLive = ids.map(id => state.features.find(x=>x.id===id)).filter(Boolean);
        if (!featsLive.length) { setStatusHint('Radial Array: nothing found.'); closeEditMenu(); return; }

        const locked = featsLive.find(f => _isFeatureLocked(f));
        if (locked) { _denyLockedEdit('radial array', locked); closeEditMenu(); return; }

        const count = Math.max(1, parseInt(prompt('Radial Array: how many copies?', '6') || '0', 10) || 0);
        if (count < 1) { setStatusHint('Radial Array cancelled.'); closeEditMenu(); return; }

        const modeRaw = (prompt('Radial Array: angle mode\nType a step angle in degrees (e.g., 30)\n—or type FULL for 360°/copies', 'FULL') || '').trim();
        let stepDeg;
        if (!modeRaw || /^full$/i.test(modeRaw)) {
          stepDeg = 360 / count;
        } else {
          stepDeg = parseFloat(modeRaw);
        }
        if (!Number.isFinite(stepDeg) || Math.abs(stepDeg) < 1e-9) {
          setStatusHint('Radial Array cancelled (invalid/zero angle).');
          closeEditMenu(); return;
        }

        // Capture a stable base set (so pivot-pick doesn't depend on later selection mutations)
        const featsBase = featsLive.map(f => deepClone(f));

        const runRadialArray = (pivot)=>{
          if (!pivot || !Number.isFinite(pivot.xM) || !Number.isFinite(pivot.yM)) {
            setStatusHint('Radial Array cancelled (bad pivot).');
            return;
          }

          pushHistory('radialArray');

          const newIds = [];
          for (let i=1; i<=count; i++){
            const deltaDeg = stepDeg * i;
            const rad = (deltaDeg * Math.PI) / 180;

            for (const f of featsBase){
              const clone = deepClone(f);
              clone.id = state.nextId++;

              // Duplicates should not inherit grouping (prevents "haunted" group behavior)
              if (clone.groupId != null) clone.groupId = null;
              if (clone.groupAuthorityId != null) clone.groupAuthorityId = null;

              // Anchored objects (symbols/labels/etc.)
              if (typeof clone.xM === 'number' && typeof clone.yM === 'number') {
                const rP = _rotatePointAbout({ xM: clone.xM, yM: clone.yM }, pivot, rad);
                clone.xM = rP.xM;
                clone.yM = rP.yM;
              }
              if (typeof clone.txM === 'number' && typeof clone.tyM === 'number') {
                const rT = _rotatePointAbout({ xM: clone.txM, yM: clone.tyM }, pivot, rad);
                clone.txM = rT.xM;
                clone.tyM = rT.yM;
              }

              // If feature carries an orientation angle, rotate it too
              if (typeof clone.angleDeg === 'number') {
                clone.angleDeg = (clone.angleDeg + deltaDeg);
              }

              // Rotate poly geometry
              if (Array.isArray(clone.points) && clone.points.length) {
                clone.points = _rotatePointsArray(clone.points, pivot, rad);
              }
              if (Array.isArray(clone.holes) && clone.holes.length) {
                clone.holes = clone.holes.map(h => (Array.isArray(h) ? _rotatePointsArray(h, pivot, rad) : h));
              }

              // Rotate circle meta center if present
              if (clone.shapeMeta && clone.shapeMeta.kind === 'circle'
                  && Number.isFinite(clone.shapeMeta.cxM) && Number.isFinite(clone.shapeMeta.cyM)) {
                const rC = _rotatePointAbout({ xM: clone.shapeMeta.cxM, yM: clone.shapeMeta.cyM }, pivot, rad);
                clone.shapeMeta.cxM = rC.xM;
                clone.shapeMeta.cyM = rC.yM;
              }

              // Recompute area
              if (clone.type === 'area') {
                try { clone.areaM2 = areaWithHoles(clone); } catch(_) { /* ignore */ }
              }

              state.features.push(clone);
              newIds.push(clone.id);
            }
          }

          // Select newly created copies
          if (newIds.length === 1) {
            _setSelectionSingle(newIds[0]);
          } else if (newIds.length > 1) {
            _setSelectionMulti(newIds, newIds[newIds.length-1]);
            state.multiSelectEnabled = true;
            if (typeof syncTopbarEditUI === 'function') syncTopbarEditUI();
          }

          draw();
          setStatusHint(newIds.length ? `Radial Array: created ${newIds.length} copy(s).` : 'Radial Array: no copies created.');
        };

        const pickPivot = confirm('Radial Array pivot\n\nOK = pick pivot point on canvas\nCancel = use selection center');
        if (pickPivot) {
          // One-shot pivot pick (snapped if snapping is enabled)
          setStatusHint('Radial Array: tap pivot point…');
          closeEditMenu();

          const onPick = (e)=>{
            try {
              e.preventDefault();
              e.stopPropagation();
              const rect = canvas.getBoundingClientRect();
              const xPx = e.clientX - rect.left;
              const yPx = e.clientY - rect.top;
              const pivot = canvasToWorld(xPx, yPx);
              runRadialArray(pivot);
            } catch(err) {
              console.warn('Radial Array pivot-pick failed', err);
              setStatusHint('Radial Array failed (see console).');
            }
          };

          canvas.addEventListener('pointerdown', onPick, { capture: true, once: true });
          return; // do not fall through
        }

        // Default pivot: selection bounds center
        const b = _getFeaturesWorldBounds(featsLive);
        if (!b || !Number.isFinite(b.cx) || !Number.isFinite(b.cy)) {
          setStatusHint('Radial Array: cannot compute pivot.');
          closeEditMenu(); return;
        }
        runRadialArray({ xM: b.cx, yM: b.cy });
      } catch(e) {
        console.warn('Radial Array handler failed', e);
        setStatusHint('Radial Array failed (see console).');
      }
      closeEditMenu();
    });;
  }

// Offset Parallel (duplicates selected line/polyline with parallel offset)
  if (topEditOffsetParallelBtn){
    topEditOffsetParallelBtn.addEventListener('click', ()=>{
      try {
        const ids = (state.multiSelectEnabled && Array.isArray(state.selectedIds) && state.selectedIds.length)
          ? state.selectedIds.slice()
          : (state.selectedId != null ? [state.selectedId] : []);

        if (ids.length !== 1) { alert('Offset Parallel: select exactly ONE line/polyline feature first.'); return; }

        const f0 = state.features.find(x=>x.id===ids[0]);
        if (!f0) { setStatusHint('Offset Parallel: feature not found.'); closeEditMenu(); return; }
        if (_isFeatureLocked(f0)) { _denyLockedEdit('offset parallel', f0); closeEditMenu(); return; }

        if (!Array.isArray(f0.points) || f0.points.length < 2) {
          alert('Offset Parallel currently supports line/polyline features with points.');
          closeEditMenu(); return;
        }
        if (f0.type === 'area') {
          alert('Offset Parallel: areas are not supported (select a line/polyline).');
          closeEditMenu(); return;
        }

        const step = state.metersPerGrid || 1;
        const distAbs = parseFloat(prompt('Offset Parallel distance (meters)', String(step)) || '0');
        if (!isFinite(distAbs) || Math.abs(distAbs) < 1e-12) { setStatusHint('Offset Parallel cancelled.'); closeEditMenu(); return; }

        const side = (prompt('Offset Parallel side: L (left) or R (right) relative to drawing direction?', 'L') || 'L').trim().toUpperCase();
        const dist = (side === 'R') ? -Math.abs(distAbs) : Math.abs(distAbs);

        const pts2 = _offsetPolyline(f0.points, dist);
        if (!pts2 || pts2.length < 2) { setStatusHint('Offset Parallel failed.'); closeEditMenu(); return; }

        pushHistory('offsetParallel');

        const clone = deepClone(f0);
        clone.id = state.nextId++;
        // Offset duplicate should not inherit grouping
        if (clone.groupId != null) clone.groupId = null;
        if (clone.groupAuthorityId != null) clone.groupAuthorityId = null;
        clone.points = pts2;

        // nudge/clear any per-vertex selection artifacts
        if (clone.type === 'road' || clone.type === 'lane') {
          // keep type
        }
        state.features.push(clone);

        // Select new feature
        state.selectedIds = [clone.id];
        state.selectedId = clone.id;
        state.multiSelectEnabled = false;
        try{ syncTopbarEditUI(); } catch(e) { console.warn('Offset Parallel failed', e); }
          draw();
        setStatusHint('Offset Parallel: created 1 offset copy.');
      } catch(e) { console.warn('Offset Parallel handler failed', e); }
      closeEditMenu();
    });
  }
  // SUB-CHUNK 16.DUPX END — Duplicate Mirror / Array Repeat / Offset Parallel (v1)

if (topEditCutoutBtn){
    topEditCutoutBtn.addEventListener('click', ()=>{
      try {
        if (state.editMode === 'cutout') {
          setEditMode('none');
          return;
        }
        if (!state.selectedId) {
          alert('Select an outer area first.');
          return;
        }
        const outer = state.features.find(f=>f.id===state.selectedId && f.type==='area');
        if (!outer) {
          alert('Select an area region first.');
          return;
        }
        cutoutOuterId = outer.id;
        setEditMode('cutout');
      } catch(e) { console.warn('Cutout handler failed', e); }
      closeEditMenu();
    });
  }
  
  // Topbar Edit UI sync (truth layer)
  // - Highlights Edit ▾ when any edit mode is armed or Bend tool is active
  // - Highlights the active item inside the Edit menu
  const syncTopbarEditUI = ()=>{
    try{
      // --- MODE HIGHLIGHTS (truth layer) ---------------------------------------
      // Draw button (topbar Draw ▾ summary)
      const drawSummary = document.getElementById('stackXBtn4'); // Draw ▾ summary
      const inspectBtn  = document.getElementById('stackYBtn4'); // Inspect / Nav button

      const tool = (state && state.tool) ? state.tool : '';
      const editMode = (state && state.editMode) ? state.editMode : 'none';

      const isEditArmed = (tool === 'bend' || (editMode && editMode !== 'none'));
      // Draw tools are geometry creation / capture modes (truth layer)
      // NOTE: Line Tool uses 'road'/'lane' (see setTool()), and free draw uses 'freeDraw'.
      const isDrawArmed = DRAW_FAMILY_TOOLS.has(tool);
const isInspectArmed = (tool === 'inspect' && (!editMode || editMode === 'none'));

      // Edit summary button element is the <summary> inside #editMenu
      const editSummary = editMenu ? editMenu.querySelector('summary') : null;
      // Multi-select button truth (Edit menu item)
      try{ if (topEditMultiSelectBtn) topEditMultiSelectBtn.classList.toggle('active', !!state.multiSelectEnabled); }catch(_){ }

      if (drawSummary){
        drawSummary.classList.toggle('active', !!isDrawArmed);
        drawSummary.setAttribute('aria-pressed', isDrawArmed ? 'true' : 'false');
      }

      
      // --- DRAW MENU ITEM HIGHLIGHTS (truth layer) -----------------------------
      // Highlights active draw tool inside Draw dropdown, including nested category (Shapes).
      try{
        if (drawToolMenu){
          const mainPanel = document.getElementById('drawMainPanel');
          const submenuPanel = document.getElementById('drawSubmenuPanel');

          const clearActive = (root)=>{
            try{
              if (!root) return;
              root.querySelectorAll('[data-draw-tool],[data-open-submenu]').forEach(el=>{
                el.classList.remove('active');
                try{ el.setAttribute('aria-pressed','false'); }catch(_){}
              });
            }catch(_){}
          };

          clearActive(mainPanel);
          clearActive(submenuPanel);

          const ttool = (state && state.tool) ? state.tool : '';

          // Map internal line tool variants to the Draw menu's "Line" row.
          const lineLike = (ttool === 'road' || ttool === 'lane' || ttool === 'line');

          // Shapes category tools
          const shapeTools = new Set(['rect','circle','rectLine','circleLine']);

          if (shapeTools.has(ttool)){
            const shapesOpener = drawToolMenu.querySelector('[data-open-submenu="shapes"]');
            if (shapesOpener){
              shapesOpener.classList.add('active');
              shapesOpener.setAttribute('aria-pressed','true');
            }
            const shapeBtn = drawToolMenu.querySelector('[data-submenu="shapes"] [data-draw-tool="'+ttool+'"]');
            if (shapeBtn){
              shapeBtn.classList.add('active');
              shapeBtn.setAttribute('aria-pressed','true');
            }
          } else if (lineLike){
            const lineBtn = drawToolMenu.querySelector('[data-draw-tool="line"]');
            if (lineBtn){
              lineBtn.classList.add('active');
              lineBtn.setAttribute('aria-pressed','true');
            }
          } else if (ttool){
            const btn = drawToolMenu.querySelector('[data-draw-tool="'+ttool+'"]');
            if (btn){
              btn.classList.add('active');
              btn.setAttribute('aria-pressed','true');
            }
          }
        }
      }catch(_){}
if (inspectBtn){
        inspectBtn.classList.toggle('active', !!isInspectArmed);
        inspectBtn.setAttribute('aria-pressed', isInspectArmed ? 'true' : 'false');
      }

      if (editSummary){
        editSummary.classList.toggle('active', !!isEditArmed);
        editSummary.setAttribute('aria-pressed', isEditArmed ? 'true' : 'false');
      }

      // --- MENU ITEM HIGHLIGHTS ------------------------------------------------
      const clearActive = (btn)=>{ if(btn) btn.classList.remove('active'); };
      [topEditBendBtn, topEditRotateBtn, topEditMoveShapeBtn, topEditMovePointBtn, topEditAddVertexBtn,
       topEditRemoveVertexBtn, topEditSplitLineBtn, topEditDuplicateBtn, topEditCutoutBtn].forEach(clearActive);

      if (tool === 'bend' && topEditBendBtn) topEditBendBtn.classList.add('active');

      if (tool !== 'bend'){
        if (editMode === 'moveShape' && topEditMoveShapeBtn) topEditMoveShapeBtn.classList.add('active');
        if (editMode === 'rotate' && topEditRotateBtn) topEditRotateBtn.classList.add('active');
        if (editMode === 'movePoint' && topEditMovePointBtn) topEditMovePointBtn.classList.add('active');
        if (editMode === 'addVertex' && topEditAddVertexBtn) topEditAddVertexBtn.classList.add('active');
        if (editMode === 'removeVertex' && topEditRemoveVertexBtn) topEditRemoveVertexBtn.classList.add('active');
        if (editMode === 'splitLine' && topEditSplitLineBtn) topEditSplitLineBtn.classList.add('active');

        if (editMode === 'cutout' && topEditCutoutBtn) topEditCutoutBtn.classList.add('active');
      }
    }catch(_){}
  
      // --- GROUP OBJECTS SUBMENU HIGHLIGHTS --------------------------------------
      try{
        const gOpener = document.getElementById('topEditGroupObjectsOpener');
        const gCreate = document.getElementById('topGroupCreateBtn');
        const gAdd    = document.getElementById('topGroupAddBtn');
        const gRem    = document.getElementById('topGroupRemoveBtn');
        const gComb   = document.getElementById('topGroupCombineBtn');
        const gDis    = document.getElementById('topGroupDisbandBtn');
        [gOpener,gCreate,gAdd,gRem,gComb,gDis].forEach(b=>{ if(b) b.classList.remove('active'); });
        if(state.tool==='inspect' && (state.editMode==='groupAdd' || state.editMode==='groupRemove' || state.editMode==='groupCombine')){
          if(gOpener) gOpener.classList.add('active');
          if(state.editMode==='groupAdd' && gAdd) gAdd.classList.add('active');
          if(state.editMode==='groupRemove' && gRem) gRem.classList.add('active');
          if(state.editMode==='groupCombine' && gComb) gComb.classList.add('active');
        }
        // Disband button highlight if current selection has active authority overlay
        const sel = state.features.find(x=>x.id===state.selectedId);
        const eff = getEffectiveGroupId(sel);
        const anyOverlay = eff && state.features.some(ff=>ff && getAuthorityGroupId(ff)===eff);
        if(anyOverlay && gDis) gDis.classList.add('active');
      }catch(_){}

};

  // --- END Topbar EDIT dropdown -------------------------------------------------

  // Button 7: Duplicate (direct; no sidebar dependency)
  if (stackYBtn3) {
    stackYBtn3.addEventListener('click', ()=>{
      try {
        if (!state.selectedId) { alert('Select something to duplicate first.'); return; }
        const f = state.features.find(x=>x.id===state.selectedId);
        if (!f) return;
        pushHistory('duplicate');
        const offset = state.metersPerGrid || 1;
        const clone = deepClone(f);
        clone.id = state.nextId++;
        if (Array.isArray(clone.points)) {
          clone.points = clone.points.map(p=>({xM:p.xM+offset,yM:p.yM+offset}));
        }
        if (Array.isArray(clone.holes)) {
          clone.holes = clone.holes.map(poly=>poly.map(p=>({xM:p.xM+offset, yM:p.yM+offset})));
        }
        if (typeof clone.xM==='number') clone.xM += offset;
        if (typeof clone.yM==='number') clone.yM += offset;
        if (typeof clone.txM==='number') clone.txM += offset;
        if (typeof clone.tyM==='number') clone.tyM += offset;
        if (clone.type==='area') clone.areaM2 = areaWithHoles(clone);
        state.features.push(clone);
        selectFeatureById(clone.id);
      } catch(_) {}
    });
  }

  // --- RESERVED PLACEHOLDER BUTTONS (Button 1–5) --------------------------------
  // These topbar slots are intentionally DISABLED placeholders to keep layout stable.
  // Edit actions moved to the Edit ▾ dropdown (truthful home). Placeholders remain for future upgrades.
  //
  // Button 1: stackXBtn2  (reserved)
  // Button 2: stackXBtn3  (reserved)
  // Button 3: stackXBtn4Alt (reserved)
  // Button 4: stackYBtn1  (reserved)
  // Button 5: stackYBtn2  (reserved)
  //
  // Contract: Do not bind actions to these placeholders until they are deliberately re-activated.
  // --- END RESERVED PLACEHOLDER BUTTONS -----------------------------------------

  // ✅ Lock to grid axes (UI sync + truthful label)
  if (lockAxisBtn){
    const axisLockStateSpan = document.getElementById('axisLockState') || lockAxisBtn.querySelector('.mono');
    const syncAxisLockUI = ()=>{
      lockAxisBtn.classList.toggle('active', !!state.axisLock);
      lockAxisBtn.setAttribute('aria-pressed', state.axisLock ? 'true' : 'false');
      if (axisLockStateSpan) axisLockStateSpan.textContent = state.axisLock ? 'ON' : 'OFF';
    };
    syncAxisLockUI();

    lockAxisBtn.addEventListener('click', ()=>{
      state.axisLock = !state.axisLock;
      syncAxisLockUI();
      try{ updateContextHighlights(); }catch(_){ }

      // Update helper text when it's relevant (draw tools or Move Shape)
      const axisMsgRelevant = (state.tool === 'road' || state.tool === 'lane' || state.tool === 'area' || state.editMode === 'moveShape');
      if (axisMsgRelevant){
        if (state.editMode === 'moveShape'){
          setStatusHint(state.axisLock
            ? 'Axis Lock: ON · Move constrains to X/Y (unless Snap Angle).'
            : 'Axis Lock: OFF · Move free (Snap Angle still applies when enabled).');
        } else {
          setStatusHint(state.axisLock
            ? 'Axis Lock: ON · Segments lock horizontal/vertical (unless Snap Angle).'
            : 'Axis Lock: OFF · Free angles (Snap Angle still applies when enabled).');
        }
      }

      draw();
    });
  }

  
  // SUB-CHUNK 16.B2 BEGIN — Auto/Finish button binding (Bend manual-commit hook)
if (autoCommitBtn){
    autoCommitBtn.addEventListener('click', ()=>{
      // Unified behavior (Finish ↔ Auto):
      // 1) If Bend has a pending preview (manual mode), this button acts as FINISH for Bend.
      // 2) Else, if a path is currently finishable, the button acts as FINISH (commit).
      // 3) Else, it toggles Auto mode (Axis-Lock style).

            // (0) Rotate manual-finish hook (Phase 2: typed rotate pending)
      try {
        if (state && state.editMode === 'rotate' && rotateSession && rotateSession.pending && typeof commitRotateSession === 'function') {
          const ok = commitRotateSession('autoCommitBtn');
          if (ok) {
            if (typeof updateToolspace === 'function') updateToolspace();
            setModeLabel();
            return;
          }
        }
      } catch(_) { /* keep going */ }

// (0) Rotate APPLY (one-shot typed rotate without dragging)
      try {
        if (state && state.tool === 'inspect' && state.editMode === 'rotate') {
          const sel = _getSelectedFeature && _getSelectedFeature();
          const stepDeg = getRotateStepDeg ? getRotateStepDeg() : (parseFloat(angleSnapDegInput && angleSnapDegInput.value) || 0);
          if (sel && stepDeg > 0) {
            // Ensure session exists and pivot is defined (tap pivot or default center)
            if (!rotateSession || rotateSession.featureId !== sel.id) {
              try { beginRotateSession(); } catch(_){}
            }
            const sign = (rotateSession && rotateSession.lastSign) ? rotateSession.lastSign : 1;
            const deltaDeg = sign * stepDeg;

            // Preview then commit immediately as a discrete command
            try { applyRotatePreview(deltaDeg); } catch(_){}
            try { commitRotateSession('apply'); } catch(_){}

            if (typeof updateToolspace === 'function') updateToolspace();
            setModeLabel();
            return;
          }
          // If no selection or step is 0, do nothing (truth: APPLY has no effect).
        }
      } catch(_) { /* keep going */ }

// (1) Bend manual-finish hook
      try {
        if (state && state.tool === 'bend' && state.bend && state.bend.pending && typeof commitBendSession === 'function') {
          const ok = commitBendSession('autoCommitBtn');
          if (ok) {
            if (typeof updateToolspace === 'function') updateToolspace();
            setModeLabel();
            return;
          }
        }
      } catch (e) {}

      // (2) Finish current drawing path (existing)
      if (typeof canCommitCurrentPath === 'function' && canCommitCurrentPath()) {
        commitCurrentPath('autoCommitBtn');
        // commitCurrentPath() calls draw(); we still refresh the toolspace label deterministically.
        if (typeof updateToolspace === 'function') updateToolspace();
        // statusMode is independent of commit; keep mode labels consistent anyway.
        setModeLabel();
        return;
      }

      // (3) Toggle Auto mode
      state.autoCommitLine = !state.autoCommitLine;

      // Visual state reflects the Auto mode flag (Axis-Lock style).
      autoCommitBtn.classList.toggle('active', !!state.autoCommitLine);

      // Refresh labels (shown as FINISH vs ON/OFF depending on currentPath validity).
      if (typeof updateToolspace === 'function') updateToolspace();
      setModeLabel();
    });
  }
  // SUB-CHUNK 16.B2 END — Auto/Finish button binding

  // --- end sub-chunk 16.1b -----------------------------------------------------------

  // SUB-CHUNK 16.D1 END — Tool selection dispatch wiring (Line/Draw/Sidebar)
// GPT_SAFE_ZONE END: TOOL_SELECTION_DISPATCH (SUB-CHUNK 16.D1)

  // GPT_SAFE_ZONE BEGIN: EDIT_MODE_WIRING (SUB-CHUNK 16.E1) — edit only if explicitly authorized
// SUB-CHUNK 16.E1 BEGIN — Edit mode button wiring (Move/Add/Remove/Duplicate/Cut)
  // SUB-CHUNK 16.1d BEGIN — Edit bindings (sidebar optional, incremental removal)
  // MP-01 PREP: Sidebar Edit button may be removed later. Missing element must never crash bindings.
  if (editMovePointBtn) editMovePointBtn.addEventListener('click',()=>{
    if (state.tool!=='inspect') setTool('inspect');
    setEditMode(state.editMode==='movePoint'?'none':'movePoint');
  });
  // SUB-CHUNK 16.1d END — Edit bindings (Move Point optional)

  // SUB-CHUNK 16.1e BEGIN — Edit bindings (Move Shape optional)
  // MS-01 PREP: Sidebar Edit button may be removed later. Missing element must never crash bindings.
  if (editMoveShapeBtn) editMoveShapeBtn.addEventListener('click',()=>{
    if (state.tool!=='inspect') setTool('inspect');
    setEditMode(state.editMode==='moveShape'?'none':'moveShape');
  });
  // SUB-CHUNK 16.1e END — Edit bindings (Move Shape optional)

  // SUB-CHUNK 16.1f BEGIN — Edit bindings (Add Vertex optional)
  // AV-01 PREP: Sidebar Edit button may be removed later. Missing element must never crash bindings.
  if (editAddVertexBtn) editAddVertexBtn.addEventListener('click',()=>{
    if (state.tool!=='inspect') setTool('inspect');
    setEditMode(state.editMode==='addVertex'?'none':'addVertex');
  });
  // SUB-CHUNK 16.1f END — Edit bindings (Add Vertex optional)

  // SUB-CHUNK 16.1g BEGIN — Edit bindings (Remove Vertex optional)
  // RV-01 PREP: Sidebar Edit button may be removed later. Missing element must never crash bindings.
  if (editRemoveVertexBtn) editRemoveVertexBtn.addEventListener('click',()=>{
    if (state.tool!=='inspect') setTool('inspect');
    setEditMode(state.editMode==='removeVertex'?'none':'removeVertex');
  });
  // SUB-CHUNK 16.1g END — Edit bindings (Remove Vertex optional)

  // SUB-CHUNK 16.1h BEGIN — Edit bindings (Duplicate optional)
  // DU-01 PREP: Sidebar Edit button may be removed later. Missing element must never crash bindings.
  if (editDuplicateBtn) editDuplicateBtn.addEventListener('click',()=>{
    if (!state.selectedId) { alert('Select something to duplicate first.'); return; }
    const f = state.features.find(x=>x.id===state.selectedId);
    if (!f) return;
    pushHistory('duplicate');
    const offset = state.metersPerGrid || 1;
    const clone = deepClone(f);
    clone.id = state.nextId++;
    if (Array.isArray(clone.points)) {
      clone.points = clone.points.map(p=>({xM:p.xM+offset,yM:p.yM+offset}));
    }
    if (Array.isArray(clone.holes)) {
      clone.holes = clone.holes.map(poly=>poly.map(p=>({xM:p.xM+offset, yM:p.yM+offset})));
    }
    if (typeof clone.xM==='number') clone.xM += offset;
    if (typeof clone.yM==='number') clone.yM += offset;
    if (typeof clone.txM==='number') clone.txM += offset;
    if (typeof clone.tyM==='number') clone.tyM += offset;
    if (clone.type==='area') clone.areaM2 = areaWithHoles(clone);
    state.features.push(clone);
    selectFeatureById(clone.id);
  });
  // SUB-CHUNK 16.1h END — Edit bindings (Duplicate optional)

  // SUB-CHUNK 16.1i BEGIN — Edit bindings (Cut-out optional)
  // CO-01 PREP: Sidebar Edit button may be removed later. Missing element must never crash bindings.
  if (editCutoutBtn) editCutoutBtn.addEventListener('click',()=>{
    if (state.editMode === 'cutout') {
      setEditMode('none');
      return;
    }
    if (!state.selectedId) {
      alert('Select an outer area first.');
      return;
    }
    const outer = state.features.find(f=>f.id===state.selectedId && f.type==='area');
    if (!outer) {
      alert('Select an area region first.');
      return;
    }
    if (state.tool!=='inspect') setTool('inspect');
    cutoutOuterId = outer.id;
    setEditMode('cutout');
  });
  // SUB-CHUNK 16.1i END — Edit bindings (Cut-out optional)
  // SUB-CHUNK 16.E1 END — Edit mode button wiring (Move/Add/Remove/Duplicate/Cut)
// GPT_SAFE_ZONE END: EDIT_MODE_WIRING (SUB-CHUNK 16.E1)

  // GPT_SAFE_ZONE BEGIN: STATUSBAR_AND_GLOBAL_ESC_HANDLERS (SUB-CHUNK 16.S1) — edit only if explicitly authorized
// SUB-CHUNK 16.S1 BEGIN — Bottom status bar interactions (Snap / Units)
// --- chunk 16.2 · Bottom status bar interactions (Snap / Snap / Units) ---------
  // (unchanged below)
  // Units-mode normalization helper is defined later (unitsFamily-aware).

  // Snap ON/OFF
  if (statusSnap) {
    statusSnap.style.cursor = 'pointer';
    statusSnap.title = 'Tap to toggle snap ON/OFF';
    statusSnap.addEventListener('click', ()=>{
      state.snapEnabled = !state.snapEnabled;
      updateStatusSnap();
      draw();
    });
  }

  // Snap ON/OFF (context toggle button)
  const snapToggleBtn = document.getElementById('snapToggleBtn');
  if (snapToggleBtn) {
    snapToggleBtn.style.cursor = 'pointer';
    snapToggleBtn.title = 'Toggle snap ON/OFF';
    snapToggleBtn.addEventListener('click', ()=>{
      state.snapEnabled = !state.snapEnabled;
      updateStatusSnap();
      draw();
    });
  }

  // Snap dropdown (Column 2)
// Snap modes: Point | Angle | Grid
const snapModeMenu = document.getElementById('snapModeMenu');
if (snapModeMenu) {
  snapModeMenu.addEventListener('click', (e)=>{
    const t = e.target && e.target.closest ? e.target.closest('[data-snap-mode]') : null;
    if (!t) return;
    const mode = String(t.getAttribute('data-snap-mode') || '').toLowerCase();
    if (mode !== 'point' && mode !== 'angle' && mode !== 'grid') return;

    state.snapMode = mode;
    updateStatusSnapMode();
    updateToolspace();
    draw();

    try { snapModeMenu.open = false; } catch(_){}
  });
}

  // Angle step degrees input — also drives Rotate quantization/typed step while in rotate mode (Phase 2).
  if (angleSnapDegInput) {
    angleSnapDegInput.addEventListener('input', ()=>{
      // Rotate uses this degrees field regardless of snap toggle.
      if (state && state.editMode === 'rotate') {
        try { handleRotateDegreesInput(); } catch(_){ }
      }
      // Note: Snap Angle uses this value on-demand during drawing; no listener required.
      try { updateStatusConstraints(); } catch(_){ }
    });
  }

  // Units (direct-select dropdown)
  // NOTE: internal storage remains meters; unitsMode only changes display + input interpretation.

// SUB-CHUNK 17.A BEGIN — Units family + grid normalization + setUnitsMode
  function unitsFamily(mode){
    const m = String(mode || 'metric').toLowerCase();
    return (m === 'imperial' || m === 'in') ? 'imperial' : 'metric';
  }

  // When toggling unit family, optionally normalize the grid/snap defaults so it "looks right"
  // without forcing custom users to lose their chosen grid spacing.
  function normalizeGridForUnitsToggle(prevMode, nextMode){
    const prevFam = unitsFamily(prevMode);
    const nextFam = unitsFamily(nextMode);

    const oneMeter = 1.0;
    const oneFootM = FT_TO_M; // 0.3048...

    const near = (a,b)=> Math.abs(a-b) < 1e-9;
    const snapTracksGrid = ()=> Math.abs((state.snapStepM ?? state.metersPerGrid) - state.metersPerGrid) < 1e-9;

    // Metric-family -> Imperial-family: if user was on default 1m grid, switch to 1ft grid
    if (prevFam === 'metric' && nextFam === 'imperial') {
      const tracking = snapTracksGrid();
      if (near(state.metersPerGrid, oneMeter)) {
        state.metersPerGrid = oneFootM;
        if (tracking) state.snapStepM = oneFootM;
      }
    }

    // Imperial-family -> Metric-family: if user is on default 1ft grid, switch back to 1m grid
    if (prevFam === 'imperial' && nextFam === 'metric') {
      const tracking = snapTracksGrid();
      if (near(state.metersPerGrid, oneFootM)) {
        state.metersPerGrid = oneMeter;
        if (tracking) state.snapStepM = oneMeter;
      }
    }
  }

  function setUnitsMode(nextMode){
    const prev = state.unitsMode;

    const m = String(nextMode || 'metric').toLowerCase();
    const allowed = ['metric','cm','mm','imperial','in'];
    state.unitsMode = allowed.includes(m) ? m : 'metric';

    normalizeGridForUnitsToggle(prev, state.unitsMode);

    updateStatusUnits();
    syncUnitSensitiveInputs();
    refreshSelectedInspector();
    updateFeatureSelect();
    updateToolspace();
    draw();
  }

  // Dropdown selection + close
  if (unitsMenu) {
    unitsMenu.addEventListener('click', (e)=>{
      const t = e.target && e.target.closest ? e.target.closest('[data-units-mode],#unitsMenuCloseBtn') : null;
      if (!t) return;

      if (t && t.id === 'unitsMenuCloseBtn') {
        try { unitsMenu.open = false; } catch(_){}
        return;
      }

      const mode = t.getAttribute && t.getAttribute('data-units-mode');
      if (mode) {
        setUnitsMode(mode);
        try { unitsMenu.open = false; } catch(_){}
      }
    });
  }

  if (unitsMenuCloseBtn) {
    unitsMenuCloseBtn.addEventListener('click', ()=>{
      try { if (unitsMenu) unitsMenu.open = false; } catch(_){}
    });
  }

  // Global dropdown closer (click outside + Esc)
// SUB-CHUNK 17.A END — Units family + grid normalization + setUnitsMode
// SUB-CHUNK 17.B BEGIN — Dropdown close helpers
  function closeOpenDropMenus(except){
    try{
      document.querySelectorAll('details.drop-menu[open]').forEach(d=>{
        if (except && d === except) return;
        try { d.open = false; } catch(_){}
      });
    }catch(_){}
  }

  document.addEventListener('pointerdown', (e)=>{
    try{
      document.querySelectorAll('details.drop-menu[open]').forEach(d=>{
        if (d.contains(e.target)) return;
        try { d.open = false; } catch(_){}
      });
    }catch(_){}
  }, true);

  document.addEventListener('keydown', (e)=>{
    if (e && e.key === 'Escape') closeOpenDropMenus();
  });

    // SUB-CHUNK 16.S1 END — Bottom status bar interactions (Snap / Units)
// GPT_SAFE_ZONE END: STATUSBAR_AND_GLOBAL_ESC_HANDLERS (SUB-CHUNK 16.S1)

// --- chunk end 16 ---------------------------------------------------------------

  // --- View / zoom / pan / scale & layers chunk 17 ------------------------------------
  // --- chunk 17.1 · Lines & areas ------------------------------------------------------
  // --- sub-chunk 17.1A · Style resolution (deterministic, schema-safe) -----------------
  // Priority:
  // 1) Type defaults (road/lane)
  // 2) lineStyle dash preset (dashed/centerline)
  // 3) Per-feature overrides (strokeWidthPx / strokeColor / strokeDash)
  //
  // Notes:
  // - No geometry changes.
  // - No auto-interpretation.
  // - Old JSON without these fields remains valid.

// SUB-CHUNK 17.B END — Dropdown close helpers
// SUB-CHUNK 17.C BEGIN — Feature style resolver
  function resolveLineStyleForFeature(f){
    const t = (f && f.type) ? String(f.type) : '';
    const isRoad    = (t === 'road');
    const isLane    = (t === 'lane');
    const isMeasure = (t === 'measure');

    // Defaults preserve today's look
    let widthPx = isRoad ? 6 : (isLane ? 2 : 1.5);
    let color   = isRoad ? '#e5e7eb' : (isLane ? '#facc15' : '#a855f7');
    let dash    = null;

    // Lane preset from lineStyle (roads are typically solid unless overridden)
    const ls = (f && f.lineStyle != null) ? String(f.lineStyle).toLowerCase() : '';
    if (isLane) {
      if (ls === 'centerline') dash = [18, 6, 3, 6];
      else if (ls === 'dashed' || ls === '') dash = [10, 8]; // default lane look
      else dash = [10, 8]; // defensive fallback
    }

    // Measure default is dashed purple unless explicitly overridden
    if (isMeasure) {
      dash = [10, 8];
    }

    // Per-feature overrides (if present & valid)
    if (f && f.strokeWidthPx != null) {
      const w = Number(f.strokeWidthPx);
      if (Number.isFinite(w) && w > 0) widthPx = w;
    }

    if (f && f.strokeColor != null) {
      const c = String(f.strokeColor);
      if (c && c.length) color = c;
    }

    // Per-feature dash override (explicit null must cancel dashes)
    if (f && Object.prototype.hasOwnProperty.call(f,'strokeDash')) {
      if (Array.isArray(f.strokeDash)) {
        const cleaned = f.strokeDash
          .map(Number)
          .filter(n => Number.isFinite(n) && n > 0);
        dash = cleaned.length ? cleaned : null;
      } else if (f.strokeDash === null) {
        dash = null;
      }
    }
return { widthPx, color, dash };
  }
  // --- end sub-chunk 17.1A ------------------------------------------------------------

// SUB-CHUNK 17.C END — Feature style resolver
// SUB-CHUNK 17.D BEGIN — Draw line/area features (active)
  function drawLineFeature(f) {
    const pts = f.points || [];
    if (pts.length < 2) return;

    const isRoad = f.type === 'road';
    const isLane = f.type === 'lane';

    if (!isRoad && !isLane) return;

    // Layer gating stays type-based (unchanged)
    if (isRoad && !state.layers.roads) return;
    if (isLane && !state.layers.lanes) return;

    const style = resolveLineStyleForFeature(f);

    ctx.save();

    ctx.strokeStyle = style.color;
    ctx.lineWidth   = style.widthPx;

    if (style.dash && style.dash.length) ctx.setLineDash(style.dash);
    else ctx.setLineDash([]);

    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    const first = worldToCanvas(pts[0]);
    ctx.beginPath();
    ctx.moveTo(first.xPx, first.yPx);
    for (let i = 1; i < pts.length; i++) {
      const p = worldToCanvas(pts[i]);
      ctx.lineTo(p.xPx, p.yPx);
    }
    ctx.stroke();

    // Always clear dash after stroke to avoid leaking into other draws
    ctx.setLineDash([]);

    // Selection outline (keep existing behavior)
    if (isSelectedId(f.id)) {
      ctx.strokeStyle = '#22c55e';
      ctx.lineWidth = isRoad ? 2 : 1.5;
      ctx.beginPath();
      ctx.moveTo(first.xPx, first.yPx);
      for (let i = 1; i < pts.length; i++) {
        const p = worldToCanvas(pts[i]);
        ctx.lineTo(p.xPx, p.yPx);
      }
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawAreaFeature(f) {
    if (!state.layers.areas) return;
    const pts = f.points || [];
    if (pts.length < 3) return;

    // Area styling: per-feature override → defaults
    // Defaults are persistent (see Area Defaults panel).
    if (!state.areaDefaults) state.areaDefaults = { color: '#38bdf8', opacity: 0.12 };

    const hex = (typeof f.fillColor === 'string' && /^#[0-9a-fA-F]{6}$/.test(f.fillColor)) ? f.fillColor : String(state.areaDefaults.color || '#38bdf8');
    const op  = (typeof f.fillOpacity === 'number' && isFinite(f.fillOpacity)) ? Math.max(0, Math.min(1, f.fillOpacity)) : Math.max(0, Math.min(1, Number(state.areaDefaults.opacity || 0.12)));

    const rgbaFromHex = (h, a)=>{
      try{
        const r = parseInt(h.slice(1,3),16);
        const g = parseInt(h.slice(3,5),16);
        const b = parseInt(h.slice(5,7),16);
        return `rgba(${r},${g},${b},${a})`;
      }catch(_){ return `rgba(56,189,248,${a})`; }
    };

    ctx.save();

    ctx.fillStyle   = rgbaFromHex(hex, op);
    ctx.strokeStyle = hex;
    ctx.lineWidth   = 1.5;

    ctx.beginPath();

    let first = worldToCanvas(pts[0]);
    ctx.moveTo(first.xPx, first.yPx);
    for (let i = 1; i < pts.length; i++) {
      const p = worldToCanvas(pts[i]);
      ctx.lineTo(p.xPx, p.yPx);
    }
    ctx.closePath();

    const holes = f.holes || [];
    holes.forEach(poly => {
      if (!Array.isArray(poly) || poly.length < 3) return;
      const h0 = worldToCanvas(poly[0]);
      ctx.moveTo(h0.xPx, h0.yPx);
      for (let i = 1; i < poly.length; i++) {
        const hp = worldToCanvas(poly[i]);
        ctx.lineTo(hp.xPx, hp.yPx);
      }
      ctx.closePath();
    });

    ctx.fill('evenodd');
    ctx.stroke();

    if (isSelectedId(f.id)) {
      ctx.strokeStyle = '#fbbf24';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    if (state.editMode === 'movePoint' && state.selectedId === f.id) {
      ctx.fillStyle = '#22c55e';
      pts.forEach(p => {
        const c = worldToCanvas(p);
        ctx.beginPath();
        ctx.arc(c.xPx, c.yPx, 4, 0, Math.PI * 2);
        ctx.fill();
      });
      holes.forEach(poly => {
        poly.forEach(p => {
          const c = worldToCanvas(p);
          ctx.beginPath();
          ctx.arc(c.xPx, c.yPx, 4, 0, Math.PI * 2);
          ctx.fill();
        });
      });
    }

    ctx.restore();
  }

  // --- chunk end 17.1 ---------------------------------------------------------------

  
  // --- chunk 17.1b · Display scale (gridPx) + stability-first +/- ----------------------

// SUB-CHUNK 17.D END — Draw line/area features (active)
// SUB-CHUNK 17.E BEGIN — View recenter + gridPx + bump helpers
  function recenterViewToKeepCanvasPointStable(xPx, yPx, worldPoint){
    const ppmNew = getPxPerMeter();
    state.viewOriginXM = worldPoint.xM - xPx / ppmNew;
    state.viewOriginYM = worldPoint.yM - yPx / ppmNew;
  }

  function applyGridPxFromUI(){
    if (!gridPxInput) return;
    let v = parseFloat(gridPxInput.value);
    if(!Number.isFinite(v)) return;
    v = Math.max(5, Math.min(80, v));
    const cx = canvas.width/2, cy = canvas.height/2;
    const Wc = canvasToWorldRaw(cx, cy);
    state.gridPx = v;
    gridPxInput.value = String(Math.round(v));
    updateStatusScale();
    recenterViewToKeepCanvasPointStable(cx, cy, Wc);
    draw(); updateFeatureSelect(); refreshSelectedInspector();
  }

  if (gridPxInput) {
    gridPxInput.addEventListener('change', applyGridPxFromUI);
  }

  function bumpNumberInput(el, delta){
    if (!el) return;
    const step = parseFloat(el.step || '1');
    const cur = parseFloat(el.value);
    const base = Number.isFinite(cur) ? cur : 0;
    const stepUse = (Number.isFinite(step) && step > 0) ? step : 1;
    const next = base + delta * stepUse;
    el.value = String(next);
    el.dispatchEvent(new Event('change'));
  }

  // Long‑press repeat for +/- buttons (touch + mouse).
  // Behavior: one step immediately, then after a short hold, continuous stepping.
// SUB-CHUNK 17.E END — View recenter + gridPx + bump helpers
// SUB-CHUNK 17.F BEGIN — Hold-repeat bindings + unit-sensitive inputs
  function bindHoldRepeat(btn, inputEl, delta){
    if (!btn || !inputEl) return;
    let holdTimer = null;
    let repeatTimer = null;
    let suppressClickUntil = 0;

    const stop = ()=>{
      if (holdTimer){ clearTimeout(holdTimer); holdTimer = null; }
      if (repeatTimer){ clearInterval(repeatTimer); repeatTimer = null; }
      // suppress the synthetic click that often follows touch/pointerup
      suppressClickUntil = Date.now() + 350;
      btn.classList.remove('is-holding');
    };

    const start = (ev)=>{
      // Only left mouse button; allow all touch/pen.
      if (ev && ev.type === 'pointerdown' && ev.pointerType === 'mouse' && ev.button !== 0) return;

      ev && ev.preventDefault && ev.preventDefault();
      // capture ensures we receive pointerup even if finger slides
      try { btn.setPointerCapture && ev && btn.setPointerCapture(ev.pointerId); } catch(e){}

      bumpNumberInput(inputEl, delta); // immediate step
      btn.classList.add('is-holding');

      holdTimer = setTimeout(()=>{
        repeatTimer = setInterval(()=> bumpNumberInput(inputEl, delta), 90);
      }, 320);
    };

    btn.addEventListener('pointerdown', start, {passive:false});
    btn.addEventListener('pointerup', stop);
    btn.addEventListener('pointercancel', stop);
    btn.addEventListener('pointerleave', stop);

    // Click fallback (keyboard) + safety for synthetic clicks after a hold
    btn.addEventListener('click', (e)=>{
      if (Date.now() < suppressClickUntil) { e.preventDefault(); return; }
      bumpNumberInput(inputEl, delta);
    });
  }

  bindHoldRepeat(gridPxMinusBtn, gridPxInput, -1);
  bindHoldRepeat(gridPxPlusBtn,  gridPxInput, +1);
  bindHoldRepeat(metersPerGridMinusBtn, metersPerGridInput, -1);
  bindHoldRepeat(metersPerGridPlusBtn,  metersPerGridInput, +1);

  // --- end chunk 17.1b -----------------------------------------------------------------

  // --- chunk 17.2 · Display grid (metersPerGrid) ---------------------------------------

  // Keep the visible input values consistent with current units.
  // Internal storage remains meters.
  function syncUnitSensitiveInputs(){
    if (metersPerGridInput) {
      metersPerGridInput.value = fmtNum(distDisplayValue(state.metersPerGrid), 2);
    }
    if (snapStepInput) {
      snapStepInput.value = fmtNum(distDisplayValue(state.snapStepM || state.metersPerGrid || 1), 3);
    }
    // Angle dist input: leave whatever the user typed; it is interpreted per-units at runtime
    // (so switching units does not silently rewrite their in-progress value).
  }

  metersPerGridInput.addEventListener('change',()=>{
    const v = parseFloat(metersPerGridInput.value);
    if(!Number.isFinite(v) || v <= 0) return;

    const cx = canvas.width/2, cy = canvas.height/2;
    const Wc = canvasToWorldRaw(cx, cy);

    const prevM = state.metersPerGrid;
    // Interpret entered value in current units, store meters
    const newM = inputDistToMetersAny(v) ?? state.metersPerGrid;

    state.metersPerGrid = newM;

    // Keep view stable (do not "jump" when scale changes)
    recenterViewToKeepCanvasPointStable(cx, cy, Wc);

    // Keep snapStepM tracking display grid ONLY if it was previously tracking
    if (Math.abs((state.snapStepM ?? prevM) - prevM) < 1e-9) {
      state.snapStepM = newM;
      if (snapStepInput) snapStepInput.value = fmtNum(distDisplayValue(newM), 3);
    }

    updateStatusScale();
    draw(); updateFeatureSelect(); refreshSelectedInspector();
  });

  // --- chunk 17.2b · Snap step (units-aware input; internal meters) --------------------

// SUB-CHUNK 17.F END — Hold-repeat bindings + unit-sensitive inputs
// SUB-CHUNK 17.G BEGIN — Snap step + layers sync
  function applySnapStepM(val){
    const v = parseFloat(val);
    if(!Number.isFinite(v) || v <= 0) return;

    // Interpret input in current units, store meters
    state.snapStepM = inputDistToMetersAny(v) ?? state.snapStepM;
    // No need to redraw grid; only affects snapping when Snap is ON
  }

  if (snapStepInput) {
    snapStepInput.addEventListener('change', ()=>{
      applySnapStepM(snapStepInput.value);
    });
  }

  // --- chunk 17.3 · Pan controls -------------------------------------------------------
  // Removed: on-screen pan arrow buttons were removed from the Topbar.
  // Panning is handled via Inspect/Nav drag + touch gestures.
  // --- END chunk 17.3 ---------------------------------------------------------------

  // --- chunk 17.4 · Layers ------------------------------------------------------------

  function syncLayersFromUI(){
    state.layers.roads   = !!(layerRoadsVisible && layerRoadsVisible.checked);
    state.layers.lanes   = !!(layerLanesVisible && layerLanesVisible.checked);
    state.layers.areas   = !!(layerAreasVisible && layerAreasVisible.checked);
    state.layers.labels  = !!(layerLabelsVisible && layerLabelsVisible.checked);
    state.layers.symbols = !!(layerSymbolsVisible && layerSymbolsVisible.checked);
    state.layers.measure = !!(layerMeasureVisible && layerMeasureVisible.checked);

    // Locks (edit guards)
    if (!state.layerLocks) state.layerLocks = { roads:false, lanes:false, areas:false, labels:false, symbols:false, measure:false };
    state.layerLocks.roads   = !!(layerRoadsLocked && layerRoadsLocked.checked);
    state.layerLocks.lanes   = !!(layerLanesLocked && layerLanesLocked.checked);
    state.layerLocks.areas   = !!(layerAreasLocked && layerAreasLocked.checked);
    state.layerLocks.labels  = !!(layerLabelsLocked && layerLabelsLocked.checked);
    state.layerLocks.symbols = !!(layerSymbolsLocked && layerSymbolsLocked.checked);
    state.layerLocks.measure = !!(layerMeasureLocked && layerMeasureLocked.checked);

    draw();
  }

  [
    layerRoadsVisible,
    layerLanesVisible,
    layerAreasVisible,
    layerLabelsVisible,
    layerSymbolsVisible,
    layerMeasureVisible,
    layerRoadsLocked,
    layerLanesLocked,
    layerAreasLocked,
    layerLabelsLocked,
    layerSymbolsLocked,
    layerMeasureLocked
  ].forEach(ch=>{
    ch.addEventListener('change', syncLayersFromUI);
  });

  // --- chunk 17.5 · Panel toggle + measure overlay clear -------------------------------

  // Toggle the right properties panel overlay
  if (toggleRightPanelBtn) {
    // LEGACY: Properties button relocated to Stack Y Button 5
// \1});
  }

  // Measurement overlay clear button: just unselect
  if (measureClearBtn) {
    measureClearBtn.addEventListener('click', () => {
      state.selectedId = null;

    // Restore background image (persisted as Data URL) — safe on all platforms
    try{
      const bi = (snap.bgImage && typeof snap.bgImage === 'object') ? snap.bgImage : null;

      // Always restore placement/controls if present, even if no dataUrl
      if (bi){
        if (typeof bi.opacity === 'number' && isFinite(bi.opacity)) state.bgImageOpacity = clamp(bi.opacity, 0, 1);
        if (typeof bi.mpp === 'number' && isFinite(bi.mpp)) state.bgImageMpp = bi.mpp;
        if (typeof bi.originXM === 'number' && isFinite(bi.originXM)) state.bgImageOriginXM = bi.originXM;
        if (typeof bi.originYM === 'number' && isFinite(bi.originYM)) state.bgImageOriginYM = bi.originYM;
        if (typeof bi.name === 'string') state.bgImageName = bi.name;
        if (typeof bi.dataUrl === 'string') state.bgImageDataUrl = bi.dataUrl;
      }

      // Rebuild runtime image object if we have a dataUrl
      if (state.bgImageDataUrl && typeof state.bgImageDataUrl === 'string'){
        const img = new Image();
        img.onload = ()=>{
          state._bgImageObj = img;
          state.bgImageEnabled = !!(bi ? bi.enabled : true);
          // Keep UI in sync if helper exists
          if (typeof setBgImageEnabled === 'function') setBgImageEnabled(!!state.bgImageEnabled);
          if (typeof syncBgImageControls === 'function') syncBgImageControls();
          draw();
        };
        img.onerror = ()=>{
          state._bgImageObj = null;
          state.bgImageEnabled = false;
          if (typeof setBgImageEnabled === 'function') setBgImageEnabled(false);
          try{ toast('BG image failed to load from draft'); }catch(_){}
          draw();
        };
        img.src = state.bgImageDataUrl;
      } else {
        state._bgImageObj = null;
        state.bgImageEnabled = !!(bi && bi.enabled);
        if (typeof setBgImageEnabled === 'function') setBgImageEnabled(!!state.bgImageEnabled);
      }
    }catch(_){}

      draw();
    });
  }
// --- chunk end 17 ---------------------------------------------------------------
  // --- Full-board view chunk 18 --------------------------------------------------------
  // View Board contract:
  // - Enter: show the whole project (fit-to-bounds) and lock to inspect/nav (no drawing).
  // - Exit : restore the previous working view AND previously active tool.
  // - Redraws here are intentional view changes (not layout-driven).

  function enterViewBoard(){
    // Save working view
    state._viewBoardPrev = {
      viewOriginXM: state.viewOriginXM,
      viewOriginYM: state.viewOriginYM,
      metersPerGrid: state.metersPerGrid
    };

    // Save current tool/edit context
    state._viewBoardPrevTool = {
      tool: state.tool,
      editMode: state.editMode,
      selectedId: state.selectedId
    };

    document.body.classList.add('full-board');
    try{ calibrateRightDock(); }catch(_){ }

    // Force inspect/nav while in View Board to prevent conflicting edits
    try { setTool('inspect'); } catch(_) { state.tool = 'inspect'; state.phase = 'idle'; }
    state.selectedId = null;

    // Restore background image (persisted as Data URL) — safe on all platforms
    try{
      const bi = (snap.bgImage && typeof snap.bgImage === 'object') ? snap.bgImage : null;

      // Always restore placement/controls if present, even if no dataUrl
      if (bi){
        if (typeof bi.opacity === 'number' && isFinite(bi.opacity)) state.bgImageOpacity = clamp(bi.opacity, 0, 1);
        if (typeof bi.mpp === 'number' && isFinite(bi.mpp)) state.bgImageMpp = bi.mpp;
        if (typeof bi.originXM === 'number' && isFinite(bi.originXM)) state.bgImageOriginXM = bi.originXM;
        if (typeof bi.originYM === 'number' && isFinite(bi.originYM)) state.bgImageOriginYM = bi.originYM;
        if (typeof bi.name === 'string') state.bgImageName = bi.name;
        if (typeof bi.dataUrl === 'string') state.bgImageDataUrl = bi.dataUrl;
      }

      // Rebuild runtime image object if we have a dataUrl
      if (state.bgImageDataUrl && typeof state.bgImageDataUrl === 'string'){
        const img = new Image();
        img.onload = ()=>{
          state._bgImageObj = img;
          state.bgImageEnabled = !!(bi ? bi.enabled : true);
          // Keep UI in sync if helper exists
          if (typeof setBgImageEnabled === 'function') setBgImageEnabled(!!state.bgImageEnabled);
          if (typeof syncBgImageControls === 'function') syncBgImageControls();
          draw();
        };
        img.onerror = ()=>{
          state._bgImageObj = null;
          state.bgImageEnabled = false;
          if (typeof setBgImageEnabled === 'function') setBgImageEnabled(false);
          try{ toast('BG image failed to load from draft'); }catch(_){}
          draw();
        };
        img.src = state.bgImageDataUrl;
      } else {
        state._bgImageObj = null;
        state.bgImageEnabled = !!(bi && bi.enabled);
        if (typeof setBgImageEnabled === 'function') setBgImageEnabled(!!state.bgImageEnabled);
      }
    }catch(_){}

    // Fit to project bounds; if nothing exists, keep current view.
    if (fitViewToProject({ padPx: 56 })) {
      draw();
    }
  }

  function exitViewBoard(){
    document.body.classList.remove('full-board');
    try{ calibrateRightDock(); }catch(_){ }

    // Restore previous view
    const prev = state._viewBoardPrev;
    state._viewBoardPrev = null;
    if (prev) {
      state.viewOriginXM = prev.viewOriginXM;
      state.viewOriginYM = prev.viewOriginYM;
      state.metersPerGrid = prev.metersPerGrid;
    }

    // Restore previous tool/edit context
    const tprev = state._viewBoardPrevTool;
    state._viewBoardPrevTool = null;
    if (tprev && tprev.tool) {
      try { setTool(tprev.tool); } catch(_) { state.tool = tprev.tool; }
      try { if (typeof setEditMode === 'function' && tprev.editMode) setEditMode(tprev.editMode); } catch(_){ }
      try { if (tprev.selectedId != null) state.selectedId = tprev.selectedId; } catch(_){ }
    }

    // Ensure one clean repaint after restoration (setTool may also draw; extra draw is harmless)
    draw();
  }

  fullViewBtn.addEventListener('click', () => {
    enterViewBoard();
  });

  exitFullViewBtn.addEventListener('click', () => {
    exitViewBoard();
  });
// --- chunk end 18 ---------------------------------------------------------------

// --- Save / load / export / Records chunk 19 ----------------------------------------

  const SAVE_KEY = 'fieldDraft_saves_v2';

// SUB-CHUNK 17.G END — Snap step + layers sync

  // SCRIPT PART 2.3 END (LLM ANCHOR)
</script>

<script>

  // SCRIPT PART 2.4 BEGIN (LLM ANCHOR)
// SUB-CHUNK 17.H BEGIN — Draft persistence + snapshots
  function loadAllDrafts(){
    try{
      const raw=localStorage.getItem(SAVE_KEY);
      if(!raw) return {};
      const obj=JSON.parse(raw);
      return obj && typeof obj==='object' ? obj : {};
    }catch(e){
      console.warn('loadAllDrafts error',e);
      return {};
    }
  }

  function saveAllDrafts(map){
    try{
      localStorage.setItem(SAVE_KEY,JSON.stringify(map));
    }catch(e){
      console.warn('saveAllDrafts error',e);
      alert('Save failed (storage full?).');
    }
  }

  // --- chunk 19.1a · Draft snapshot (v3 canvas-only) ---------------------------------
  // v3 draft snapshot: view + display + layers + bgImage + features
  // IMPORTANT TRUTH RULE:
  // - Draft files must NOT persist user UI preferences (theme/buttons/tool/edit mode/etc.).
  // - Draft files SHOULD persist canvas/document data (grid/view, canvasBg, grid opacity, layers, bg image, features).
  

  // --- chunk 19.S · Portable custom symbol pack (used-symbols-only) -----------------
  // Draft/export JSON may embed only the custom symbols it actually references.
  // This keeps drafts small while allowing clean-device imports to render custom symbols.
  function _collectReferencedUserSymbolIds(features){
    const out = new Set();
    const feats = Array.isArray(features) ? features : [];
    for (const f of feats){
      if (!f || f.type !== 'symbol') continue;
      const t = String(f.symbolType || '');
      if (t.startsWith('user:')){
        const id = t.slice(5).trim();
        if (id) out.add(id);
      }
    }
    return out;
  }

  function _buildUserSymbolsPackFromFeatures(features){
    try{
      const ids = _collectReferencedUserSymbolIds(features);
      if (!ids || ids.size === 0) return null;

      const lib = _getUserSymbols();
      const symbols = [];
      const missing = [];

      for (const id of ids){
        const def = lib.find(s=>s && String(s.id)===String(id)) || null;
        if (!def || !def.template || !Array.isArray(def.template.items)){
          missing.push(String(id));
          continue;
        }
        const payload = FDSP_ENCODE_TEMPLATE(def.template);
        if (!payload){
          missing.push(String(id));
          continue;
        }
        symbols.push({
          id: String(def.id),
          name: String(def.name || ''),
          baseSizeM: (typeof def.baseSizeM==='number' ? def.baseSizeM : null),
          codec: 'FDSP',
          v: 1,
          payload
        });
      }

      const pack = {
        codec: 'FDSP',
        v: 1,
        symbols
      };
      if (missing.length) pack.missing = missing;
      return pack;
    }catch(_){
      return null;
    }
  }
  // --- chunk end 19.S ---------------------------------------------------------------

function makeDraftSnapshot(){
    const symbolsPack = _buildUserSymbolsPackFromFeatures(state.features);
    return {
      meta:{
        version:3,
        savedAt:new Date().toISOString(),
        jobId: draftJobIdInput.value || ''
      },
      view:{
        gridPx:state.gridPx,
        metersPerGrid:state.metersPerGrid,
        snapStepM: state.snapStepM,
        viewOriginXM:state.viewOriginXM,
        viewOriginYM:state.viewOriginYM
      },
      display:{
        canvasBg: state.canvasBg || '#020617',
        gridOpacity: (typeof state.gridOpacity==='number' && isFinite(state.gridOpacity)) ? clamp(state.gridOpacity,0,1) : 1,
        gridOpacityMinor: (typeof state.gridOpacityMinor==='number' && isFinite(state.gridOpacityMinor)) ? clamp(state.gridOpacityMinor,0,1) : ((typeof state.gridOpacity==='number' && isFinite(state.gridOpacity)) ? clamp(state.gridOpacity,0,1) : 1),
        gridOpacityMajor: (typeof state.gridOpacityMajor==='number' && isFinite(state.gridOpacityMajor)) ? clamp(state.gridOpacityMajor,0,1) : ((typeof state.gridOpacity==='number' && isFinite(state.gridOpacity)) ? clamp(state.gridOpacity,0,1) : 1)
      },
      layers: deepClone(state.layers || {}),
      bgImage:{
        enabled: !!state.bgImageEnabled,
        opacity: (typeof state.bgImageOpacity==='number' ? state.bgImageOpacity : 0.6),
        mpp: (typeof state.bgImageMpp==='number' ? state.bgImageMpp : null),
        originXM: (typeof state.bgImageOriginXM==='number' ? state.bgImageOriginXM : 0),
        originYM: (typeof state.bgImageOriginYM==='number' ? state.bgImageOriginYM : 0),
        name: state.bgImageName || '',
        dataUrl: state.bgImageDataUrl || ''
      },
      features:state.features,
      symbolsPack: symbolsPack || undefined
    };
  }

  // --- chunk 19.1x · Export snapshot (canvas-only; excludes UI prefs) -------------------
  // Purpose: JSON export/import should NOT override the user's UI preferences (theme, buttons, tool).
  // Export contains: view + canvas display + layers + bgImage + features.
  function makeExportSnapshot(){
    const symbolsPack = _buildUserSymbolsPackFromFeatures(state.features);
    return {
      meta:{
        version:2,
        savedAt:new Date().toISOString(),
        jobId: draftJobIdInput.value || ''
      },
      view:{
        gridPx:state.gridPx,
        metersPerGrid:state.metersPerGrid,
        snapStepM: state.snapStepM,
        viewOriginXM:state.viewOriginXM,
        viewOriginYM:state.viewOriginYM
      },
      display:{
        canvasBg: state.canvasBg || '#020617',
        gridOpacity: (typeof state.gridOpacity==='number' && isFinite(state.gridOpacity)) ? clamp(state.gridOpacity,0,1) : 1,
        gridOpacityMinor: (typeof state.gridOpacityMinor==='number' && isFinite(state.gridOpacityMinor)) ? clamp(state.gridOpacityMinor,0,1) : ((typeof state.gridOpacity==='number' && isFinite(state.gridOpacity)) ? clamp(state.gridOpacity,0,1) : 1),
        gridOpacityMajor: (typeof state.gridOpacityMajor==='number' && isFinite(state.gridOpacityMajor)) ? clamp(state.gridOpacityMajor,0,1) : ((typeof state.gridOpacity==='number' && isFinite(state.gridOpacity)) ? clamp(state.gridOpacity,0,1) : 1)
      },
      layers: deepClone(state.layers || {}),
      bgImage:{
        enabled: !!state.bgImageEnabled,
        opacity: (typeof state.bgImageOpacity==='number' ? state.bgImageOpacity : 0.6),
        mpp: (typeof state.bgImageMpp==='number' ? state.bgImageMpp : null),
        originXM: (typeof state.bgImageOriginXM==='number' ? state.bgImageOriginXM : 0),
        originYM: (typeof state.bgImageOriginYM==='number' ? state.bgImageOriginYM : 0),
        name: state.bgImageName || '',
        dataUrl: state.bgImageDataUrl || ''
      },
      features: state.features,
      symbolsPack: symbolsPack || undefined
    };
  }
  // --- chunk end 19.1x ---------------------------------------------------------------

  // --- chunk end 19.1a ---------------------------------------------------------------

  
  
  // Display prefs persistence (theme + optional colors) — baseline defaults to MID for first-time users
  const DISPLAY_PREFS_KEY = 'FD_DISPLAY_PREFS_V1';

  // --- Session recovery (autosave safety net; canvas/draft only) --------------------
  // Purpose:
  // - Prevent loss of unsaved work if the page/app is exited (Back/Backup/refresh).
  // - On next open, offer to restore the last unsaved session.
  // Notes:
  // - Uses makeDraftSnapshot() so it stays canvas-only (no UI prefs/theme).
  // - Throttled writes to avoid performance issues.
  const FD_SESSION_KEY = 'FD_SESSION_RECOVERY_V1';
  const FD_SESSION_META_KEY = 'FD_SESSION_META_V1';

  let _fdDirtySinceSave = false;
  let _fdLastManualSaveAt = 0;
	let _fdLastBaselineAt = 0;
  let _fdSessionWriteTimer = 0;
  let _fdSessionNonce = Math.random().toString(36).slice(2);

  function _fdLoadSessionMeta(){
    try{
      const raw = localStorage.getItem(FD_SESSION_META_KEY);
      if(!raw) return;
      const obj = JSON.parse(raw);
      if(obj && typeof obj === 'object' && typeof obj.lastSaveAt === 'number' && isFinite(obj.lastSaveAt)){
        _fdLastManualSaveAt = obj.lastSaveAt;
      }
	    if(obj && typeof obj === 'object' && typeof obj.lastBaselineAt === 'number' && isFinite(obj.lastBaselineAt)){
	      _fdLastBaselineAt = obj.lastBaselineAt;
	    }
    }catch(_){ }
  }

  function writeSessionRecoverySnapshot(){
    try{
      if (typeof makeDraftSnapshot !== 'function') return;
      const payload = {
        v: 1,
        at: Date.now(),
        nonce: _fdSessionNonce,
        snap: makeDraftSnapshot()
      };
      localStorage.setItem(FD_SESSION_KEY, JSON.stringify(payload));
    }catch(_){ }
  }

  function scheduleSessionRecoveryWrite(delayMs){
    if(!_fdDirtySinceSave) return;
    const d = (typeof delayMs === 'number' && isFinite(delayMs) && delayMs >= 0) ? delayMs : 1200;
    try{ if(_fdSessionWriteTimer) clearTimeout(_fdSessionWriteTimer); }catch(_){ }
    _fdSessionWriteTimer = setTimeout(()=>{
      _fdSessionWriteTimer = 0;
      if(_fdDirtySinceSave) writeSessionRecoverySnapshot();
    }, d);
  }

  function clearSessionRecoverySnapshot(){
    try{ localStorage.removeItem(FD_SESSION_KEY); }catch(_){ }
  }

  function maybeOfferRestoreSession(didLoadFromHash){
    // If a draft was explicitly loaded from hash, respect that and do not override.
    if(didLoadFromHash) return false;
    try{
      _fdLoadSessionMeta();
      const raw = localStorage.getItem(FD_SESSION_KEY);
      if(!raw) return false;
      const payload = JSON.parse(raw);
      if(!payload || typeof payload !== 'object') return false;
      const at = (typeof payload.at === 'number' && isFinite(payload.at)) ? payload.at : 0;
      const snap = payload.snap;
      if(!snap || typeof snap !== 'object') return false;
	    const baseAt = Math.max((_fdLastManualSaveAt || 0), (_fdLastBaselineAt || 0));
	    if(at <= baseAt) return false;

      const when = new Date(at).toLocaleString();
      const ok = confirm(`Recover unsaved session from ${when}?`);
      if(ok){
        // Use the same import pipeline for safety.
        if (typeof normalizeCanvasSnapshot === 'function'){
          applyImportedSnapshot(normalizeCanvasSnapshot(snap));
    // Session recovery: loading a saved draft clears dirty flag and recovery snapshot
    _fdDirtySinceSave = false;
    try{ clearSessionRecoverySnapshot(); }catch(_){}
        } else {
          applyImportedSnapshot(snap);
        }
        _fdDirtySinceSave = true;
        scheduleSessionRecoveryWrite(250);
        return true;
      } else {
        clearSessionRecoverySnapshot();
        return false;
      }
    }catch(_){
      return false;
    }
  }

  function installSessionExitGuards(){
    const flush = ()=>{ if(_fdDirtySinceSave) writeSessionRecoverySnapshot(); };

    // Attempt a standard unsaved-changes prompt where supported.
    window.addEventListener('beforeunload', (e)=>{
      if(!_fdDirtySinceSave) return;
      try{ flush(); }catch(_){ }
      e.preventDefault();
      e.returnValue = '';
      return '';
    });

    // Mobile browsers often skip beforeunload prompts; ensure we still snapshot.
    window.addEventListener('pagehide', ()=>{ try{ flush(); }catch(_){ } });
    document.addEventListener('visibilitychange', ()=>{
      if(document.visibilityState === 'hidden'){
        try{ flush(); }catch(_){ }
      }
    });
  }
  // --- Session recovery end ---------------------------------------------------------

  function loadDisplayPrefs(){
    try{
      const raw = localStorage.getItem(DISPLAY_PREFS_KEY);
      if(!raw) return;
      const obj = JSON.parse(raw);
      if(!obj || typeof obj !== 'object') return;

      if (obj.uiTheme){
        const t = String(obj.uiTheme).toLowerCase();
        if (t === 'dark' || t === 'mid' || t === 'light' || t === 'custom') state.uiTheme = t;
      }
      if (obj.uiThemeColor){
        const c = String(obj.uiThemeColor).trim();
        if (/^#([0-9a-fA-F]{6})$/.test(c)) state.uiThemeColor = c;
      }
      // Control wells palette prefs removed (v1.6.6.6)
      if (typeof obj.gridOpacity === 'number' && isFinite(obj.gridOpacity)){
        // stored as 0..1
        state.gridOpacity = clamp(obj.gridOpacity, 0, 1);
      }

      // v2: separate minor/major grid opacity (stored as 0..1)
      if (typeof obj.gridOpacityMinor === 'number' && isFinite(obj.gridOpacityMinor)){
        state.gridOpacityMinor = clamp(obj.gridOpacityMinor, 0, 1);
      } else {
        state.gridOpacityMinor = (typeof state.gridOpacity==='number' && isFinite(state.gridOpacity)) ? clamp(state.gridOpacity,0,1) : 1;
      }
      if (typeof obj.gridOpacityMajor === 'number' && isFinite(obj.gridOpacityMajor)){
        state.gridOpacityMajor = clamp(obj.gridOpacityMajor, 0, 1);
      } else {
        state.gridOpacityMajor = (typeof state.gridOpacity==='number' && isFinite(state.gridOpacity)) ? clamp(state.gridOpacity,0,1) : 1;
      }

      if (typeof obj.btnFaceA === 'string' && obj.btnFaceA){
        state.btnFaceA = obj.btnFaceA;
      }
      if (typeof obj.btnFaceB === 'string' && obj.btnFaceB){
        state.btnFaceB = obj.btnFaceB;
      }
      if (typeof obj.btnBorder === 'string' && obj.btnBorder){
        state.btnBorder = obj.btnBorder;
      }

      if (typeof obj.btnAutoFaces === 'boolean'){
        state.btnAutoFaces = !!obj.btnAutoFaces;
      }

      if (obj.canvasBg){
        const c = String(obj.canvasBg).trim();
        if (/^#([0-9a-fA-F]{6})$/.test(c)) state.canvasBg = c;
      }

      if (typeof obj.bgImageOpacity === 'number' && isFinite(obj.bgImageOpacity)){
        state.bgImageOpacity = clamp(obj.bgImageOpacity, 0, 1);
      }
      if (typeof obj.bgImageMpp === 'number' && isFinite(obj.bgImageMpp) && obj.bgImageMpp > 0){
        state.bgImageMpp = obj.bgImageMpp;
      }
    }catch(_){}
  }

  function saveDisplayPrefs(){
    try{
      localStorage.setItem(DISPLAY_PREFS_KEY, JSON.stringify({
        uiTheme: state.uiTheme || 'mid',
        uiThemeColor: state.uiThemeColor || null,
        uiThemeCustomMode: state.uiThemeCustomMode || 'dark',
        uiThemeCustomStrength: (typeof state.uiThemeCustomStrength==='number' && isFinite(state.uiThemeCustomStrength)) ? Math.round(state.uiThemeCustomStrength) : 14,
        canvasBg: state.canvasBg || null,
        gridOpacity: (typeof state.gridOpacity==='number' && isFinite(state.gridOpacity)) ? clamp(state.gridOpacity,0,1) : 1,
        gridOpacityMinor: (typeof state.gridOpacityMinor==='number' && isFinite(state.gridOpacityMinor)) ? clamp(state.gridOpacityMinor,0,1) : ((typeof state.gridOpacity==='number' && isFinite(state.gridOpacity)) ? clamp(state.gridOpacity,0,1) : 1),
        gridOpacityMajor: (typeof state.gridOpacityMajor==='number' && isFinite(state.gridOpacityMajor)) ? clamp(state.gridOpacityMajor,0,1) : ((typeof state.gridOpacity==='number' && isFinite(state.gridOpacity)) ? clamp(state.gridOpacity,0,1) : 1),
        btnFaceA: state.btnFaceA || null,
        btnFaceB: state.btnFaceB || null,
        btnBorder: state.btnBorder || null,
        btnAutoFaces: !!state.btnAutoFaces,
        bgImageOpacity: (typeof state.bgImageOpacity==='number' && isFinite(state.bgImageOpacity)) ? clamp(state.bgImageOpacity,0,1) : 0.6,
        bgImageMpp: (typeof state.bgImageMpp==='number' && isFinite(state.bgImageMpp) && state.bgImageMpp>0) ? state.bgImageMpp : null
      }));
    }catch(_){}
  }

function applyUITheme(){
    const t = String(state.uiTheme || 'mid').toLowerCase();
    const theme = (t === 'mid' || t === 'light' || t === 'dark' || t === 'custom') ? t : 'mid';
    state.uiTheme = theme;
    try{
      document.body.dataset.theme = theme;
      if (theme === 'custom'){
        const cm = String(state.uiThemeCustomMode || 'dark').toLowerCase();
        document.body.dataset.customMode = (cm==='light' || cm==='dark') ? cm : 'dark';

        
        const base = String(state.uiThemeColor || '').trim() || '#2563eb';
        document.documentElement.style.setProperty('--ui-custom-base', base);
        const sRaw = (typeof state.uiThemeCustomStrength==='number' && isFinite(state.uiThemeCustomStrength)) ? state.uiThemeCustomStrength : 14;
        const s = Math.max(0, Math.min(40, Math.round(sRaw)));
        state.uiThemeCustomStrength = s;
        document.documentElement.style.setProperty('--ui-custom-strength', String(s) + '%');

      } else {
        try{ delete document.body.dataset.customMode; }catch(_){}
        // clear custom base so presets are pure
        document.documentElement.style.removeProperty('--ui-custom-base');
        document.documentElement.style.removeProperty('--ui-custom-strength');
      }
    }catch(_){}
    // Control wells palette override removed (v1.6.6.6)

    saveDisplayPrefs();
  }

  function canvasPresetToColor(preset){
    switch(String(preset||'').toLowerCase()){
      case 'draft-blue':  return '#0b2a4a';
      case 'draft-green': return '#0b3a2a';
      case 'white':       return '#ffffff';
      case 'dark':        return '#020617';
      default:            return null;
    }
  }

  
  function applyButtonSkinVars(){
    const root = document.documentElement;
    // Border remains user-controlled
    const br = (state.btnBorder || '#0000ff');

    // Optional: allow button faces to follow the current theme surfaces.
    const auto = !!state.btnAutoFaces;
    try{
      if (auto){
        document.body.dataset.btnAutoFaces = '1';
        // Let CSS token logic drive faces
        root.style.removeProperty('--btn-face-a');
        root.style.removeProperty('--btn-face-b');
      } else {
        try{ delete document.body.dataset.btnAutoFaces; }catch(_){ document.body.dataset.btnAutoFaces = '0'; }
        const a = (state.btnFaceA || '#ffffff');
        const b = (state.btnFaceB || '#020617');
        root.style.setProperty('--btn-face-a', a);
        root.style.setProperty('--btn-face-b', b);
      }
    }catch(_){
      // last resort: keep existing behavior
      const a = (state.btnFaceA || '#ffffff');
      const b = (state.btnFaceB || '#020617');
      root.style.setProperty('--btn-face-a', a);
      root.style.setProperty('--btn-face-b', b);
    }

    root.style.setProperty('--btn-border', br);
  }

  const DISPLAY_PRESET_SNAPSHOT_KEY = 'FD_DISPLAY_PRESET_SNAPSHOT_V1';

  
  // --- Toast helper (guarded) ---
  // Some builds call toast() for lightweight user feedback. Define it here so
  // missing UI toast plumbing never crashes runtime.
  function toast(message, ms){
    try{
      const text = String(message ?? '');
      const dur = (typeof ms === 'number' && ms > 0) ? ms : 1400;

      let el = document.getElementById('fd_toast');
      if(!el){
        el = document.createElement('div');
        el.id = 'fd_toast';
        el.setAttribute('role','status');
        el.style.position = 'fixed';
        el.style.left = '12px';
        el.style.bottom = '12px';
        el.style.zIndex = '99999';
        el.style.maxWidth = '70vw';
        el.style.padding = '8px 10px';
        el.style.borderRadius = '10px';
        el.style.fontSize = '13px';
        el.style.lineHeight = '1.25';
        el.style.backdropFilter = 'blur(6px)';
        el.style.webkitBackdropFilter = 'blur(6px)';
        // Theme-aware surfaces (falls back safely)
        el.style.background = 'color-mix(in srgb, var(--panel, #0b1220) 92%, #000 8%)';
        el.style.border = '1px solid color-mix(in srgb, var(--btn-border, var(--accent, #2563eb)) 65%, #000 35%)';
        el.style.color = 'var(--ink, #e5e7eb)';
        el.style.boxShadow = '0 10px 24px rgba(0,0,0,.35)';
        el.style.opacity = '0';
        el.style.transform = 'translateY(6px)';
        el.style.transition = 'opacity .15s ease, transform .15s ease';
        document.body.appendChild(el);
      }

      el.textContent = text;
      // animate in
      requestAnimationFrame(()=>{
        el.style.opacity = '1';
        el.style.transform = 'translateY(0)';
      });

      clearTimeout(el._fd_toast_t);
      el._fd_toast_t = setTimeout(()=>{
        el.style.opacity = '0';
        el.style.transform = 'translateY(6px)';
      }, dur);
    }catch(err){
      // last-resort: never throw from toast
      try{ console.log('toast:', message); }catch(_){}
    }
  }
  // --- /Toast helper ---

function snapshotCurrentDisplayPreset(){
    // Only the display-affecting fields we introduced/extended
    const legacy = (typeof state.gridOpacity==='number' && isFinite(state.gridOpacity)) ? clamp(state.gridOpacity,0,1) : 1;
    const minor  = (typeof state.gridOpacityMinor==='number' && isFinite(state.gridOpacityMinor)) ? clamp(state.gridOpacityMinor,0,1) : legacy;
    const major  = (typeof state.gridOpacityMajor==='number' && isFinite(state.gridOpacityMajor)) ? clamp(state.gridOpacityMajor,0,1) : legacy;
    return {
      canvasBg: state.canvasBg || '#020617',
      gridOpacity: legacy,          // legacy (v1)
      gridOpacityMinor: minor,      // v2
      gridOpacityMajor: major,      // v2
      btnFaceA: state.btnFaceA || '#ffffff',
      btnFaceB: state.btnFaceB || '#020617',
      btnBorder: state.btnBorder || '#0000ff',
      btnAutoFaces: !!state.btnAutoFaces,
      uiTheme: state.uiTheme || 'mid',
    };
  }

  function saveDisplayPresetSnapshot(){
    try{
      localStorage.setItem(DISPLAY_PRESET_SNAPSHOT_KEY, JSON.stringify(snapshotCurrentDisplayPreset()));
      toast('Preset saved');
    }catch(e){
      console.warn('Save preset failed', e);
      toast('Save failed');
    }
  }

  function loadDisplayPresetSnapshot(){
    try{
      const raw = localStorage.getItem(DISPLAY_PRESET_SNAPSHOT_KEY);
      if (!raw) return null;
      const obj = JSON.parse(raw);
      return (obj && typeof obj === 'object') ? obj : null;
    }catch(e){
      console.warn('Load preset failed', e);
      return null;
    }
  }

  function resetToFactoryDisplayPreset(){
    // Factory reset = shipped defaults (not the user-saved snapshot).
    // Also clear the saved preset snapshot so the user can: customize → save → reset → customize again.
    try{ localStorage.removeItem(DISPLAY_PRESET_SNAPSHOT_KEY); }catch(_){}

    const factory = {
      canvasBg: '#020617',
      gridOpacity: 1,
      gridOpacityMinor: 1,
      gridOpacityMajor: 1,
      btnFaceA: '#ffffff',
      btnFaceB: '#020617',
      btnBorder: '#0000ff',
      uiTheme: 'mid',
      btnAutoFaces: false,
      uiThemeColor: null
    };

    state.canvasBg = factory.canvasBg;
    state.gridOpacity = clamp(factory.gridOpacity, 0, 1);
    state.btnFaceA = factory.btnFaceA;
    state.btnFaceB = factory.btnFaceB;
    state.btnBorder = factory.btnBorder;
    state.btnAutoFaces = !!factory.btnAutoFaces;
    state.uiTheme = factory.uiTheme;
    state.uiThemeColor = factory.uiThemeColor;

    // Background image resets to OFF (image data is not persisted)
    state.bgImageEnabled = false;
    state._bgImageObj = null;
    state.bgImageName = '';
    
        state.bgImageDataUrl = '';state.bgImageOpacity = 0.6;
    state.bgImageMpp = null;

    applyButtonSkinVars();

    // If no saved snapshot exists yet, recreate it from the shipped defaults (post-reset baseline).
    if (!localStorage.getItem(DISPLAY_PRESET_SNAPSHOT_KEY)){
      try{ localStorage.setItem(DISPLAY_PRESET_SNAPSHOT_KEY, JSON.stringify(snapshotCurrentDisplayPreset())); }catch(e){}
    }

    applyUITheme();          // NOTE: function name is case-sensitive
    saveDisplayPrefs();      // keep normal display prefs in sync
    syncDisplayControls();
    draw();
    toast('Restored factory');
  }

function syncDisplayControls(){
    if (uiThemeSelect) uiThemeSelect.value = (state.uiTheme || 'mid');

    const legacy = (typeof state.gridOpacity==='number' && isFinite(state.gridOpacity)) ? clamp(state.gridOpacity,0,1) : 1;
    const minor  = (typeof state.gridOpacityMinor==='number' && isFinite(state.gridOpacityMinor)) ? clamp(state.gridOpacityMinor,0,1) : legacy;
    const major  = (typeof state.gridOpacityMajor==='number' && isFinite(state.gridOpacityMajor)) ? clamp(state.gridOpacityMajor,0,1) : legacy;

    if (gridOpacityMinorInput){
      gridOpacityMinorInput.value = String(Math.round(clamp(minor,0,1)*100));
      if (gridOpacityMinorValue) gridOpacityMinorValue.textContent = String(Math.round(clamp(minor,0,1)*100));
    }
    if (gridOpacityMajorInput){
      gridOpacityMajorInput.value = String(Math.round(clamp(major,0,1)*100));
      if (gridOpacityMajorValue) gridOpacityMajorValue.textContent = String(Math.round(clamp(major,0,1)*100));
    }
if (btnFaceAColorInput){
      btnFaceAColorInput.value = (state.btnFaceA || '#ffffff');
      if (btnFaceAColorText) btnFaceAColorText.textContent = (state.btnFaceA || '#ffffff');
    }
    if (btnFaceBColorInput){
      btnFaceBColorInput.value = (state.btnFaceB || '#020617');
      if (btnFaceBColorText) btnFaceBColorText.textContent = (state.btnFaceB || '#020617');
    }
    if (btnBorderColorInput){
      btnBorderColorInput.value = (state.btnBorder || '#0000ff');
      if (btnBorderColorText) btnBorderColorText.textContent = (state.btnBorder || '#0000ff');
    }

    if (typeof btnAutoFacesCheck !== 'undefined' && btnAutoFacesCheck){
      btnAutoFacesCheck.checked = !!state.btnAutoFaces;
    }
    // Disable face pickers when auto is enabled
    try{
      const dis = !!state.btnAutoFaces;
      if (btnFaceAColorInput) btnFaceAColorInput.disabled = dis;
      if (btnFaceBColorInput) btnFaceBColorInput.disabled = dis;
      if (btnFaceAColorInput) btnFaceAColorInput.style.opacity = dis ? '0.55' : '';
      if (btnFaceBColorInput) btnFaceBColorInput.style.opacity = dis ? '0.55' : '';
    }catch(_){ }

    // Background image UI (does not persist image data; only params)
    const bgOn = !!(state.bgImageEnabled && state._bgImageObj);
    if (bgImageOpacityRow) bgImageOpacityRow.style.display = bgOn ? '' : 'none';
    if (bgImageScaleRow)   bgImageScaleRow.style.display   = bgOn ? '' : 'none';

    if (bgImageOpacityInput){
      bgImageOpacityInput.value = String(Math.round(clamp((typeof state.bgImageOpacity==='number' && isFinite(state.bgImageOpacity)) ? state.bgImageOpacity : 0.6, 0, 1) * 100));
      if (bgImageOpacityValue) bgImageOpacityValue.textContent = String(bgImageOpacityInput.value);
    }
    if (bgImageMppInput){
      if (typeof state.bgImageMpp === 'number' && isFinite(state.bgImageMpp) && state.bgImageMpp > 0){
        bgImageMppInput.value = String(state.bgImageMpp);
      } else {
        bgImageMppInput.value = '';
      }
    }

    if (uiThemeCustomRow){
      const isCustom = String(state.uiTheme || 'mid').toLowerCase() === 'custom';
      uiThemeCustomRow.style.display = isCustom ? '' : 'none';
    }
    if (uiThemeCustomModeRow){
      const isCustom = String(state.uiTheme || 'mid').toLowerCase() === 'custom';
      uiThemeCustomModeRow.style.display = isCustom ? '' : 'none';
    }

    if (uiThemeCustomStrengthRow){
      const isCustom = String(state.uiTheme || 'mid').toLowerCase() === 'custom';
      uiThemeCustomStrengthRow.style.display = isCustom ? '' : 'none';
    }
    if (uiThemeCustomStrengthRange){
      const v = (typeof state.uiThemeCustomStrength==='number' && isFinite(state.uiThemeCustomStrength)) ? Math.max(0, Math.min(40, Math.round(state.uiThemeCustomStrength))) : 14;
      uiThemeCustomStrengthRange.value = String(v);
      if (uiThemeCustomStrengthText) uiThemeCustomStrengthText.textContent = String(v);
    }

    if (uiThemeCustomModeSelect){
      uiThemeCustomModeSelect.value = String(state.uiThemeCustomMode || 'dark');
    }
    if (uiThemeCustomColorInput){
      uiThemeCustomColorInput.value = String(state.uiThemeColor || '#2563eb');
    }
    if (uiThemeCustomColorText){
      uiThemeCustomColorText.value = String(state.uiThemeColor || '#2563eb');
    }
    // Control wells palette UI removed (v1.6.6.6)
    if (canvasBgColorInput){
      const c = String(state.canvasBg || '#020617');
      canvasBgColorInput.value = c;
    }
    if (canvasBgColorText){
      canvasBgColorText.value = String(state.canvasBg || '#020617');
    }

    // Determine best preset match
    if (canvasBgPresetSelect){
      const c = String(state.canvasBg || '#020617').toLowerCase();
      const map = {
        '#0b2a4a':'draft-blue',
        '#0b3a2a':'draft-green',
        '#ffffff':'white',
        '#020617':'dark'
      };
      const preset = map[c] || 'custom';
      canvasBgPresetSelect.value = preset;
      if (canvasBgCustomRow) canvasBgCustomRow.style.display = (preset === 'custom') ? '' : 'none';
    }
  }

  function wireDisplayControls(){
    // --- Theme + custom controls (single-bind, no nesting) ---
    if (uiThemeSelect){
      uiThemeSelect.addEventListener('change', ()=>{
        state.uiTheme = String(uiThemeSelect.value || 'mid').toLowerCase();

        // toggle custom rows immediately
        const isCustom = (String(state.uiTheme||'').toLowerCase() === 'custom');
        if (uiThemeCustomRow)         uiThemeCustomRow.style.display         = isCustom ? '' : 'none';
        if (uiThemeCustomModeRow)     uiThemeCustomModeRow.style.display     = isCustom ? '' : 'none';
        if (uiThemeCustomStrengthRow) uiThemeCustomStrengthRow.style.display = isCustom ? '' : 'none';
      if (uiThemeBtnAutoFacesRow) uiThemeBtnAutoFacesRow.style.display = '';// always available

        applyUITheme();
      });
    }

    if (uiThemeCustomColorInput){
      uiThemeCustomColorInput.addEventListener('input', ()=>{
        state.uiThemeColor = String(uiThemeCustomColorInput.value || '#2563eb');
        if (uiThemeCustomColorText) uiThemeCustomColorText.value = state.uiThemeColor;
        // ensure theme is custom when user edits
        if (uiThemeSelect && uiThemeSelect.value !== 'custom'){
          uiThemeSelect.value = 'custom';
          state.uiTheme = 'custom';
        }
        // ensure custom rows are visible
        if (uiThemeCustomRow)         uiThemeCustomRow.style.display         = '';
        if (uiThemeCustomModeRow)     uiThemeCustomModeRow.style.display     = '';
        if (uiThemeCustomStrengthRow) uiThemeCustomStrengthRow.style.display = '';
        applyUITheme();
      });
    }

    if (uiThemeCustomColorText){
      uiThemeCustomColorText.addEventListener('change', ()=>{
        const raw = String(uiThemeCustomColorText.value || '').trim();
        const v = raw.startsWith('#') ? raw : ('#'+raw);
        if (/^#([0-9a-fA-F]{6})$/.test(v)){
          state.uiThemeColor = v;
          if (uiThemeCustomColorInput) uiThemeCustomColorInput.value = v;
          if (uiThemeSelect && uiThemeSelect.value !== 'custom'){
            uiThemeSelect.value = 'custom';
            state.uiTheme = 'custom';
          }
          if (uiThemeCustomRow)         uiThemeCustomRow.style.display         = '';
          if (uiThemeCustomModeRow)     uiThemeCustomModeRow.style.display     = '';
          if (uiThemeCustomStrengthRow) uiThemeCustomStrengthRow.style.display = '';
          applyUITheme();
        } else {
          uiThemeCustomColorText.value = String(state.uiThemeColor || '#2563eb');
        }
      });
    }

    if (uiThemeCustomModeSelect){
      uiThemeCustomModeSelect.addEventListener('change', ()=>{
        const m = String(uiThemeCustomModeSelect.value || 'dark').toLowerCase();
        state.uiThemeCustomMode = (m==='light' || m==='dark') ? m : 'dark';
        if (uiThemeSelect && uiThemeSelect.value !== 'custom'){
          uiThemeSelect.value = 'custom';
          state.uiTheme = 'custom';
        }
        if (uiThemeCustomRow)         uiThemeCustomRow.style.display         = '';
        if (uiThemeCustomModeRow)     uiThemeCustomModeRow.style.display     = '';
        if (uiThemeCustomStrengthRow) uiThemeCustomStrengthRow.style.display = '';
        applyUITheme();
      });
    }

    if (uiThemeCustomStrengthRange){
      uiThemeCustomStrengthRange.addEventListener('input', ()=>{
        const v = Math.max(0, Math.min(40, Math.round(parseFloat(uiThemeCustomStrengthRange.value||'14')||14)));
        state.uiThemeCustomStrength = v;
        if (uiThemeCustomStrengthText) uiThemeCustomStrengthText.textContent = String(v);
        if (uiThemeSelect && uiThemeSelect.value !== 'custom'){
          uiThemeSelect.value = 'custom';
          state.uiTheme = 'custom';
        }
        if (uiThemeCustomRow)         uiThemeCustomRow.style.display         = '';
        if (uiThemeCustomModeRow)     uiThemeCustomModeRow.style.display     = '';
        if (uiThemeCustomStrengthRow) uiThemeCustomStrengthRow.style.display = '';
        applyUITheme();
      });
    }

    // --- /Theme + custom controls ---
    // --- Control wells palette controls removed (v1.6.6.6) ---

    if (canvasBgPresetSelect){
      canvasBgPresetSelect.addEventListener('change', ()=>{
        const preset = String(canvasBgPresetSelect.value || '').toLowerCase();
        const mapped = canvasPresetToColor(preset);
        if (mapped){
          state.canvasBg = mapped;
          if (canvasBgCustomRow) canvasBgCustomRow.style.display = 'none';
        } else {
          if (canvasBgCustomRow) canvasBgCustomRow.style.display = '';
          // keep existing color as custom
          state.canvasBg = String(state.canvasBg || '#020617');
        }
        if (canvasBgColorInput) canvasBgColorInput.value = String(state.canvasBg || '#020617');
        if (canvasBgColorText)  canvasBgColorText.value  = String(state.canvasBg || '#020617');
        draw();
      });
    }
    if (gridOpacityMinorInput){
      gridOpacityMinorInput.addEventListener("input", ()=>{
        const n = Number(gridOpacityMinorInput.value);
        const pct = isFinite(n) ? clamp(n, 0, 100) : 100;
        if (gridOpacityMinorValue) gridOpacityMinorValue.textContent = String(Math.round(pct));
        const v = clamp(pct/100, 0, 1);
        state.gridOpacityMinor = v;
        // keep legacy value in sync for older paths
        state.gridOpacity = (typeof state.gridOpacityMajor==='number' && isFinite(state.gridOpacityMajor)) ? clamp(Math.max(v, state.gridOpacityMajor), 0, 1) : v;
        saveDisplayPrefs();
        draw();
      });
    }
    if (gridOpacityMajorInput){
      gridOpacityMajorInput.addEventListener("input", ()=>{
        const n = Number(gridOpacityMajorInput.value);
        const pct = isFinite(n) ? clamp(n, 0, 100) : 100;
        if (gridOpacityMajorValue) gridOpacityMajorValue.textContent = String(Math.round(pct));
        const v = clamp(pct/100, 0, 1);
        state.gridOpacityMajor = v;
        // keep legacy value in sync for older paths
        state.gridOpacity = (typeof state.gridOpacityMinor==='number' && isFinite(state.gridOpacityMinor)) ? clamp(Math.max(v, state.gridOpacityMinor), 0, 1) : v;
        saveDisplayPrefs();
        draw();
      });
    }

    function bindBtnColor(inputEl, textEl, key){
      if (!inputEl) return;
      inputEl.addEventListener('input', ()=>{
        const v = String(inputEl.value || '').trim();
        state[key] = v || state[key];
        if (textEl) textEl.textContent = v;
        applyButtonSkinVars();
        saveDisplayPrefs();
        // no draw() required; CSS variables update instantly
      });
    }
    bindBtnColor(btnFaceAColorInput, btnFaceAColorText, 'btnFaceA');
    bindBtnColor(btnFaceBColorInput, btnFaceBColorText, 'btnFaceB');

    if (btnAutoFacesCheck){
      btnAutoFacesCheck.addEventListener('change', ()=>{
        state.btnAutoFaces = !!btnAutoFacesCheck.checked;
        applyButtonSkinVars();
        syncDisplayControls();
        saveDisplayPrefs();
      });
    }

    bindBtnColor(btnBorderColorInput, btnBorderColorText, 'btnBorder');

    if (saveDisplayPresetBtn){
      saveDisplayPresetBtn.addEventListener('click', ()=>{
        saveDisplayPresetSnapshot();
      });
    }
    if (resetFactoryBtn){
      resetFactoryBtn.addEventListener('click', ()=>{
        resetToFactoryDisplayPreset();
      });
    }

    if (canvasBgColorInput){
      canvasBgColorInput.addEventListener('input', ()=>{
        const c = String(canvasBgColorInput.value || '').trim();
        if (!c) return;
        state.canvasBg = c;
        if (canvasBgColorText) canvasBgColorText.value = c;
        draw();
      });
    }
    if (canvasBgColorText){
      canvasBgColorText.addEventListener('change', ()=>{
        const raw = String(canvasBgColorText.value || '').trim();
        const c = raw.startsWith('#') ? raw : ('#'+raw);
        if (!/^#[0-9a-fA-F]{6}$/.test(c)) {
          canvasBgColorText.value = String(state.canvasBg || '#020617');
          return;
        }
        state.canvasBg = c;
        if (canvasBgColorInput) canvasBgColorInput.value = c;
        draw();
      });
    }
  
    // --- Background Image (optional) ---------------------------------------------------
    function setBgImageEnabled(on){
      const v = !!on;
      state.bgImageEnabled = v;
      if (bgImageOpacityRow) bgImageOpacityRow.style.display = v ? '' : 'none';
      if (bgImageScaleRow)   bgImageScaleRow.style.display   = v ? '' : 'none';
      if (bgImageCalRow)     bgImageCalRow.style.display     = v ? '' : 'none';
    }

    function centerBgImageInView(){
      if (!state._bgImageObj || !state.bgImageMpp || !(state.bgImageMpp > 0)) return;
      const img = state._bgImageObj;
      const ppm = getPxPerMeter();
      const viewWM = canvas.width / ppm;
      const viewHM = canvas.height / ppm;

      const imgWM = img.width  * state.bgImageMpp;
      const imgHM = img.height * state.bgImageMpp;

      state.bgImageOriginXM = state.viewOriginXM + (viewWM - imgWM) / 2;
      state.bgImageOriginYM = state.viewOriginYM + (viewHM - imgHM) / 2;
    }

    function loadBgImageFromFile(file){
      if (!file) return;
      try{
        const reader = new FileReader();
        reader.onload = ()=>{
          try{
            const img = new Image();
            img.onload = ()=>{
              state._bgImageObj = img;
              state.bgImageName = String(file.name || '');
              // Default scale: fit image width to current view width (user can adjust m/px afterward)
              const ppm = getPxPerMeter();
              const viewWM = canvas.width / ppm;
              const mpp = (img.width > 0) ? (viewWM / img.width) : null;
              state.bgImageMpp = (typeof mpp === 'number' && isFinite(mpp) && mpp > 0) ? mpp : (1/ppm);

              // Place centered in current view
              centerBgImageInView();

              setBgImageEnabled(true);
              if (bgImageMppInput) bgImageMppInput.value = String(state.bgImageMpp);
              if (bgImageOpacityInput) bgImageOpacityInput.value = String(Math.round(clamp(state.bgImageOpacity,0,1)*100));
              if (bgImageOpacityValue) bgImageOpacityValue.textContent = String(Math.round(clamp(state.bgImageOpacity,0,1)*100));
              draw();
              toast('Background image loaded');
            };
            img.onerror = ()=>{
              toast('Image load failed');
            };
            try{ state.bgImageDataUrl = String(reader.result || ''); }catch(_){ state.bgImageDataUrl = ''; }
            img.src = String(reader.result || '');
          }catch(_){
            toast('Image load failed');
          }
        };
        reader.onerror = ()=> toast('Image read failed');
        reader.readAsDataURL(file);
      }catch(_){
        toast('Image load failed');
      }
    }

    if (bgImageLoadBtn){
      bgImageLoadBtn.addEventListener('click', ()=>{
        if (bgImageFileInput) bgImageFileInput.click();
      });
    }
    if (bgImageFileInput){
      bgImageFileInput.addEventListener('change', ()=>{
        const file = (bgImageFileInput.files && bgImageFileInput.files[0]) ? bgImageFileInput.files[0] : null;
        // allow selecting the same file twice
        try{ bgImageFileInput.value = ''; }catch(_){}
        loadBgImageFromFile(file);
      });
    }
    if (bgImageClearBtn){
      bgImageClearBtn.addEventListener('click', ()=>{
        state.bgImageEnabled = false;
        state._bgImageObj = null;
        state.bgImageName = '';
        // Keep last m/px + opacity so reloading feels consistent
        setBgImageEnabled(false);
        draw();
        toast('Background cleared');
      });
    }
    if (bgImageOpacityInput){
      bgImageOpacityInput.addEventListener('input', ()=>{
        const n = Number(bgImageOpacityInput.value);
        const pct = isFinite(n) ? clamp(n, 0, 100) : 60;
        if (bgImageOpacityValue) bgImageOpacityValue.textContent = String(Math.round(pct));
        state.bgImageOpacity = clamp(pct/100, 0, 1);
        saveDisplayPrefs(); // stores opacity only
        draw();
      });
    }
    if (bgImageMppInput){
      bgImageMppInput.addEventListener('change', ()=>{
        const n = Number(bgImageMppInput.value);
        if (!isFinite(n) || n <= 0) {
          if (state.bgImageMpp && state.bgImageMpp > 0) bgImageMppInput.value = String(state.bgImageMpp);
          return;
        }
        state.bgImageMpp = n;
        saveDisplayPrefs(); // stores m/px
        draw();
      });
    }
    if (bgImageCenterBtn){
      bgImageCenterBtn.addEventListener('click', ()=>{
        centerBgImageInView();
        draw();
      });
    }

    if (bgImageCalBtn){
      bgImageCalBtn.addEventListener('click', ()=>{
        // Arm 2-point calibration capture for background image scale
        if (!state._bgImageObj || !state.bgImageMpp || !(state.bgImageMpp > 0)) {
          toast('Load a background image first');
          return;
        }
        const n = Number(bgImageCalLenInput ? bgImageCalLenInput.value : '');
        if (!isFinite(n) || n <= 0) {
          toast('Enter a known length first');
          return;
        }
        if (!state._bgCal) state._bgCal = { active:false, p1:null, p1Img:null };
        state._bgCal.active = true;
        state._bgCal.p1 = null;
        state._bgCal.p1Img = null;
        if (bgImageCalCancelBtn) bgImageCalCancelBtn.style.display = '';
        toast('BG Calibrate: click first point on the image');
      });
    }
    if (bgImageCalCancelBtn){
      bgImageCalCancelBtn.addEventListener('click', ()=>{
        if (!state._bgCal) state._bgCal = { active:false, p1:null, p1Img:null };
        state._bgCal.active = false;
        state._bgCal.p1 = null;
        state._bgCal.p1Img = null;
        bgImageCalCancelBtn.style.display = 'none';
        toast('BG Calibrate cancelled');
        draw();
      });
    }

    // Initial visibility (if image was already loaded via runtime)
    setBgImageEnabled(!!(state.bgImageEnabled && state._bgImageObj));
    // -----------------------------------------------------------------------------------

}

function applyLayersToUI(){
    if (!state.layers) return;
    if (layerRoadsVisible)   layerRoadsVisible.checked   = !!state.layers.roads;
    if (layerLanesVisible)   layerLanesVisible.checked   = !!state.layers.lanes;
    if (layerAreasVisible)   layerAreasVisible.checked   = !!state.layers.areas;
    if (layerLabelsVisible)  layerLabelsVisible.checked  = !!state.layers.labels;
    if (layerSymbolsVisible) layerSymbolsVisible.checked = !!state.layers.symbols;
    if (layerMeasureVisible) layerMeasureVisible.checked = !!state.layers.measure;

    if (!state.layerLocks) state.layerLocks = { roads:false, lanes:false, areas:false, labels:false, symbols:false, measure:false };
    if (layerRoadsLocked)   layerRoadsLocked.checked   = !!state.layerLocks.roads;
    if (layerLanesLocked)   layerLanesLocked.checked   = !!state.layerLocks.lanes;
    if (layerAreasLocked)   layerAreasLocked.checked   = !!state.layerLocks.areas;
    if (layerLabelsLocked)  layerLabelsLocked.checked  = !!state.layerLocks.labels;
    if (layerSymbolsLocked) layerSymbolsLocked.checked = !!state.layerLocks.symbols;
    if (layerMeasureLocked) layerMeasureLocked.checked = !!state.layerLocks.measure;
  }

  // Backward-compatible restore:
  // - v1 had meta/view/features only
  // - v2 adds ui + snapStepM (+ lineStyle)
  // --- chunk 19.2a · Apply draft snapshot (restore lineStyle safely) -------------------
  function applyDraftSnapshot(snap){
    if(!snap || !snap.view || !Array.isArray(snap.features)) return;

    // Restore view
    state.gridPx        = (snap.view.gridPx ?? state.gridPx);
    state.metersPerGrid = (snap.view.metersPerGrid ?? state.metersPerGrid);
    state.snapStepM     = (snap.view.snapStepM ?? snap.view.metersPerGrid ?? state.snapStepM);

    state.viewOriginXM  = (snap.view.viewOriginXM ?? 0);
    state.viewOriginYM  = (snap.view.viewOriginYM ?? 0);

    // Restore UI/state if present (v2)
    if (snap.ui && typeof snap.ui === 'object') {
      if (typeof snap.ui.snapEnabled === 'boolean') state.snapEnabled = snap.ui.snapEnabled;
      if (snap.ui.snapMode){
        const sm = String(snap.ui.snapMode).toLowerCase();
        state.snapMode = (sm === 'angle' || sm === 'grid') ? sm : 'point';
      }

      if (typeof snap.ui.axisLock === 'boolean') state.axisLock = snap.ui.axisLock;
      if (typeof snap.ui.multiSelectEnabled === 'boolean') state.multiSelectEnabled = snap.ui.multiSelectEnabled;
      if (snap.ui.unitsMode) state.unitsMode = snap.ui.unitsMode;
      // Normalize unitsMode (backward-safe; allow extended units)
      {
        const um = String(state.unitsMode || 'metric').toLowerCase();
        const ok = (um === 'metric' || um === 'cm' || um === 'mm' || um === 'imperial' || um === 'in');
        state.unitsMode = ok ? um : (um === 'feet' ? 'imperial' : 'metric');
      }

      // Restore lineStyle if present (v2+)
      if (snap.ui.lineStyle) {
        state.lineStyle = String(snap.ui.lineStyle).toLowerCase();
      }

      if (snap.ui.layers && typeof snap.ui.layers === 'object') {
        state.layers = deepClone(snap.ui.layers);
      }

      // Restore display prefs (v2+)
      if (snap.ui.canvasBg){
        const c = String(snap.ui.canvasBg).trim();
        state.canvasBg = c ? c : (state.canvasBg || '#020617');
      }
      if (snap.ui.theme){
  const t = String(snap.ui.theme).toLowerCase();
  state.uiTheme = (t === 'dark' || t === 'mid' || t === 'light' || t === 'custom') ? t : (state.uiTheme || 'mid');
}
if (snap.ui.themeColor){
  const c = String(snap.ui.themeColor).trim();
  if (/^#([0-9a-fA-F]{6})$/.test(c)) state.uiThemeColor = c;
}

      // Tool + edit mode last
      if (snap.ui.tool) state.tool = snap.ui.tool;
      if (snap.ui.editMode) state.editMode = snap.ui.editMode;
    } else {
      // Backward drafts: derive a safe default lineStyle from restored tool
      state.lineStyle = (state.tool === 'lane') ? 'dashed' : 'solid';
    }

    // Normalize lineStyle to known values (hard safety)
    if (state.lineStyle !== 'solid' && state.lineStyle !== 'dashed' && state.lineStyle !== 'centerline') {
      state.lineStyle = (state.tool === 'lane') ? 'dashed' : 'solid';
    }

    // Restore geometry
    state.features = snap.features;

    // --- sub-chunk 19.2a.1 · Normalize features (backward-safe + style field hygiene) ---
    let maxId=0;

    state.features.forEach(f=>{
      if(!f) return;

      if(f.id>maxId) maxId=f.id;

      // Areas must always have holes array
      if (f.type === 'area' && !Array.isArray(f.holes)) {
        f.holes = [];
      }

      // Lines: sanitize optional style fields (do NOT invent them if missing)
      if (f.type === 'road' || f.type === 'lane') {
        // lineStyle (per-feature) stays optional but if present must be known
        if (f.lineStyle != null) {
          const ls = String(f.lineStyle).toLowerCase();
          if (ls === 'solid' || ls === 'dashed' || ls === 'centerline') f.lineStyle = ls;
          else delete f.lineStyle;
        }

        // strokeWidthPx: number > 0
        if (f.strokeWidthPx != null) {
          const w = Number(f.strokeWidthPx);
          if (Number.isFinite(w) && w > 0) f.strokeWidthPx = w;
          else delete f.strokeWidthPx;
        }

        // strokeColor: string
        if (f.strokeColor != null) {
          const c = String(f.strokeColor);
          if (c.length) f.strokeColor = c;
          else delete f.strokeColor;
        }

        // strokeDash: array of finite positive numbers (or null)
        if (f.strokeDash != null) {
          if (Array.isArray(f.strokeDash)) {
            const cleaned = f.strokeDash
              .map(Number)
              .filter(n => Number.isFinite(n) && n > 0);
            if (cleaned.length) f.strokeDash = cleaned;
            else f.strokeDash = null;
          } else {
            // allow explicit null; otherwise drop
            if (f.strokeDash !== null) delete f.strokeDash;
          }
        }
      }

      // Measures: ensure derived values + optional style overrides are sane
      if (f.type === 'measure') {
        // points must be an array with at least 2 points
        if (!Array.isArray(f.points)) f.points = [];
        if (f.points.length >= 2) {
          try{
            f.length = lineLengthMeters(f.points.slice(0,2));
            const dx = f.points[1].xM - f.points[0].xM;
            const dy = f.points[1].yM - f.points[0].yM;
            f.angleDeg = Math.atan2(dy,dx)*180/Math.PI;
          }catch(_){}
        } else {
          delete f.length;
          delete f.angleDeg;
        }

        // Optional style fields (same hygiene rules as road/lane; do not invent if missing)
        if (f.strokeWidthPx != null) {
          const w = Number(f.strokeWidthPx);
          if (Number.isFinite(w) && w > 0) f.strokeWidthPx = w;
          else delete f.strokeWidthPx;
        }
        if (f.strokeColor != null) {
          const c = String(f.strokeColor);
          if (c.length) f.strokeColor = c;
          else delete f.strokeColor;
        }
        if (f.strokeDash != null) {
          if (Array.isArray(f.strokeDash)) {
            const cleaned = f.strokeDash
              .map(Number)
              .filter(n => Number.isFinite(n) && n > 0);
            if (cleaned.length) f.strokeDash = cleaned;
            else f.strokeDash = null;
          } else {
            if (f.strokeDash !== null) delete f.strokeDash;
          }
        }

        // Seed label pos if missing (only once)
        if (!Number.isFinite(f.txM) || !Number.isFinite(f.tyM)) {
          try{
            const d = _defaultMeasureLabelPos(f.points || []);
            f.txM = d.xM; f.tyM = d.yM;
          }catch(_){}
        }
      }
    });

    state.nextId=maxId+1;
    // --- end sub-chunk 19.2a.1 ---------------------------------------------------------

    // Reflect restored values into UI fields
    if (gridPxInput) gridPxInput.value = state.gridPx;
    if (metersPerGridInput) metersPerGridInput.value = state.metersPerGrid;
    if (snapStepInput) snapStepInput.value = String(state.snapStepM || state.metersPerGrid || 1);

    // XY lock button
    if (lockAxisBtn) lockAxisBtn.classList.toggle('active', !!state.axisLock);

    // Layers checkboxes
    applyLayersToUI();

    // Status bar + toolspace + unit labels
    updateStatusScale();
    updateStatusSnap();
    updateStatusSnapMode();
    updateStatusUnits();
    if (typeof syncUnitSensitiveInputs === 'function') syncUnitSensitiveInputs();
    updateToolspace();

    // Ensure Line Tool UI surfaces are correct
    if (typeof syncLineToolLabel === 'function') syncLineToolLabel();

    // Apply tool + edit mode
    if (typeof setTool === 'function') setTool(state.tool || 'inspect');
    if (typeof setEditMode === 'function') setEditMode(state.editMode || 'none');

    // Selection is UI-state; clear it on load to avoid stale ids
    state.selectedIds = [];
    state.selectedId = null;

    // Restore background image (persisted as Data URL) — safe on all platforms
    try{
      const bi = (snap.bgImage && typeof snap.bgImage === 'object') ? snap.bgImage : null;

      // Always restore placement/controls if present, even if no dataUrl
      if (bi){
        if (typeof bi.opacity === 'number' && isFinite(bi.opacity)) state.bgImageOpacity = clamp(bi.opacity, 0, 1);
        if (typeof bi.mpp === 'number' && isFinite(bi.mpp)) state.bgImageMpp = bi.mpp;
        if (typeof bi.originXM === 'number' && isFinite(bi.originXM)) state.bgImageOriginXM = bi.originXM;
        if (typeof bi.originYM === 'number' && isFinite(bi.originYM)) state.bgImageOriginYM = bi.originYM;
        if (typeof bi.name === 'string') state.bgImageName = bi.name;
        if (typeof bi.dataUrl === 'string') state.bgImageDataUrl = bi.dataUrl;
      }

      // Rebuild runtime image object if we have a dataUrl
      if (state.bgImageDataUrl && typeof state.bgImageDataUrl === 'string'){
        const img = new Image();
        img.onload = ()=>{
          state._bgImageObj = img;
          state.bgImageEnabled = !!(bi ? bi.enabled : true);
          // Keep UI in sync if helper exists
          if (typeof setBgImageEnabled === 'function') setBgImageEnabled(!!state.bgImageEnabled);
          if (typeof syncBgImageControls === 'function') syncBgImageControls();
          draw();
        };
        img.onerror = ()=>{
          state._bgImageObj = null;
          state.bgImageEnabled = false;
          if (typeof setBgImageEnabled === 'function') setBgImageEnabled(false);
          try{ toast('BG image failed to load from draft'); }catch(_){}
          draw();
        };
        img.src = state.bgImageDataUrl;
      } else {
        state._bgImageObj = null;
        state.bgImageEnabled = !!(bi && bi.enabled);
        if (typeof setBgImageEnabled === 'function') setBgImageEnabled(!!state.bgImageEnabled);
      }
    }catch(_){}

    draw();
    updateFeatureSelect();
    refreshSelectedInspector();

    // Apply display prefs after restore
    applyUITheme();
    syncDisplayControls();

  }
  // --- chunk 19.2a.X · Normalize snapshot to canvas-only (strip UI prefs) -------------
  // Accepts older drafts/exports that may contain snap.ui; lifts draft-level canvas data
  // into display/layers, then removes ui so it cannot overwrite user preferences.
  function normalizeCanvasSnapshot(snap){
    if (!snap || typeof snap !== 'object') return snap;
    if (snap.ui && typeof snap.ui === 'object'){
      if (!snap.display) snap.display = {};
      if (!snap.display.canvasBg && snap.ui.canvasBg) snap.display.canvasBg = snap.ui.canvasBg;
      if (typeof snap.display.gridOpacity !== 'number' && typeof snap.ui.gridOpacity === 'number') snap.display.gridOpacity = snap.ui.gridOpacity;
      if (typeof snap.display.gridOpacityMinor !== 'number' && typeof snap.ui.gridOpacityMinor === 'number') snap.display.gridOpacityMinor = snap.ui.gridOpacityMinor;
      if (typeof snap.display.gridOpacityMajor !== 'number' && typeof snap.ui.gridOpacityMajor === 'number') snap.display.gridOpacityMajor = snap.ui.gridOpacityMajor;
      if (!snap.layers && snap.ui.layers) snap.layers = snap.ui.layers;
      // Never apply ui prefs from a draft.
      try{ delete snap.ui; }catch(_){ snap.ui = undefined; }
    }
    return snap;
  }

  // --- chunk 19.2b · Apply imported snapshot (canvas-only; ignores UI prefs) ------------
  function applyImportedSnapshot(snap){
    if(!snap || !snap.view || !Array.isArray(snap.features)) return false;

    // Hydrate runtime symbol registry from imported pack (so clean devices can render custom symbols).
    _clearRuntimeUserSymbolRegistry();
    const __sympackReport = _sympackNewReport();
    try{
      if (snap.symbolsPack && snap.symbolsPack.codec === 'FDSP' && snap.symbolsPack.v === 1 && Array.isArray(snap.symbolsPack.symbols)){
        const arr = snap.symbolsPack.symbols;
        __sympackReport.total = arr.length;
        if (arr.length > SYMPACK_MAX_SYMBOLS) __sympackReport.tooMany = true;
        const limit = Math.min(arr.length, SYMPACK_MAX_SYMBOLS);
        for (let i=0;i<limit;i++){
          const rec = arr[i];
          const dec = _safeDecodeSymbolPackRecord(rec);
          if (!dec.ok){
            __sympackReport.skipped++;
            _sympackAddReason(__sympackReport, dec.reason);
            continue;
          }
          _registerRuntimeUserSymbol({
            id: String(rec.id),
            name: String(rec.name || ''),
            baseSizeM: (typeof rec.baseSizeM === 'number' ? rec.baseSizeM : null),
            template: dec.template
          });
          __sympackReport.loaded++;
        }
        // If we capped, count remaining as skipped with a single reason bucket.
        if (arr.length > limit){
          __sympackReport.skipped += (arr.length - limit);
          _sympackAddReason(__sympackReport, 'pack cap exceeded');
        }
      } else if (snap.symbolsPack){
        __sympackReport.unsupported = true;
      }
    }catch(_){
      __sympackReport.skipped++;
      _sympackAddReason(__sympackReport, 'symbolsPack decode error');
    }
    _lastSymbolsPackReport = (__sympackReport.total || __sympackReport.loaded || __sympackReport.skipped) ? __sympackReport : null;


    // Use the main restorer for view + features (+ bgImage), but ensure ui is not applied.
    const tmp = {
      meta: snap.meta || {},
      view: snap.view,
      bgImage: snap.bgImage,
      features: snap.features
    };
    applyDraftSnapshot(tmp);

    // Apply canvas display (draft-level) without touching UI theme/buttons.
    if (snap.display && typeof snap.display === 'object'){
      if (snap.display.canvasBg){
        const c = String(snap.display.canvasBg).trim();
        if (/^#([0-9a-fA-F]{6})$/.test(c)) state.canvasBg = c;
      }
      if (typeof snap.display.gridOpacity === 'number' && isFinite(snap.display.gridOpacity)){
        state.gridOpacity = clamp(snap.display.gridOpacity, 0, 1);
      }
      if (typeof snap.display.gridOpacityMinor === 'number' && isFinite(snap.display.gridOpacityMinor)){
        state.gridOpacityMinor = clamp(snap.display.gridOpacityMinor, 0, 1);
      }
      if (typeof snap.display.gridOpacityMajor === 'number' && isFinite(snap.display.gridOpacityMajor)){
        state.gridOpacityMajor = clamp(snap.display.gridOpacityMajor, 0, 1);
      }
      syncDisplayControls();
    }

    // Apply layer visibility (draft-level)
    if (snap.layers && typeof snap.layers === 'object'){
      state.layers = deepClone(snap.layers);
      applyLayersToUI();
    }

    draw();
    return true;
  }

  // --- chunk 19.2c · Merge imported snapshot into current draft -----------------------
  // Purpose: Import a draft/export JSON *into* the current draft without replacing it.
  // Rules: merges features; does NOT apply view/display/bgImage; adds missing layers only; avoids groupId collisions.
  function mergeImportedSnapshot(snap){
    try{ snap = normalizeCanvasSnapshot(snap); }catch(_){/* no-op */}
    if(!snap || !Array.isArray(snap.features)) return false;

    // Hydrate runtime symbol registry from imported pack (merge mode; do not clear existing).
    const __sympackReport = _sympackNewReport();
    try{
      if (snap.symbolsPack && snap.symbolsPack.codec === 'FDSP' && snap.symbolsPack.v === 1 && Array.isArray(snap.symbolsPack.symbols)){
        const arr = snap.symbolsPack.symbols;
        __sympackReport.total = arr.length;
        if (arr.length > SYMPACK_MAX_SYMBOLS) __sympackReport.tooMany = true;
        const limit = Math.min(arr.length, SYMPACK_MAX_SYMBOLS);
        for (let i=0;i<limit;i++){
          const rec = arr[i];
          if (!rec || rec.id == null) { __sympackReport.skipped++; _sympackAddReason(__sympackReport,'invalid record'); continue; }
          if (_getRuntimeUserSymbolById(rec.id)) continue;
          const dec = _safeDecodeSymbolPackRecord(rec);
          if (!dec.ok){
            __sympackReport.skipped++;
            _sympackAddReason(__sympackReport, dec.reason);
            continue;
          }
          _registerRuntimeUserSymbol({
            id: String(rec.id),
            name: String(rec.name || ''),
            baseSizeM: (typeof rec.baseSizeM === 'number' ? rec.baseSizeM : null),
            template: dec.template
          });
          __sympackReport.loaded++;
        }
        if (arr.length > limit){
          __sympackReport.skipped += (arr.length - limit);
          _sympackAddReason(__sympackReport, 'pack cap exceeded');
        }
      } else if (snap.symbolsPack){
        __sympackReport.unsupported = true;
      }
    }catch(_){
      __sympackReport.skipped++;
      _sympackAddReason(__sympackReport, 'symbolsPack decode error');
    }
    // Merge mode: only overwrite last report if this import had a pack.
    if (__sympackReport.total || __sympackReport.loaded || __sympackReport.skipped || __sympackReport.unsupported){
      _lastSymbolsPackReport = __sympackReport;
    }


    // Hardening: ensure current draft feature list is a writable array.
    // (Defensive against rare/uninitialized state or future refactors.)
    if (!Array.isArray(state.features)) state.features = [];

    // Prepare layer merge (non-destructive): only add layers that don't exist yet.
    if (snap.layers && typeof snap.layers === 'object'){
      if (!state.layers || typeof state.layers !== 'object') state.layers = {};
      const keys = Object.keys(snap.layers);
      for (const k of keys){
        if (!(k in state.layers)) state.layers[k] = deepClone(snap.layers[k]);
      }
      applyLayersToUI();
    }

    // GroupId collision guard: if imported groupId exists in current, remap to <gid>_impN
    const existingGroups = new Set();
    (state.features || []).forEach(f=>{
      if (!f) return;
      const g = (f.groupId != null) ? String(f.groupId).trim() : '';
      if (g) existingGroups.add(g);
    });

    const groupMap = new Map();
    const mapGroupId = (gidRaw)=>{
      const g0 = _normGroupStr(String(gidRaw||''));
      if (!g0) return null;
      if (groupMap.has(g0)) return groupMap.get(g0);
      let g = g0;
      if (existingGroups.has(g)){
        let i = 1;
        while (existingGroups.has(`${g0}_imp${i}`)) i++;
        g = `${g0}_imp${i}`;
      }
      groupMap.set(g0, g);
      existingGroups.add(g);
      return g;
    };

    const incoming = deepClone(snap.features || []);
    let added = 0;
    const importedIds = [];
    for (const f of incoming){
      if (!f || typeof f !== 'object') continue;
      const clone = deepClone(f);
      clone.id = state.nextId++;
      importedIds.push(clone.id);

      // Normalize/guard groupId
      if (clone.groupId != null && String(clone.groupId).trim() !== ''){
        const mapped = mapGroupId(clone.groupId);
        if (mapped) clone.groupId = mapped; else delete clone.groupId;
      } else {
        delete clone.groupId;
      }

      state.features.push(clone);
      added++;
    }

    if (added > 0){
      // Select newly imported objects so user can move them immediately.
      // On merge-import we explicitly enable Inspect/Nav + Multi-select,
      // then select ALL imported ids as the active selection set.
      try{
        // Helper: compute world bounds for a set of feature ids (selection).
        const _boundsForIds = (ids)=>{
          try{
            const want = new Set((ids||[]).map(n=>Number(n)).filter(n=>Number.isFinite(n)));
            if (!want.size) return null;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            const bump = (xM,yM)=>{
              if (!isFinite(xM) || !isFinite(yM)) return;
              if (xM < minX) minX = xM;
              if (yM < minY) minY = yM;
              if (xM > maxX) maxX = xM;
              if (yM > maxY) maxY = yM;
            };
            const feats = Array.isArray(state.features) ? state.features : [];
            feats.forEach(f=>{
              if (!f || !want.has(Number(f.id))) return;
              if (Array.isArray(f.points) && f.points.length){
                f.points.forEach(p=>bump(p.xM, p.yM));
              }
              if (f.type === 'symbol' && isFinite(f.xM) && isFinite(f.yM)){
                const s = (f.sizeM || state.metersPerGrid) * 0.75;
                bump(f.xM - s, f.yM - s);
                bump(f.xM + s, f.yM + s);
              }
              if (f.type === 'label'){
                if (isFinite(f.xM) && isFinite(f.yM)) bump(f.xM, f.yM);
                if (isFinite(f.txM) && isFinite(f.tyM)) bump(f.txM, f.tyM);
              }
            });
            if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) return null;
            if (maxX - minX < 1e-6) { maxX = minX + 1; }
            if (maxY - minY < 1e-6) { maxY = minY + 1; }
            return { minX, minY, maxX, maxY };
          }catch(_){ return null; }
        };

        // Helper: fit view to explicit bounds (like View Board, but for selection).
        const _fitViewToBounds = (b, opts)=>{
          opts = opts || {};
          if (!b) return false;
          const padPx = Number.isFinite(opts.padPx) ? opts.padPx : 56;
          const cw = roadCanvas ? roadCanvas.width : 0;
          const ch = roadCanvas ? roadCanvas.height: 0;
          if (!(cw > 0 && ch > 0)) return false;
          const wM = (b.maxX - b.minX);
          const hM = (b.maxY - b.minY);
          const ppmX = (cw - padPx * 2) / wM;
          const ppmY = (ch - padPx * 2) / hM;
          let ppmTarget = Math.min(ppmX, ppmY);
          if (!isFinite(ppmTarget) || ppmTarget <= 0) return false;
          ppmTarget = Math.max(0.05, Math.min(ppmTarget, 5000));
          const newMetersPerGrid = state.gridPx / ppmTarget;
          const viewWm = cw / ppmTarget;
          const viewHm = ch / ppmTarget;
          const cx = (b.minX + b.maxX) / 2;
          const cy = (b.minY + b.maxY) / 2;
          state.metersPerGrid = newMetersPerGrid;
          state.viewOriginXM = cx - viewWm / 2;
          state.viewOriginYM = cy - viewHm / 2;
          return true;
        };

        // 1) Ensure Inspect/Nav semantics (drag-to-move lives here)
        if (state.tool !== 'inspect') setTool('inspect');
        if (state.editMode && state.editMode !== 'none') setEditMode('none');

        // 2) Force multi-select ON for import (so all items are selected)
        state.multiSelectEnabled = true;

        // 3) Select everything we just imported (stable primary = last)
        const lastId = importedIds.length ? importedIds[importedIds.length-1] : null;
        _setSelectionMulti(importedIds, lastId);

        // 4) Arm Move mode (so the user can immediately drag the imported selection)
        try{
          setEditMode('moveShape');try{ if (typeof updateToolspace === 'function') updateToolspace(); }catch(_){ }
          try{ setModeLabel(); }catch(_){ }
        }catch(_){ }

        // 5) Expose imported bounds for optional camera-centering prompt (handled by UI layer)
        try{
          const b = _boundsForIds(importedIds);
          window.__fd_lastMergeImportBounds = b || null;
          // Export helper so UI layer can reuse the exact fit logic without duplicating math.
          // Reduce global churn: define once, update only the bounds each import.
          if (typeof window.__fd_fitViewToBounds !== 'function'){
            window.__fd_fitViewToBounds = (bb, opts)=>_fitViewToBounds(bb, opts);
          }
        }catch(_){ }

        updateFeatureSelect();
        refreshSelectedInspector();
        try{ if (typeof window.refreshMeasureDefaultsPanel === 'function') window.refreshMeasureDefaultsPanel(); }catch(_){ }
        try{ if (window.__fc_applyAreaPanelUI) window.__fc_applyAreaPanelUI(); }catch(_){ }
        try{ syncTopbarEditUI(); }catch(_){ }
        try{ setStatusHint('Imported selection ready · Move armed · Drag to place'); }catch(_){ }
      }catch(_){ /* best-effort */ }

      draw();
      if (typeof setStatus === 'function') setStatus(`Imported ${added} feature${added===1?'':'s'} into current draft.`);
      return true;
    }

    return false;
  }
  // --- chunk end 19.2c -------------------------------------------------------------
  // --- chunk end 19.2b ---------------------------------------------------------------

  // --- chunk end 19.2a ---------------------------------------------------------------

// SUB-CHUNK 17.H END — Draft persistence + snapshots
// SUB-CHUNK 17.I BEGIN — Draft record save/load + label sync
  function saveDraftRecord(name){
    if(!window.FieldOpsRecords) return;

    const features = state.features || [];
    let totalAreaM2 = 0;

    features.forEach(f => {
      if (f.type === 'area') {
        const a = areaWithHoles(f);
        if(Number.isFinite(a)) totalAreaM2 += a;
      }
    });

    const subtitleParts = [];
    if(features.length) subtitleParts.push(features.length + ' features');

    // Units-aware area for Records subtitle
    if(totalAreaM2 > 0){
      const aDisp = areaDisplayValue(totalAreaM2);
      subtitleParts.push(fmtNum(aDisp,1) + ' ' + unitLabelArea() + ' areas');
    }

    const jobId = draftJobIdInput.value || '';

    FieldOpsRecords.upsert('fieldDraft', {
      id: name,
      title: name,
      subtitle: subtitleParts.join(' • '),
      badge: 'Draft',
      updated: new Date().toLocaleString(),
      href: 'field-draft.html#' + encodeURIComponent(name),
      flagged: false,
      meta: { jobId }
    });
  }

  // --- Save / load UI handlers -------------------------------------------------------

  saveDraftBtn.addEventListener('click',()=>{
    const name=(draftNameInput.value||'').trim();
    if(!name){ alert('Enter a draft name first.'); return; }
    const map=loadAllDrafts();
    map[name]=makeDraftSnapshot();
    saveAllDrafts(map);
    saveDraftRecord(name);
    alert(`Draft "${name}" saved.`);
    // Session recovery: manual save resets dirty flag and records save timestamp
    _fdDirtySinceSave = false;
    _fdLastManualSaveAt = Date.now();
	    try{ localStorage.setItem(FD_SESSION_META_KEY, JSON.stringify({ lastSaveAt: _fdLastManualSaveAt, lastBaselineAt: (_fdLastBaselineAt||0) })); }catch(_){}
    // Keep recovery snapshot aligned with saved state
    try{ writeSessionRecoverySnapshot(); }catch(_){}

    if (typeof refreshLoadDraftDropdown === 'function') refreshLoadDraftDropdown();
  });

  
  function refreshLoadDraftDropdown(){
    if (!loadDraftSelect) return;
    const map = loadAllDrafts();
    const names = Object.keys(map).sort((a,b)=>a.localeCompare(b));
    const current = String(loadDraftSelect.value || '');

    loadDraftSelect.innerHTML = '';
    const opt0 = document.createElement('option');
    opt0.value = '';
    opt0.textContent = '(select)';
    loadDraftSelect.appendChild(opt0);

    names.forEach(n=>{
      const o = document.createElement('option');
      o.value = n;
      o.textContent = n;
      loadDraftSelect.appendChild(o);
    });

    if (current && names.includes(current)) loadDraftSelect.value = current;
  }

  // Populate list when user focuses/clicks the dropdown (avoids menu-toggle wiring)
  if (loadDraftSelect){
    loadDraftSelect.addEventListener('focus', refreshLoadDraftDropdown);
    loadDraftSelect.addEventListener('click', refreshLoadDraftDropdown);
    loadDraftSelect.addEventListener('change',()=>{
      const name = String(loadDraftSelect.value || '').trim();
      if (!name) return;
      const map = loadAllDrafts();
      if (draftNameInput) draftNameInput.value = name;
      if (draftJobIdInput) draftJobIdInput.value = (map[name] && map[name].meta && map[name].meta.jobId) ? String(map[name].meta.jobId) : '';
    });
  }

loadDraftBtn.addEventListener('click',()=>{
    const map=loadAllDrafts();
    const names=Object.keys(map);
    if(!names.length){ alert('No drafts saved yet.'); return; }

    // Prefer dropdown selection; fallback to typed draft name.
    let name = (loadDraftSelect && loadDraftSelect.value) ? String(loadDraftSelect.value).trim() : '';
    if(!name) name = (draftNameInput.value||'').trim();

    if(!name){
      name = names.sort((a,b)=>a.localeCompare(b))[0];
      if (loadDraftSelect) loadDraftSelect.value = name;
      if (draftNameInput) draftNameInput.value = name;
    }

    if(!name || !map[name]){ alert('Draft not found.'); return; }
    if (draftNameInput) draftNameInput.value = name;
    if (draftJobIdInput) draftJobIdInput.value = (map[name].meta && map[name].meta.jobId) || '';
    applyImportedSnapshot(normalizeCanvasSnapshot(map[name]));
  });

  if (deleteDraftBtn){
    deleteDraftBtn.addEventListener('click',()=>{
      const map = loadAllDrafts();
      const names = Object.keys(map);
      if(!names.length){ alert('No drafts saved yet.'); return; }

      const sel = (loadDraftSelect && loadDraftSelect.value) ? String(loadDraftSelect.value).trim() : '';
      const typed = (draftNameInput && draftNameInput.value) ? String(draftNameInput.value).trim() : '';
      const name = sel || typed;

      if(!name){ alert('No draft selected.'); return; }
      if(!map[name]){ alert('Draft not found.'); return; }

      if(!confirm('Delete saved draft: ' + name + ' ?')) return;

      delete map[name];
      saveAllDrafts(map);

      if (draftNameInput) draftNameInput.value = '';
      if (draftJobIdInput) draftJobIdInput.value = '';
      if (loadDraftSelect) loadDraftSelect.value = '';
      if (typeof refreshLoadDraftDropdown === 'function') refreshLoadDraftDropdown();
      if (typeof setStatus === 'function') setStatus('Deleted: ' + name);
    });
  }

  // --- Export / import JSON ----------------------------------------------------------

  exportJsonBtn.addEventListener('click',()=>{
    const snap=makeExportSnapshot();
    const name=(draftNameInput.value||'draft').trim() || 'draft';
    const blob=new Blob([JSON.stringify(snap,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url;
    const safeName=name.replace(/[^a-z0-9_-]+/gi,'_');
    a.download=`field-draft-${safeName}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  });

    // Import mode: 'replace' (Import JSON) vs 'merge' (Import into current draft)
  let _importJsonMode = 'replace';

  importJsonBtn.addEventListener('click',()=>{
    _importJsonMode = 'replace';
    importFileInput.click();
  });

  if (importIntoCurrentBtn){
    importIntoCurrentBtn.addEventListener('click', async ()=>{
      // Confirm intent (prevents the file picker from feeling like a surprise action).
      const go = await fdAskYesNo('Import into current draft?', 'Import', 'Cancel');
      if (!go) return;
      _importJsonMode = 'merge';
      importFileInput.click();
    });
  }

  importFileInput.addEventListener('change',e=>{
    const file=e.target.files[0];
    if(!file) return;
    const reader=new FileReader();
    reader.onload=evt=>{
      try{
        const snap=JSON.parse(evt.target.result);

        // Back-compat: if an older export included ui.canvasBg / ui.layers / gridOpacity*, lift them into display/layers
        if (snap && snap.ui && typeof snap.ui === 'object'){
          if (!snap.display) snap.display = {};
          if (!snap.display.canvasBg && snap.ui.canvasBg) snap.display.canvasBg = snap.ui.canvasBg;
          if (typeof snap.display.gridOpacity !== 'number' && typeof snap.ui.gridOpacity === 'number') snap.display.gridOpacity = snap.ui.gridOpacity;
          if (typeof snap.display.gridOpacityMinor !== 'number' && typeof snap.ui.gridOpacityMinor === 'number') snap.display.gridOpacityMinor = snap.ui.gridOpacityMinor;
          if (typeof snap.display.gridOpacityMajor !== 'number' && typeof snap.ui.gridOpacityMajor === 'number') snap.display.gridOpacityMajor = snap.ui.gridOpacityMajor;
          if (!snap.layers && snap.ui.layers) snap.layers = snap.ui.layers;
          // Never apply ui prefs on import
          delete snap.ui;
        }
        let ok = false;
        if (_importJsonMode === 'merge'){
          ok = mergeImportedSnapshot(snap);
          // SymbolsPack import report (merge mode)
          try{
            const r = _lastSymbolsPackReport;
            if (r && (r.total || r.loaded || r.skipped || r.unsupported)){
              const skipped = r.skipped || 0;
              let msg = 'Custom symbols loaded: ' + (r.loaded||0);
              if (skipped){
                const reasons = r.reasons || {};
                const top = Object.keys(reasons).sort((a,b)=>reasons[b]-reasons[a]).slice(0,2);
                const tail = top.map(k=> k + ' ' + reasons[k]).join(', ');
                msg += ' (skipped ' + skipped + (tail?': '+tail:'') + ')';
              }
              msg += '. Not saved to library.';
              setStatus && setStatus(msg);
            }
          }catch(_){ }
          // Status bar already reports import result; avoid modal alerts that block rendering/selection.
          if (!ok) alert('Could not import into current: invalid draft snapshot.');
          
        
          // After import completes, optionally center camera on the imported selection.
          try{
            const b = window.__fd_lastMergeImportBounds || null;
            if (ok && b){
              // Let the selection render first, then ask.
              setTimeout(async ()=>{
                const yes = await fdAskYesNo('Center camera on imported objects?', 'Yes', 'No');
                if (yes && window.__fd_fitViewToBounds){
                  if (window.__fd_fitViewToBounds(b, { padPx: 56 })) draw();
                }
              }, 0);
            }
          }catch(_){ }
} else {
          ok = applyImportedSnapshot(snap);
          // SymbolsPack import report (if present)
          try{
            const r = _lastSymbolsPackReport;
            if (r && (r.total || r.loaded || r.skipped || r.unsupported)){
              const skipped = r.skipped || 0;
              let msg = 'Custom symbols loaded: ' + (r.loaded||0);
              if (skipped){
                const reasons = r.reasons || {};
                const top = Object.keys(reasons).sort((a,b)=>reasons[b]-reasons[a]).slice(0,2);
                const tail = top.map(k=> k + ' ' + reasons[k]).join(', ');
                msg += ' (skipped ' + skipped + (tail?': '+tail:'') + ')';
              }
              msg += '. Not saved to library.';
              setStatus && setStatus(msg);
            }
          }catch(_){ }
          alert(ok ? 'Draft imported.' : 'Could not import: invalid draft snapshot.');
        }
      }catch(err){
        console.error(err);
        alert('Could not read JSON file.');
      }finally{
        importFileInput.value='';
      }
    };
    reader.readAsText(file);
  });

  // --- Transient Yes/No Modal helpers -------------------------------------------
  const fdYesNoOverlay = document.getElementById('fdYesNoOverlay');
  const fdYesNoMsg = document.getElementById('fdYesNoMsg');
  const fdYesNoBtnYes = document.getElementById('fdYesNoBtnYes');
  const fdYesNoBtnNo  = document.getElementById('fdYesNoBtnNo');

  function fdAskYesNo(message, yesLabel='Yes', noLabel='No'){
    return new Promise(resolve=>{
      if (!fdYesNoOverlay || !fdYesNoMsg || !fdYesNoBtnYes || !fdYesNoBtnNo){
        // Fallback (should be rare): confirm uses OK/Cancel semantics.
        resolve(!!confirm(message));
        return;
      }
      fdYesNoMsg.textContent = String(message || '');
      fdYesNoBtnYes.textContent = String(yesLabel || 'Yes');
      fdYesNoBtnNo.textContent  = String(noLabel  || 'No');
      fdYesNoOverlay.style.display = 'flex';
      fdYesNoOverlay.setAttribute('aria-hidden','false');

      const cleanup = (ans)=>{
        fdYesNoOverlay.style.display = 'none';
        fdYesNoOverlay.setAttribute('aria-hidden','true');
        fdYesNoBtnYes.onclick = null;
        fdYesNoBtnNo.onclick = null;
        try{ document.removeEventListener('keydown', onKey, true); }catch(_){ }
        resolve(ans);
      };

      const onKey = (ev)=>{
        if (ev.key === 'Escape'){ ev.preventDefault(); cleanup(false); }
        if (ev.key === 'Enter'){ ev.preventDefault(); cleanup(true); }
      };

      fdYesNoBtnYes.onclick = ()=>cleanup(true);
      fdYesNoBtnNo.onclick  = ()=>cleanup(false);
      // Click outside box = No
      fdYesNoOverlay.onclick = (e)=>{ if (e.target === fdYesNoOverlay) cleanup(false); };
      document.addEventListener('keydown', onKey, true);

      // Focus yes by default for quick flow
      try{ fdYesNoBtnYes.focus(); }catch(_){ }
    });
  }
  // -----------------------------------------------------------------------------

  // --- Export PNG --------------------------------------------------------------------

  exportPngBtn.addEventListener('click',()=>{
    const url=canvas.toDataURL('image/png');
    const a=document.createElement('a');
    a.href=url;
    a.download=(draftNameInput.value.trim()||'field-draft')+'.png';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  });

  // --- Costing hookup placeholder -----------------------------------------------------

  sendAreasToCostingBtn.addEventListener('click',()=>{
    setStatusHint('Coming soon.');
  });
// --- chunk end 19 ---------------------------------------------------------------
// --- Init chunk 20 -------------------------------------------------------------------

  // --- chunk 20.1a · Load-from-hash returns a boolean (prevents init override) --------

  function loadDraftFromHashIfAny(){
    const hash = window.location.hash ? window.location.hash.slice(1) : '';
    if(!hash) return false;

    const name = decodeURIComponent(hash);
    const map = loadAllDrafts();
    if(map[name]){
      draftNameInput.value = name;
      draftJobIdInput.value = map[name].meta && map[name].meta.jobId || '';
      applyImportedSnapshot(normalizeCanvasSnapshot(map[name]));
      return true;
    }
    return false;
  }

  // --- chunk end 20.1a ---------------------------------------------------------------

  // --- chunk 20.1b · Line Tool label sync helper (UI only) ----------------------------

  function syncLineToolLabel(){
    const s = (state.lineStyle || 'solid').toLowerCase();
    const label =
      (s === 'dashed') ? 'Dashed' :
      (s === 'centerline') ? 'Centerline' :
      (s === 'custom') ? 'Custom' : 'Solid';

    if (lineStyleLabel) lineStyleLabel.textContent = label;

    // Unified dropdown: keep the <select> in sync
    if (lineStyleSelect) lineStyleSelect.value = s;
  }

  // --- chunk end 20.1b ---------------------------------------------------------------

// SUB-CHUNK 17.I END — Draft record save/load + label sync
  // SUB-CHUNK 20.S2 BEGIN — Marker Integrity Sentinel (SEC)
  // Purpose: detect structural drift in safety markers/cognitive layers (non-crypto; runway-safe).
  // NOTE: Runway often has secureContext=false, so this is pattern-based, not signature-based.
  function runMarkerIntegritySentinel(opts){
    opts = opts || {};
    // Throttle: sentinel should not run in hot paths.
    const now = Date.now();
    if (runMarkerIntegritySentinel._last && (now - runMarkerIntegritySentinel._last) < 5000) return { ok:true, issues:[], throttled:true };
    runMarkerIntegritySentinel._last = now;
    const emitIncident = (opts.emitIncident !== false);
    const quietOK = !!opts.quietOK;
    
    try{
      const html = document.documentElement ? document.documentElement.outerHTML : '';
      const issues = [];

      // 1) Duplicate DPA blocks (each NAME:DPA@X must be unique)
      const dpaRe = /\[COGNITIVE_LAYER:CL-02\|NAME:(DPA@[^\]|]+)[^\]]*\]\s*STOP:/g;
      const seen = Object.create(null);
      let m;
      while ((m = dpaRe.exec(html)) !== null) {
        const name = String(m[1] || '').trim();
        if (!name) continue;
        seen[name] = (seen[name] || 0) + 1;
      }
      const dup = Object.entries(seen).filter(([,c])=>c>1);
      if (dup.length){
        issues.push('Duplicate DPA blocks: ' + dup.map(([n,c])=>`${n}×${c}`).join(', '));
      }

      // 2) Critical PROTECT anchors (structural closers)
      const protectNeedles = [
        'PROTECT: DO NOT DELETE / DO NOT MOVE — closes .work-layout grid',
        'PROTECT: DO NOT DELETE / DO NOT MOVE — closes <main> structural wrapper'
      ];
      protectNeedles.forEach(s=>{
        if (!html.includes(s)) issues.push('Missing PROTECT anchor: ' + s);
      });

      // 3) Key headers expected to exist (navigation sanity)
      const headerNeedles = [
        'CSS PART 13',
        'SCRIPT PART 1',
        'SCRIPT PART 2',
        'chunk 5',
        'chunk 20'
      ];
      headerNeedles.forEach(s=>{
        if (!html.includes(s)) issues.push('Missing expected header token: ' + s);
      });

      // 4) SEC manifest must never render as visible page text (comment leak guard)
      try{
        const bodyText = (document.body && document.body.innerText) ? document.body.innerText : '';
        if (bodyText.includes('SEC-MANIFEST') || bodyText.includes('CHANGE RECEIPT') || bodyText.includes('FILE_SHA256:') || bodyText.includes('BLOCK:')) {
          issues.push('SEC manifest appears in visible text (comment boundary leak)');
        }
      }catch(_){}

      // Report
      if (issues.length){
        console.warn('[SEC][S2] Marker Integrity WARN', { issues });
        try{
          if (emitIncident && window.FO_DIAG){
            FO_DIAG.raiseIncident({
              severity: 'SEC_WARN',
              code: 'MARKER_INTEGRITY',
              scope: 'security',
              summary: 'SEC WARN: marker integrity',
              key: issues.join('|'),
              details: { issues: issues.slice(0, 20) }
            });
          }
        }catch(_){ }
return { ok:false, issues };
      } else {
        if (!quietOK) console.info('[SEC][S2] Marker Integrity OK');
        return { ok:true, issues:[] };
      }
    }catch(err){
      console.warn('[SEC][S2] Marker Integrity ERROR', err);
      try{
        if (emitIncident && window.FO_DIAG){
          FO_DIAG.raiseIncident({ severity:'SEC_WARN', code:'MARKER_INTEGRITY_ERROR', scope:'security', summary:'SEC WARN: marker sentinel error', key:String(err&&err.message||err), details:{ message:String(err&&err.message||err) } });
        }
      }catch(_){ }
      return { ok:false, issues:['sentinel error'] };
    }
  }
  // SUB-CHUNK 20.S2 END — Marker Integrity Sentinel (SEC)

  /* Phase-4C: resize binding handled by requestResizeCanvas() (near resizeCanvas). */

  // Initial setup
  // Diagnostics Sentry init (event-driven)
  try{ if (window.FO_DIAG && typeof FO_DIAG.initSentry === 'function') FO_DIAG.initSentry(); }catch(_){ }
  requestResizeCanvas();

  const didLoadFromHash = loadDraftFromHashIfAny();

  // Startup contract: always begin in Inspect/Nav with nothing armed.
  // (No snap, no axis lock, no auto/finish, no edit mode; preserve geometry/view.)
  try {
    if (typeof setTool === 'function') setTool('inspect'); else state.tool = 'inspect';
  } catch(_) { state.tool = 'inspect'; }
  try { if (typeof setEditMode === 'function') setEditMode('none'); else state.editMode = 'none'; } catch(_) { state.editMode = 'none'; }
  state.axisLock = false;
  state.snapEnabled = false;
  state.autoCommitLine = false;
  // Keep snapMode as-is; Snap OFF means it won't apply.

  // Base UI fields
  gridPxInput.value = state.gridPx;

  // SUB-CHUNK 20.2A BEGIN — Context toolspace defaults (no overwrite)
  // NOTE: The Tool row hosts #statusMode inside #toolspaceNA. Do NOT set toolspaceNA.textContent here.
  // SUB-CHUNK 20.2A END — Context toolspace defaults (no overwrite)

  // Coordinate-model hint (UX fix: screen-space Y grows downward)
  if (statusCursor) {
    statusCursor.title = 'Coordinate model: X increases to the right, Y increases downward (screen-space).';
  }
  const axisIndicator = document.getElementById('axisIndicator');
  if (axisIndicator) {
    axisIndicator.title = 'Screen coordinates: X →, Y ↓';
  }

  // Ensure all unit labels + status reflect current unitsMode (also updates scale label)
  updateStatusUnits();

  // Sync unit-sensitive input VALUES (metersPerGridInput + snapStepInput) to current units
  // (ft display when imperial, m display when metric)
  syncUnitSensitiveInputs();

  // Sync Line Tool label BEFORE tool selection (pure UI)
  syncLineToolLabel();

  // Tool defaults and rendering:
  // - If a draft loaded from hash, do NOT override its restored tool.
  // - Otherwise, default to Inspect.
  if (!didLoadFromHash) {
    setTool('inspect');
  } else {
    // applyDraftSnapshot already calls setTool(), but keep UI in sync defensively
    syncLineToolLabel();
  }

  // Keep axis lock button appearance consistent with state
  if (lockAxisBtn) lockAxisBtn.classList.toggle('active', !!state.axisLock);

  updateFeatureSelect();
  refreshSelectedInspector();

  // Ensure toolspace visibility matches current snapMode
  updateToolspace();

  // SEC: marker integrity sentinel
  // NOTE: Heavy structural scan is NOT run in hot UI paths. It runs at startup (FO_DIAG.initSentry)
  // and on-demand when generating a report.
  // runMarkerIntegritySentinel();

  // Apply UI theme + wire display controls
  loadDisplayPrefs();
  applyButtonSkinVars();
  applyUITheme();
  wireDisplayControls();
  syncDisplayControls();


  // Session recovery: offer restore of last unsaved session (if any) and install exit guards
  try{
    maybeOfferRestoreSession(!!didLoadFromHash);
  }catch(_){ }
  try{ installSessionExitGuards(); }catch(_){ }
  // Final draw
  draw();
  // --- chunk end 20 ---------------------------------------------------------------

/* ==== STEP2 FREE DRAW TOOL (points-only) BEGIN ==== */
(function(){
  const btn = document.getElementById('freeDrawBtn');
  if(!btn) return;

  btn.addEventListener('click', () => {
    // Toggle between freeDraw and inspect for convenience
    if (state.tool === 'freeDraw') setTool('inspect');
    else setTool('freeDraw');
  });
})();
 /* ==== STEP2 FREE DRAW TOOL (points-only) END ==== */

/* ==== STEP2 PROPERTIES TOGGLE PATCH (direct overlay) BEGIN ==== */
/*
  Purpose:
  - Make the topbar Properties button (#stackYBtn2) directly toggle the overlay right panel
    via body.show-right-panel (CSS truth).
  - Avoid reliance on the disabled legacy button (#toggleRightPanelBtn).
  - Keep tool/edit mode unchanged (UI-only).
*/
(function(){
  const btn   = document.getElementById('stackYBtn2');   // Topbar "Properties"
  const panel = document.getElementById('rightSidebar'); // Overlay panel
  if(!btn || !panel) return;

  const KEY = 'fc_showRightPanel';

  const syncUI = ()=>{
    const on = document.body.classList.contains('show-right-panel');
    btn.classList.toggle('active', on);
    btn.setAttribute('aria-pressed', on ? 'true' : 'false');
  };

  const setOpen = (on)=>{
    document.body.classList.toggle('show-right-panel', !!on);
    syncUI();
    try { localStorage.setItem(KEY, on ? '1' : '0'); } catch(_) {}
  };

  // PROTECT: Calibrate inspector top offset so it never covers header/topbar
  function calibrateRightDock(){
    const dock = document.getElementById('rightSidebar');
    const topbar = document.querySelector('.topbar');
    const header = document.querySelector('header');
    if(!dock) return;

    // Prefer actual bottom of topbar (includes header above if stacked)
    let bottom = 0;
    if(topbar){
      const r = topbar.getBoundingClientRect();
      bottom = Math.max(bottom, r.bottom);
    } else if(header){
      const r = header.getBoundingClientRect();
      bottom = Math.max(bottom, r.bottom);
    }

    // Small breathing room so it feels "below" the toolbar, not glued to it
    const pad = 10;
    const topPx = Math.max(80, Math.round(bottom + pad));
    document.documentElement.style.setProperty('--rightDockTop', topPx + 'px');
  }

  // PROTECT: Run dock calibration now and on viewport changes
  calibrateRightDock();
  try { window.addEventListener('resize', calibrateRightDock, {passive:true}); } catch(_){}
  try { if(window.visualViewport){ window.visualViewport.addEventListener('resize', calibrateRightDock, {passive:true}); } } catch(_){}
  // Re-run once after layout settles (fonts/metrics)
  try { setTimeout(calibrateRightDock, 50); setTimeout(calibrateRightDock, 250); } catch(_){}
  // Restore last state (best-effort; safe if storage unavailable)
  try {
    const saved = localStorage.getItem(KEY);
    if (saved === '1') document.body.classList.add('show-right-panel');
  } catch(_) {}
  syncUI();

  // Toggle on click (do NOT change tool/edit mode)
  btn.addEventListener('click', (e)=>{
    try { e.preventDefault(); } catch(_) {}
    setOpen(!document.body.classList.contains('show-right-panel'));
  });

  // ESC closes panel (desktop convenience; harmless on mobile)
  document.addEventListener('keydown', (e)=>{
    if (e && e.key === 'Escape' && document.body.classList.contains('show-right-panel')){
      setOpen(false);
    }
  });

  // Close button inside inspector header (keeps same truth path)
  const closeBtn = document.getElementById('propCloseBtn');
  if (closeBtn){
    closeBtn.addEventListener('click', (e)=>{
      try { e.preventDefault(); e.stopPropagation(); } catch(_) {}
      setOpen(false);
    });
  }

})();
/* ==== STEP2 PROPERTIES TOGGLE PATCH (direct overlay) END ==== */

/* ==== STEP2 LINE DEFAULTS PANEL (persistent) BEGIN ==== */
(function(){
  const KEY = 'fc_lineDefaults_v1';
  if (!window.state) window.state = {};
  if (!state.lineDefaults) state.lineDefaults = { widthPx: null, color: null, style: 'auto' };

  const w = (typeof lineDefaultWidthInput !== 'undefined') ? lineDefaultWidthInput : null;
  const c = (typeof lineDefaultColorInput !== 'undefined') ? lineDefaultColorInput : null;
  const ct = (typeof lineDefaultColorText !== 'undefined') ? lineDefaultColorText : null;
  const s = (typeof lineDefaultStyleSelect !== 'undefined') ? lineDefaultStyleSelect : null;

  const pv = document.getElementById('lineDefaultPreviewLine');
  const pm = document.getElementById('lineDefaultPreviewMeta');
  const dr = document.getElementById('lineDefaultDashRow');
  const di = document.getElementById('lineDefaultDashInput');

  if (!w || !c || !ct || !s) return;

  const clampColor = (hex)=>{
    if (typeof hex !== 'string') return null;
    const h = hex.trim();
    if (/^#[0-9a-fA-F]{6}$/.test(h)) return h.toLowerCase();
    return null;
  };

  const updatePreview = ()=>{
    if (!pv) return;
    const width = Number.isFinite(Number(state.lineDefaults.widthPx)) ? Math.max(0.5, Number(state.lineDefaults.widthPx)) : 2;
    const col = clampColor(state.lineDefaults.color) || '#ffffff';
    const style = String(state.lineDefaults.style || 'auto');

    if (pm){
      const labelStyle = (style === 'auto') ? 'auto' : style;
      pm.textContent = `${width}px · ${labelStyle}`;
    }

    // Reset
    pv.style.backgroundImage = 'none';
    pv.style.height = '0px';
    pv.style.borderTopWidth = `${width}px`;
    pv.style.borderTopColor = col;

    if (style === 'dashed'){
      // Truthy dashed preview: match canvas dash [10,8]
      pv.style.borderTopStyle = 'none';
      pv.style.borderTopWidth = '0px';
      pv.style.height = `${Math.max(2, Math.round(width))}px`;
      pv.style.backgroundImage = `repeating-linear-gradient(90deg, ${col} 0 10px, transparent 10px 18px)`;
    } else if (style === 'centerline'){
      // Truthy centerline preview: match canvas dash [18,6,3,6]
      pv.style.borderTopStyle = 'none';
      pv.style.borderTopWidth = '0px';
      pv.style.height = `${Math.max(2, Math.round(width))}px`;
      pv.style.backgroundImage = `repeating-linear-gradient(90deg, ${col} 0 18px, transparent 18px 24px, ${col} 24px 27px, transparent 27px 33px)`;
    } else if (style === 'custom'){
      const parsed = (typeof parseDashList === 'function') ? parseDashList(state.lineDefaults.customDash) : null;
      const a = (parsed && parsed.length >= 2) ? parsed : [10,8];
      const on = Math.max(1, Math.round(a[0]));
      const off = Math.max(1, Math.round(a[1]));
      pv.style.borderTopStyle = 'none';
      pv.style.borderTopWidth = '0px';
      pv.style.height = `${Math.max(2, Math.round(width))}px`;
      pv.style.backgroundImage = `repeating-linear-gradient(90deg, ${col} 0 ${on}px, transparent ${on}px ${on+off}px)`;
    } else {
      // solid + auto
      pv.style.borderTopStyle = 'solid';
    }
  };

const load = ()=>{
    try{
      const raw = localStorage.getItem(KEY);
      if (!raw) return;
      const obj = JSON.parse(raw);
      if (obj && typeof obj === 'object'){
        if (Number.isFinite(Number(obj.widthPx))) state.lineDefaults.widthPx = Number(obj.widthPx);
        const col = clampColor(obj.color);
        if (col) state.lineDefaults.color = col;
        if (typeof obj.style === 'string') state.lineDefaults.style = obj.style;
        if (typeof obj.customDash === 'string') state.lineDefaults.customDash = obj.customDash;
      }
    }catch(_){}
  };

  const save = ()=>{
    try{
      localStorage.setItem(KEY, JSON.stringify(state.lineDefaults));
    }catch(_){}
  };

  const syncUI = ()=>{
    const width = Number.isFinite(Number(state.lineDefaults.widthPx)) ? Number(state.lineDefaults.widthPx) : '';
    w.value = String(width);
    const col = clampColor(state.lineDefaults.color) || '#ffffff';
    c.value = col;
    ct.textContent = col;
    s.value = (state.lineDefaults.style || 'auto');
    if (dr && di){
      const st = String(state.lineDefaults.style || 'auto');
      dr.style.display = (st === 'custom') ? '' : 'none';
      di.value = String(state.lineDefaults.customDash || '10, 8');
    }
    updatePreview();
  };

  load();
  syncUI();

  w.addEventListener('input', ()=>{
    const v = Number(w.value);
    state.lineDefaults.widthPx = Number.isFinite(v) ? v : null;
    save();
    updatePreview();
  });

  c.addEventListener('input', ()=>{
    const col = clampColor(c.value) || '#ffffff';

    // If a line-like feature (road/lane) is selected, apply to the selection (single or multi).
    const ids = (state && state.multiSelectEnabled && Array.isArray(state.selectedIds) && state.selectedIds.length)
      ? state.selectedIds.slice()
      : [state.selectedId];

    const targets = (Array.isArray(state.features) ? ids.map(id=>state.features.find(x=>x && x.id===id)) : [])
      .filter(f=>f && (f.type === 'road' || f.type === 'lane'));

    if (targets.length){
      // Deny locked edits if any target is locked.
      for (const t of targets){
        if (typeof _isFeatureLocked === 'function' && _isFeatureLocked(t)){
          if (typeof _denyLockedEdit === 'function') _denyLockedEdit('stroke', t);
          return;
        }
      }

      pushHistory('strokeColor');
      for (const t of targets){
        t.strokeColor = col;
      }
      // Also update defaults so new lines match and the preview stays truthful.
      state.lineDefaults.color = col;
      ct.textContent = col;
      save();
      updatePreview();
      if (typeof draw === 'function') draw();
      if (typeof refreshSelectedInspector === 'function') refreshSelectedInspector();
      return;
    }

    // No selected line-like feature: treat as persistent defaults for new lines.
    state.lineDefaults.color = col;
    ct.textContent = col;
    save();
    updatePreview();
  });

  s.addEventListener('change', ()=>{
    const st = String(s.value || 'auto');
    state.lineDefaults.style = st;
    if (st === 'custom'){
      if (!state.lineDefaults.customDash) state.lineDefaults.customDash = '10, 8';
    }
    if (dr && di){ dr.style.display = (st === 'custom') ? '' : 'none'; }
    save();
    updatePreview();
  });

  if (di){
    di.addEventListener('input', ()=>{
      state.lineDefaults.customDash = String(di.value || '');
      // If user starts typing, force style to custom for truth.
      if (state.lineDefaults.style !== 'custom'){
        state.lineDefaults.style = 'custom';
        if (s) s.value = 'custom';
        if (dr) dr.style.display = '';
      }
      save();
      updatePreview();
    });
  }

})();

/* ==== CHUNK 19.2ab MEASURE DEFAULTS PANEL (persistent) BEGIN ==== */
(function(){
  const KEY = 'fc_measureDefaults_v1';
  if (!window.state) window.state = {};
  if (!state.measureDefaults) state.measureDefaults = { widthPx: 1.5, color: '#a855f7', style: 'auto', customDash: '10,8', mode: 'distance', decimals: 2 };

  const w = (typeof measureDefaultWidthInput !== 'undefined') ? measureDefaultWidthInput : null;
  const c = (typeof measureDefaultColorInput !== 'undefined') ? measureDefaultColorInput : null;
  const ct = (typeof measureDefaultColorText !== 'undefined') ? measureDefaultColorText : null;
  const s = (typeof measureDefaultStyleSelect !== 'undefined') ? measureDefaultStyleSelect : null;
  const dr = document.getElementById('measureDefaultDashRow');
  const di = document.getElementById('measureDefaultDashInput');
  const msel = (typeof measureDefaultModeSelect !== 'undefined') ? measureDefaultModeSelect : null;
  const dsel = (typeof measureDefaultDecimalsInput !== 'undefined') ? measureDefaultDecimalsInput : null;

  const pv = document.getElementById('measureDefaultPreviewLine');
  const pc = document.getElementById('measureDefaultPreviewCanvas');
  const pm = document.getElementById('measureDefaultPreviewMeta');
  const pl = document.getElementById('measureDefaultPreviewLabel');

  if (!w || !c || !ct || !s || !msel || !dsel) return;

  const clampColor = (hex)=>{
    if (typeof hex !== 'string') return null;
    const h = hex.trim().toLowerCase();
    if (!/^#[0-9a-f]{6}$/.test(h)) return null;
    return h;
  };

const _parseDashList = (s)=>{
  try{
    const parts = String(s||'').trim().replace(/\s+/g,',').split(',').map(v=>Number(v.trim())).filter(n=>Number.isFinite(n) && n>0);
    return parts.length ? parts : null;
  }catch(_){ return null; }
};

const _drawMeasureDefaultsPreview = ()=>{
  if (!pc) return;
  const dpr = window.devicePixelRatio || 1;
  const rect = pc.getBoundingClientRect();
  const cw = Math.max(10, Math.round(rect.width));
  const ch = Math.max(10, Math.round(rect.height));
  pc.width = Math.round(cw * dpr);
  pc.height = Math.round(ch * dpr);
  const ctx = pc.getContext('2d');
  if (!ctx) return;

  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,cw,ch);

  const width = Number.isFinite(Number(state.measureDefaults.widthPx)) ? Math.max(0.5, Number(state.measureDefaults.widthPx)) : 1.5;
  const col = clampColor(state.measureDefaults.color) || '#a855f7';
  const style = String(state.measureDefaults.style || 'auto');

  // Canonical presets used by the inspector (truthful mapping)
  const DASH_DASHED = [10,8];
  const DASH_CENTER = [18,6,3,6];

  let dash = null;
  if (style === 'solid') dash = null;
  else if (style === 'dashed') dash = DASH_DASHED;
  else if (style === 'centerline') dash = DASH_CENTER;
  else if (style === 'custom') dash = _parseDashList(state.measureDefaults.customDash) || DASH_DASHED;
  else dash = DASH_DASHED; // auto

  // Draw single preview line (truthful: measures are single-stroke)
  const pad = 10;
  const y = Math.round(ch*0.62);

  ctx.strokeStyle = col;
  ctx.lineWidth = width;
  ctx.lineCap = 'round';
  if (dash && dash.length) ctx.setLineDash(dash);
  else ctx.setLineDash([]);

  ctx.beginPath();
  ctx.moveTo(pad, y);
  ctx.lineTo(cw-pad, y);
  ctx.stroke();

  ctx.setLineDash([]);
};

  const save = ()=>{
    try{ localStorage.setItem(KEY, JSON.stringify(state.measureDefaults)); }catch(_){}
  };

  const load = ()=>{
    try{
      const raw = localStorage.getItem(KEY);
      if (!raw) return;
      const obj = JSON.parse(raw);
      if (!obj || typeof obj !== 'object') return;

      if (Number.isFinite(Number(obj.widthPx))) state.measureDefaults.widthPx = Number(obj.widthPx);
      if (typeof obj.color === 'string') state.measureDefaults.color = clampColor(obj.color) || state.measureDefaults.color;
      if (typeof obj.style === 'string') state.measureDefaults.style = String(obj.style || 'auto');
      if (typeof obj.customDash === 'string') state.measureDefaults.customDash = String(obj.customDash || state.measureDefaults.customDash || '10,8');
      if (typeof obj.mode === 'string') state.measureDefaults.mode = String(obj.mode || 'distance');
      if (Number.isFinite(Number(obj.decimals))) state.measureDefaults.decimals = Math.max(0, Math.min(6, Math.round(Number(obj.decimals))));
    }catch(_){}
  };

  const updatePreview = ()=>{
    const width = Number.isFinite(Number(state.measureDefaults.widthPx)) ? Math.max(0.5, Number(state.measureDefaults.widthPx)) : 1.5;
    const col = clampColor(state.measureDefaults.color) || '#a855f7';
    const style = String(state.measureDefaults.style || 'auto');
    const mode = String(state.measureDefaults.mode || 'distance');
    const dec = Number.isFinite(Number(state.measureDefaults.decimals)) ? Math.max(0, Math.min(6, Math.round(Number(state.measureDefaults.decimals)))) : 2;

    if (pm){
      let st = (style === 'auto') ? 'auto' : style;
      if (style === 'custom') st = `custom(${String(state.measureDefaults.customDash||'').trim()||'10,8'})`;
      pm.textContent = `${width}px · ${st} · ${mode} · ${dec}dp`;
    }

    if (pv){
      // Reset
      pv.style.backgroundImage = 'none';
      pv.style.height = '0px';
      pv.style.borderTopWidth = `${width}px`;
      pv.style.borderTopColor = col;

      if (style === 'dashed'){
        pv.style.borderTopStyle = 'dashed';
      } else if (style === 'solid'){
        pv.style.borderTopStyle = 'solid';
      } else if (style === 'custom'){
        // Preview can't render true dash arrays via CSS borders; treat as dashed but show meta
        pv.style.borderTopStyle = 'dashed';
      } else {
        // auto: match default measure styling
        pv.style.borderTopStyle = 'dashed';
      }
    }

    if (pl){
      const sampleLen = (12.34567).toFixed(dec);
      const sampleAng = (37.89).toFixed(dec);
      let txt = '';
      if (mode === 'none') txt = '';
      else if (mode === 'distance') txt = `${sampleLen}`;
      else if (mode === 'angle') txt = `${sampleAng}°`;
      else txt = `${sampleLen} · ${sampleAng}°`;
      pl.textContent = txt;
      pl.style.color = col;
    }

    _drawMeasureDefaultsPreview();
  };

  const applyToUI = ()=>{
    w.value = Number.isFinite(Number(state.measureDefaults.widthPx)) ? String(state.measureDefaults.widthPx) : '1.5';
    c.value = clampColor(state.measureDefaults.color) || '#a855f7';
    ct.value = clampColor(state.measureDefaults.color) || '#a855f7';
    s.value = String(state.measureDefaults.style || 'auto');
    if (di) di.value = String(state.measureDefaults.customDash || '10,8');
    if (dr) dr.style.display = (String(state.measureDefaults.style || 'auto') === 'custom') ? '' : 'none';
    msel.value = String(state.measureDefaults.mode || 'distance');
    dsel.value = String(state.measureDefaults.decimals ?? 2);
  };

  load();
  applyToUI();
  updatePreview();

  // Width
  w.addEventListener('change', ()=>{
    state.measureDefaults.widthPx = Math.max(0.5, Number(w.value||1.5));
    save(); updatePreview(); requestDraw?.();
  });

  // Color (picker)
  c.addEventListener('input', ()=>{
    const col = clampColor(c.value) || '#a855f7';
    state.measureDefaults.color = col;
    ct.value = col;
    save(); updatePreview(); requestDraw?.();
  });

  // Color (text)
  ct.addEventListener('change', ()=>{
    const col = clampColor(ct.value) || clampColor(state.measureDefaults.color) || '#a855f7';
    state.measureDefaults.color = col;
    c.value = col;
    ct.value = col;
    save(); updatePreview(); requestDraw?.();
  });

  // Style
  s.addEventListener('change', ()=>{
    const val = String(s.value || 'auto');
    state.measureDefaults.style = val;
    if (dr) dr.style.display = (val === 'custom') ? '' : 'none';
    // Ensure a sane default exists when switching to custom
    if (val === 'custom' && (!state.measureDefaults.customDash || String(state.measureDefaults.customDash).trim().length < 3)){
      state.measureDefaults.customDash = (di && di.value) ? String(di.value) : '10,8';
    }
    save(); updatePreview(); requestDraw?.();
  });

  // Custom dash
  if (di){
    di.addEventListener('change', ()=>{
      state.measureDefaults.customDash = String(di.value || '').trim() || '10,8';
      save(); updatePreview(); requestDraw?.();
    });
  }
// Label mode
  msel.addEventListener('change', ()=>{
    state.measureDefaults.mode = String(msel.value || 'distance');
    save(); updatePreview(); requestDraw?.();
  });

  // Decimals
  dsel.addEventListener('change', ()=>{
    const v = Math.max(0, Math.min(6, Math.round(Number(dsel.value||2))));
    state.measureDefaults.decimals = v;
    dsel.value = String(v);
    save(); updatePreview(); requestDraw?.();
  });
})();
/* ==== CHUNK 19.2ab MEASURE DEFAULTS PANEL (persistent) END ==== */

/* ==== CHUNK 19.2b AREA DEFAULTS PANEL (persistent) BEGIN ==== */
(function(){
  const KEY = 'fc_areaDefaults_v1';
  if (!window.state) window.state = {};
  if (!state.areaDefaults) state.areaDefaults = { color: '#38bdf8', opacity: 0.12 };

  const c = (typeof areaDefaultColorInput !== 'undefined') ? areaDefaultColorInput : null;
  const ct = (typeof areaDefaultColorText !== 'undefined') ? areaDefaultColorText : null;
  const o = (typeof areaDefaultOpacityRange !== 'undefined') ? areaDefaultOpacityRange : null;
  const opct = (typeof areaDefaultOpacityPct !== 'undefined') ? areaDefaultOpacityPct : null;

  if (!c || !ct || !o) return;

  const clampColor = (hex)=>{
    if (typeof hex !== 'string') return null;
    const h = hex.trim();
    if (/^#[0-9a-fA-F]{6}$/.test(h)) return h.toLowerCase();
    return null;
  };

  const clampPct = (v)=>{
    const n = Number(v);
    if (!Number.isFinite(n)) return null;
    return Math.max(0, Math.min(100, n));
  };

  // If an area is selected, treat this panel as "selected area fill".
  // If not, it edits persistent defaults (for *new* areas).
  const getSelectedAreas = ()=>{
    if (!state || !Array.isArray(state.features)) return [];
    const ids = (state.multiSelectEnabled && Array.isArray(state.selectedIds) && state.selectedIds.length)
      ? state.selectedIds
      : [state.selectedId];
    return ids.map(id=>state.features.find(x=>x && x.id===id)).filter(f=>f && f.type==='area');
  };
  const getSelectedArea = ()=> getSelectedAreas()[0] || null;

  const applyToUI = ()=>{
    const active = getSelectedArea();
    const col = clampColor(active && active.fillColor) || clampColor(state.areaDefaults.color) || '#38bdf8';
    const baseOp = (active && typeof active.fillOpacity === 'number' && isFinite(active.fillOpacity)) ? active.fillOpacity : (Number(state.areaDefaults.opacity)||0.12);
    const pct = clampPct(Math.round(baseOp * 100)) ?? 12;
    c.value = col;
    ct.value = col;
    o.value = String(pct);
    if (opct) opct.textContent = `${pct}%`;
  };

  // Expose for selection refresh
  window.__fc_applyAreaPanelUI = applyToUI;

  const saveLS = ()=>{
    try{ localStorage.setItem(KEY, JSON.stringify(state.areaDefaults)); }catch(_){}
  };

  const loadLS = ()=>{
    try{
      const raw = localStorage.getItem(KEY);
      if (!raw) return;
      const obj = JSON.parse(raw);
      if (obj && typeof obj === 'object'){
        if (typeof obj.color === 'string') state.areaDefaults.color = obj.color;
        if (typeof obj.opacity === 'number') state.areaDefaults.opacity = obj.opacity;
      }
    }catch(_){}
  };

  loadLS();
  applyToUI();

  const setColor = (val)=>{
    const col = clampColor(val);
    if (!col) return;

    // Always update persistent defaults (so the next new area uses it)
    state.areaDefaults.color = col;
    saveLS();

    // If areas are selected, also apply to selection (multi-select aware)
    const actives = getSelectedAreas();
    if (actives && actives.length){
      for (const a of actives){
        a.fillColor = col;
      }
    }

    c.value = col;
    ct.value = col;
    draw();
  };

  const setOpacityPct = (val)=>{
    const pct = clampPct(val);
    if (pct == null) return;

    // Always update persistent defaults (so the next new area uses it)
    state.areaDefaults.opacity = pct / 100;
    saveLS();

    // If areas are selected, also apply to selection (multi-select aware)
    const actives = getSelectedAreas();
    if (actives && actives.length){
      for (const a of actives){
        a.fillOpacity = pct / 100;
      }
    }

    if (opct) opct.textContent = `${pct}%`;
    draw();
  };

  c.addEventListener('input', ()=> setColor(c.value));
  ct.addEventListener('change', ()=> setColor(ct.value));
  o.addEventListener('input', ()=> setOpacityPct(o.value));
})();
 /* ==== CHUNK 19.2b AREA DEFAULTS PANEL (persistent) END ==== */
;
/* ==== STEP2 LINE DEFAULTS PANEL (persistent) END ==== */

/* ==== STEP2 PROPERTIES INSPECTOR COLLAPSIBLE SECTIONS BEGIN ==== */

(function(){
  const panel = document.getElementById('rightSidebar');
  if(!panel) return;

  const KEY = 'fc_propSection_';

  // Build collapsible chrome around each panel-section
  const sections = Array.from(panel.querySelectorAll('.panel-section'));
  sections.forEach((sec, i)=>{
    if(sec.dataset.collapsibleReady === '1') return;
    sec.dataset.collapsibleReady = '1';

    // Title host can be either a <h3> (section headers) or an existing .panel-title-row (Properties block)
    const rowEl = sec.querySelector('.panel-title-row');
    const h3El  = sec.querySelector('h3');
    const titleHost = rowEl || h3El;
    if(!titleHost) return;

    // Derive a stable name for persistence
    let titleText = '';
    if(rowEl){
      const t = rowEl.querySelector('.panel-title');
      titleText = (t ? t.textContent : rowEl.textContent || '').trim();
    } else {
      titleText = (h3El.textContent || '').trim();
    }
    titleText = titleText || ('section_' + i);
    const safeName = titleText.toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_+|_+$/g,'');
    const storeKey = KEY + safeName;

    // Header row:
    // - If .panel-title-row exists, reuse it as the header (keeps existing layout + close button).
    // - Otherwise, create a new header row and move <h3> into it.
    let head;
    if(rowEl){
      head = rowEl;
      head.classList.add('panel-section-head');
    } else {
      head = document.createElement('div');
      head.className = 'panel-section-head';
      head.appendChild(h3El);
    }

    // Body wrapper: move all nodes after the header into a body container for collapse
    const body = document.createElement('div');
    body.className = 'panel-section-body';

    // Collect nodes to move (everything after head within the section)
    const nodes = [];
    let cur = head.nextSibling;
    while(cur){
      const next = cur.nextSibling;
      nodes.push(cur);
      cur = next;
    }
    nodes.forEach(n=> body.appendChild(n));
    sec.appendChild(body);

    // Create toggle button (right-aligned)
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'panel-collapse-btn';
    btn.setAttribute('aria-label', 'Toggle section');
    btn.innerHTML = '<span class="chev">▾</span>';

    // Insert toggle at end of header row
    head.appendChild(btn);

    let open = true;
    try {
      const v = localStorage.getItem(storeKey);
      if(v === '0') open = false;
    } catch(_){}

    const apply = ()=>{
      sec.classList.toggle('collapsed', !open);
      btn.setAttribute('aria-expanded', open ? 'true' : 'false');
      btn.querySelector('.chev').textContent = open ? '▾' : '▸';
      try { localStorage.setItem(storeKey, open ? '1' : '0'); } catch(_){}
    };

    btn.addEventListener('click', (e)=>{
      e.preventDefault();
      open = !open;
      apply();
    });

    // Allow tapping header row (except interactive controls) to toggle
    head.addEventListener('click', (e)=>{
      if(e.target && (e.target.closest('button') || e.target.closest('input') || e.target.closest('select') || e.target.closest('textarea'))) return;
      open = !open;
      apply();
    });

    apply();
  });
})();
 /* ==== STEP2 PROPERTIES INSPECTOR COLLAPSIBLE SECTIONS END ==== */

/* --- PATCH: Create group must open Properties panel + focus Group field (Phase2 hotfix) --- */
(function(){
  const btn = document.getElementById('topGroupCreateBtn');
  if (!btn) return;

  btn.addEventListener('click', ()=>{
    try { if (window.state && state.tool!=='inspect') setTool('inspect'); } catch(_) {}

    // Must have a selected object to create/nickname a group
    try{
      if (!window.state || !state.selectedId) {
        if (typeof setStatus === 'function') setStatus('Select an object first to create a group.');
        return;
      }
    }catch(_){}

    // Open Properties panel (rightSidebar) by forcing the body class
    try{
      document.body.classList.add('show-right-panel');
      try{ localStorage.setItem('fc_showRightPanel','1'); }catch(_){}
    }catch(_){}

    // Focus the Group field so user can name the group immediately
    setTimeout(()=>{
      try{
        const gi = document.getElementById('propGroupInput');
        if (!gi) return;
        gi.scrollIntoView({block:'center', inline:'nearest', behavior:'smooth'});
        gi.focus();
        if (gi.select) gi.select();
      }catch(_){}
    }, 60);
  }, true); // capture=true to ensure this runs even if earlier handlers stop propagation
})();

  // SCRIPT PART 2 END (LLM ANCHOR)

  // SCRIPT PART 2.4 END (LLM ANCHOR)
</script>

<!-- TRUNC_GUARD::BODY_END::BG_20260108 -->

<!-- GPT SELF-TEST BLOCK (Phase 6) BEGIN: contract integrity + export surface -->
<script>
(function(){
  const REQUIRED_IDS = ["roadCanvas", "canvasContainer", "draftNameInput", "saveDraftBtn", "loadDraftBtn", "deleteDraftBtn", "loadDraftSelect", "exportJsonBtn", "importJsonBtn", "importIntoCurrentBtn", "exportPngBtn", "importFileInput", "featureSelect", "gridPxInput", "metersPerGridInput", "snapStepInput", "lockAxisBtn", "autoCommitBtn", "autoCommitValue", "contextToolspace", "statusMode", "statusCursor", "statusUnits", "statusSnapMode", "undoBtn", "redoBtn", "deleteSelectedBtn", "clearAllBtn", "fullViewBtn", "exitFullViewBtn", "rightSidebar"];
  const REQUIRED_GLOBALS = ['FO_DIAG','FO_STATUS','state'];

  function runSelfTest(){
    const missingIds = REQUIRED_IDS.filter(id => !document.getElementById(id));
    const missingGlobals = REQUIRED_GLOBALS.filter(k => typeof window[k] === 'undefined');

    const ok = (missingIds.length === 0) && (missingGlobals.length === 0);
    const report = {
      ok,
      missingIds,
      missingGlobals,
      ts: new Date().toISOString()
    };

    try {
      window.FO_DIAG = window.FO_DIAG || {};
      window.FO_DIAG.selfTest = report;
    } catch (e) {}

    if (ok) {
      console.info('[FD SelfTest] OK');
    } else {
      console.warn('[FD SelfTest] FAIL', report);
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => setTimeout(runSelfTest, 0));
  } else {
    setTimeout(runSelfTest, 0);
  }
})();
</script>
<!-- GPT SELF-TEST BLOCK (Phase 6) END -->

<!-- PATCH BEGIN :: TOOLBOX HUB COMING SOON GUARD :: 20260117a -->
<script>
// Toolbox Hub guard: Field Draft is shippable standalone; Field Ops Hub may not exist yet.
(function(){
  function _wireHubComingSoon(){
    const a = document.querySelector('a.hub-link');
    if(!a) return;

    // Flip this to true (or remove this guard) once Field Ops Hub (index.html) ships alongside this app.
    const hubReady = (window.FIELDOPS_HUB_READY === true);
    if(hubReady) return;

    a.addEventListener('click', function(ev){
      try {
        ev.preventDefault();
        ev.stopPropagation();
      } catch(_){}

      const msg = [
        'Field Ops — coming soon.',
        '',
        'This button will open the Field Ops Hub once it is released.',
        'For now, Field Draft runs standalone.'
      ].join('\n');

      if (typeof window.fdAskYesNo === 'function') {
        // Reuse the existing transient modal system.
        try { window.fdAskYesNo(msg, 'OK', 'Close'); } catch(_) {}
      } else {
        // Hard fallback (should rarely be needed).
        try { alert('Field Ops — coming soon.'); } catch(_) {}
      }
    }, { capture: true });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', _wireHubComingSoon);
  } else {
    _wireHubComingSoon();
  }
})();
</script>
<!-- PATCH END :: TOOLBOX HUB COMING SOON GUARD :: 20260117a -->


<!-- PATCH BEGIN :: USER PRESET SYMBOLS PANEL DOM :: 20260115a -->
<!-- PROTECT: UI wrapper only. Must not alter engine contracts. -->
<div id="userPresetPanel" class="drop-panel" role="dialog" aria-label="User preset symbols" aria-hidden="true">
  <div class="preset-head">
    <div class="preset-title">User Preset Symbols</div>
    <button type="button" class="btn btn-ghost" id="userPresetCloseBtn" title="Close">✕</button>
  </div>

  <select id="userPresetSelect" aria-label="Preset list"></select>

  <div class="preset-actions">
    <button type="button" class="btn btn-soft" id="userPresetStampBtn">Stamp selected</button>
    <button type="button" class="btn btn-soft" id="userPresetSaveBtn">Save selection as preset</button>
    <button type="button" class="btn btn-soft" id="userPresetRenameBtn">Rename selected</button>
    <button type="button" class="btn btn-soft" id="userPresetDeleteBtn">Delete selected</button>
  </div>
</div>
<!-- PATCH END :: USER PRESET SYMBOLS PANEL DOM :: 20260115a -->


<!-- Transient Yes/No Modal (used for Import UX) -->
<div id="fdYesNoOverlay" aria-hidden="true">
  <div id="fdYesNoBox" role="dialog" aria-modal="true">
    <div id="fdYesNoMsg">?</div>
    <div id="fdYesNoBtns">
      <button class="btn btn-soft btn-no" id="fdYesNoBtnNo" type="button">No</button>
      <button class="btn btn-soft btn-yes" id="fdYesNoBtnYes" type="button">Yes</button>
    </div>
  </div>
</div>

</body>

<!-- TRUNC_GUARD::HTML_END::XG_20260108 -->
</html>